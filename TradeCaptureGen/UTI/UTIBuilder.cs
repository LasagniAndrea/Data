#region Using Directives
using EFS.ACommon;
using EFS.Actor;
using EFS.Common;
using EfsML.Business;
using EfsML.Enum;
using FixML.Enum;
using System;
using System.Data;

#endregion Using Directives

namespace EFS.TradeInformation
{
    /// <summary>
    /// Class chargee de générer un UTI (EMIR)
    /// <para>La classe s'appuie un utiComponents</para>f
    /// </summary>
    /// FI 20140206 [19564] add Class 
    /// FI 20140919 [XXXXX] Modify (Cette classe s'appuie uniquement sur UTIComponents)
    public class UTIBuilder
    {
        /// <summary>
        /// Code BIC de CCeG 
        /// </summary>
        public const string BIC_CCeG = "CCEGITRR";

        /// <summary>
        /// Code BIC de EUREX
        /// </summary>
        public const string BIC_EUREX = "EUXCDEFF";
        
        /// <summary>
        /// Code BIC de LCHClearnetSA
        /// </summary>
        public const string BIC_LCHClearnetSA = "BACPFRPP";

        /// <summary>
        /// Code BIC de EURONEXT CLEARING
        /// </summary>
        /// FI 20240704 [WI987] Add
        public const string BIC_EURONEXTCLEARING = "CCEGITRRXXX";

        /// <summary>
        /// Code MIC de EUREX : "XEUR"
        /// </summary>
        public const string MIC_EXCHANGE_EUREX = "XEUR";
        /// <summary>
        /// ESMA Code Method 1 for establishing UTI: "E01"
        /// <para>Method 1:
        /// a. The characters 'E01'. The characters '000' will also be permitted but only for derivative contracts executed before 12 February 2015.
        /// b. The MIC code (ISO 10383) of the applicable trading venue. 
        /// c. A unique code generated by that trading venue or by a CCP used by that trading venue to clear the derivative contract.
        /// If the CCP generates the code and if derivative contracts executed on that trading venue could be cleared by more than one CCP, then measures should be put in place to avoid different CCPs generating the same value.
        /// </para>
        /// </summary>
        public const string ESMA_UTIMethod1 = "E01";
        /// <summary>
        /// ESMA Code Method 2 for establishing UTI: "E02"
        /// <para>Method 2:
        /// a. The characters 'E02'.
        /// b. The (20 character) Legal Entity Identifier of the generating entity (normally one of the parties to the trade).
        /// c. A unique code generated by the unique Trade ID generating entity.
        /// </para>
        /// </summary>
        public const string ESMA_UTIMethod2 = "E02";
        /// <summary>
        /// ESMA Code Method 3 for establishing UTI: "E03"
        /// <para>Method 3:
        /// a. The characters 'E03'.
        /// b. A unique code generated independently by both counterparties based on the pre-agreed set of information about the trade in such a way that both counterparties will arrive at the same code and that it would be unique with respect to any other report.
        /// The two counterparties are responsible for providing the same code. The information used should include Common Data from Table 2 of the Commission Delegated Regulation (EU) No 148/2013 and the Legal Entity Identifiers of the two counterparties.
        /// </para>
        /// </summary>
        public const string ESMA_UTIMethod3 = "E03";
        /// <summary>
        /// ESMA Code Method 4 for establishing UTI: "E04"
        /// <para>Method 4:
        /// Note that ESMA considers this approach as sub-optimal and therefore intends to maintain it as a possibility only for derivative contracts that have been or will be entered into before 12 February 2015:
        /// a. The characters 'E04' or '000'
        /// b. An identifier of the generating entity other than the full Legal Entity Identifier (normally one of the parties to the trade).
        /// c. A unique code generated by the unique Trade ID generating entity. For derivative contracts that are also reportable under the provisions of the Dodd-Frank Act the same value as would be reported under the Dodd-Frank Act, i.e. the Unique Swap Identifier, could be used.
        /// </para>
        /// </summary>
        public const string ESMA_UTIMethod4 = "E04";
        /// <summary>
        /// "{Missing}"
        /// </summary>
        public const string Missing = "{Missing}";

        /// <summary>
        /// 
        /// </summary>
        private enum PadMode
        {
            Left,
            Right
        }
        
        /// <summary>
        /// Obtient ou définit l'émetteur de l'UTI
        /// </summary>
        public Pair<UTIIssuerIdent, string> Issuer
        {
            get;
            set;
        }

        /// <summary>
        /// Obtient ou définit les informations nécessaires aux calculs des UTI/PUTI
        /// </summary>
        public UTIComponents UtiComponents
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public UTIBuilder() { }
        /// <summary>
        /// Constructeur 
        /// </summary>
        /// <param name="pComponents"></param>
        /// <param name="pIssuer"></param>
        public UTIBuilder(UTIComponents pComponents, Pair<UTIIssuerIdent, string> pIssuer)
        {
            UtiComponents = pComponents;
            Issuer = pIssuer;
        }

        /// <summary>
        ///  Retourne l'UTI avec ou sans son Issuer  
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pRule"></param>
        /// <param name="pMode"></param>
        /// <param name="pTypeSideAllocation"></param>
        /// <returns></returns>
        public string Generate(string pCS, UTIRule pRule, UTIBuildMode pMode, TypeSideAllocation pTypeSideAllocation)
        {
            string uti = BuildTradeId(pRule, pTypeSideAllocation, pCS = null);
            string ret;
            switch (pMode)
            {
                case UTIBuildMode.withoutIssuer:
                    ret = uti;
                    break;
                case UTIBuildMode.withIssuer:
                    string issuer = BuildIssuer(pCS, pRule);
                    ret = BuilResult(issuer, uti);
                    break;
                default:
                    throw new NotImplementedException($"Mode: {pMode} is not implemented.");
            }
            return ret;
        }

        /// <summary>
        /// Génère un UTI pour un trade posting/give-up selon la règle <paramref name="pRule"/>, l'issuer <paramref name="pIssuer"/>, et le type de partie (dealer, clearer) <paramref name="pSide"/> à laquelle cela s'applique 
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pComponents"></param>
        /// <param name="pRule">Représente la règle de calcul </param>
        /// <param name="pIssuer">Représente l'emetteur (valeur null autorisée, Spheres® auto détermine le code issuer)</param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        /// FI 20140919 [XXXXX] Modification de signature, il n'y a plus le paramètre pTradeIdentification 
        /// EG 20180307 [23769] Gestion dbTransaction
        public static string BuildTradeUTI(string pCS, UTIComponents pComponents, UTIRule pRule, Pair<UTIIssuerIdent, string> pIssuer, TypeSideAllocation pSide)
        {
            return BuildTradeUTI(pCS, null, pComponents, pRule, pIssuer, pSide);
        }

        /// <summary>
        /// Génère un UTI pour un trade posting/give-up selon la règle <paramref name="pRule"/>, l'issuer <paramref name="pIssuer"/>, et le type de partie (dealer, clearer) <paramref name="pSide"/> à laquelle cela s'applique 
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pComponents"></param>
        /// <param name="pRule">Représente la règle de calcul </param>
        /// <param name="pIssuer">Représente l'emetteur (valeur null autorisée, Spheres® auto détermine le code issuer)</param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        /// FI 20140919 [XXXXX] Modification de signature, il n'y a plus le paramètre pTradeIdentification 
        /// EG 20180307 [23769] Gestion dbTransaction
        public static string BuildTradeUTI(string pCS, IDbTransaction pDbTransaction, UTIComponents pComponents, UTIRule pRule, Pair<UTIIssuerIdent, string> pIssuer, TypeSideAllocation pSide)
        {
            UTIBuilder utiBuilder = new UTIBuilder(pComponents, pIssuer);

            string issuer = utiBuilder.BuildIssuer(pCS, pDbTransaction, pRule);
            string tradeId = utiBuilder.BuildTradeId(pRule, pSide, pCS);

            return BuilResult(issuer, tradeId);
        }

        /// <summary>
        ///  Génère un PUTI pour un trade posting/give-up selon la règle {pRule}, l'issuer {pIssuer} sur la base des informations présentes 
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pComponents"></param>
        /// <param name="pRule"></param>
        /// <param name="pIssuer"></param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        //FI 20140218 [19631] add Method
        //PL 20160428 [22107] EUREX C7 3.0 Release - New signature, add pSide
        // EG 20180307 [23769] Gestion dbTransaction
        public static string BuildPositionUTI(string pCS, UTIComponents pComponents, UTIRule pRule, Pair<UTIIssuerIdent, string> pIssuer, TypeSideAllocation pSide)
        {
            return BuildPositionUTI(pCS, null, pComponents, pRule, pIssuer, pSide);
        }
        // EG 20180307 [23769] Gestion dbTransaction
        public static string BuildPositionUTI(string pCS, IDbTransaction pDbTransaction, UTIComponents pComponents, UTIRule pRule, Pair<UTIIssuerIdent, string> pIssuer, TypeSideAllocation pSide)
        {
            UTIBuilder utiBuilder = new UTIBuilder(pComponents, pIssuer);

            string issuer = utiBuilder.BuildIssuer(pCS, pDbTransaction, pRule);
            string positionId = utiBuilder.BuildPositionId(pRule, pSide);

            return BuilResult(issuer, positionId);
        }

        /// <summary>
        /// Génération du code Unique Trade Identifier (UTI)
        /// </summary>
        /// <param name="pRule">Méthode de calcul</param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        // FI 20140307 [19689] add pDbTransaction
        // PL 20151029 add L2
        private string BuildTradeId(UTIRule pRule, TypeSideAllocation pSide, string pCS = null)
        {
            string ret;
            switch (pRule)
            {
                case UTIRule.CCP:
                case UTIRule.CCP_L2:
                case UTIRule.CCP_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildTradeIdUsingCCPMethod(pRule, pSide);
                    break;
                case UTIRule.CCEG:
                case UTIRule.CCEG_L2:
                case UTIRule.CCEG_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildTradeIdUsingCCEGMethod(pRule, pSide);
                    break;
                case UTIRule.EUREX:
                case UTIRule.EUREX_L2:
                case UTIRule.EUREX_L2_C7_3: //PL 20160426 [22107] Newness EUREX C7 3.0 Release
                case UTIRule.EUREX_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildTradeIdUsingEUREXMethod(pRule, pSide);
                    break;
                case UTIRule.LCHCLEARNETSA:
                case UTIRule.LCHCLEARNETSA_L2:
                case UTIRule.LCHCLEARNETSA_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildTradeIdUsingLCHCLEARNETSAMethod(pRule);
                    break;
                case UTIRule.EURONEXTCLEARING_REFIT: // FI 20240704 [WI987] Add
                    ret = BuildTradeIdUsingEURONEXTCLEARINGMethod(pRule);
                    break;
                case UTIRule.SPHERES:
                case UTIRule.SPHERES_L2:
                case UTIRule.SPHERES_REFIT: //LP 20240625 [WI936] UTI/PUTI REFIT
                    ret = BuildTradeIdUsingSPHERESMethod(pRule, pCS);
                    break;
                default:
                    throw new NotImplementedException($"UTI Rule: {pRule} is not implemented.");
            }

            return ret;
        }

        /// <summary>
        /// Retourne l'UTI selon la règle de la chambre de compensation relative au trade.
        /// </summary>
        /// <param name="pSide"></param>
        /// <returns></returns>
        // FI 20140307 [19689] add pDbTransaction
        // PL 20151029 add L2
        private string BuildTradeIdUsingCCPMethod(UTIRule pRule, TypeSideAllocation pSide)
        {
            string codeBIC = UtiComponents.Css_BIC;
            string identifier = UtiComponents.Css_Identifier;

            string ret;
            switch (codeBIC)
            {
                case BIC_CCeG:
                    ret = BuildTradeIdUsingCCEGMethod(pRule, pSide);
                    break;
                case BIC_EUREX:
                    ret = BuildTradeIdUsingEUREXMethod(pRule, pSide);
                    break;
                case BIC_LCHClearnetSA:
                    ret = BuildTradeIdUsingLCHCLEARNETSAMethod(pRule);
                    break;
                case BIC_EURONEXTCLEARING:  // FI 20240704 [WI987] Add
                    ret = BuildTradeIdUsingEURONEXTCLEARINGMethod(pRule);
                    break;
                default:
                    if (StrFunc.IsFilled(codeBIC))
                        throw new NotImplementedException($"Actor BIC: {codeBIC} is not implemented");
                    else
                        throw new NotImplementedException($"Actor Identifier: {identifier} is not implemented because its BIC code is unknown");
            }
            return ret;
        }

        /// <summary>
        /// Retourne l'UTI selon la règle CCeG
        /// </summary>
        /// <param name="pSide"></param>
        /// <returns></returns>
        // PL 20151029 add L2
        private string BuildTradeIdUsingCCEGMethod(UTIRule pRule, TypeSideAllocation pSide)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret;
            char fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');

            if (UTITools.IsREFITRULE(pRule))
            {
                //Trade Date
                string tradeDate = string.Empty;
                if (DtFunc.IsDateTimeFilled(UtiComponents.Trade_tradeDate))
                    tradeDate = DtFunc.DateTimeToString(UtiComponents.Trade_tradeDate, "yyMMdd");
                tradeDate = BuildElementaryElement(tradeDate, 6, PadMode.Right, fillerString);

                //Product ID
                string productId = UtiComponents.Asset_ISIN;
                productId = BuildElementaryElement(productId, 12, PadMode.Right, fillerString);

                //Trade Number
                string tradeNumber = UtiComponents.Trade_executionID;
                //FI 20140101 [19808] Pad left et '0'
                //tradeNumber = BuildElementaryElement(tradeNumber, 12, PadMode.Right, ' ');
                tradeNumber = BuildElementaryElement(tradeNumber, 12, PadMode.Left, '0');

                //Trade Side
                string tradeSide = UtiComponents.Trade_tradeSide.ToUpper().Substring(0, 2);
                tradeSide = BuildElementaryElement(tradeSide, 2, PadMode.Right, fillerString);

                ret = tradeDate + productId + tradeNumber + tradeSide;
            }
            else
            {

                //Participant Code (Abicode)
                string participantCode = string.Empty;
                int idAEntity = UtiComponents.Entity_id;
                if (idAEntity > 0)
                    participantCode = UtiComponents.Entity_CSSMemberCode;
                //participantCode = BuildElementaryElement(participantCode, 5, PadMode.Right, ' ');
                participantCode = BuildElementaryElement(participantCode, 5, PadMode.Left, '0');
                
                //Trade Date
                string tradeDate = string.Empty;
                if (DtFunc.IsDateTimeFilled(UtiComponents.Trade_tradeDate))
                    tradeDate = DtFunc.DateTimeToStringyyyyMMdd(UtiComponents.Trade_tradeDate);
                tradeDate = BuildElementaryElement(tradeDate, 8, PadMode.Right, fillerString);

                //Product ID
                string productId = UtiComponents.Asset_ISIN;
                productId = BuildElementaryElement(productId, 12, PadMode.Right, fillerString);

                //Trade Number
                string tradeNumber = UtiComponents.Trade_executionID;
                //FI 20140101 [19808] Pad left et '0'
                //tradeNumber = BuildElementaryElement(tradeNumber, 12, PadMode.Right, ' ');
                tradeNumber = BuildElementaryElement(tradeNumber, 12, PadMode.Left, '0');

                //Trade Indicator
                string tradeIndicator = string.Empty;
                if (StrFunc.IsFilled(UtiComponents.Trade_tradeSide))
                    tradeIndicator = StrFunc.FirstUpperCase(UtiComponents.Trade_tradeSide.Substring(0, 1));
                tradeIndicator = BuildElementaryElement(tradeIndicator, 1, PadMode.Right, fillerString);

                //Chain Indicator
                string chainIndicator = string.Empty;
                if (pSide == TypeSideAllocation.Dealer)
                    chainIndicator = "A";
                else if (pSide == TypeSideAllocation.Clearer)
                    chainIndicator = "C";
                chainIndicator = BuildElementaryElement(chainIndicator, 1, PadMode.Right, fillerString);

                ret = participantCode + tradeDate + productId + tradeNumber + tradeIndicator + chainIndicator;
            }
            return ret;
        }

        /// <summary>
        /// Retourne l'UTI selon la règle EUREX
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        //PL 20151029 add L2 
        //PL 20160426 [22107] Newness EUREX C7 3.0 Release
        private string BuildTradeIdUsingEUREXMethod(UTIRule pRule, TypeSideAllocation pSide)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret;
            char fillerString = '_';

            //UTI type indicator
            string UTITypeIndicator = "E";
            Boolean isValueW = false;
            if (StrFunc.IsFilled(UtiComponents.Trade_trdType))
            {
                Nullable<TrdTypeEnum> trdTypeEnum = UtiComponents.Trade_TrdTypeEnum;
                if (trdTypeEnum.HasValue)
                {
                    switch (trdTypeEnum.Value)
                    {
                        case TrdTypeEnum.BlockTrade:            //1
                        case TrdTypeEnum.EFP:                   //2    NB: this value is not used any more with C7 3.0 Release
                        case TrdTypeEnum.ExchangeForSwap:       //12
                        case TrdTypeEnum.OTC:                   //54
                        case TrdTypeEnum.ExchangeBasisFacility: //55
                            isValueW = true;
                            break;
                        default:
                            isValueW = false;
                            break;
                    }
                }
            }
            if (false == isValueW)
                isValueW = UtiComponents.DC_ContractTypeEnum.HasValue && (UtiComponents.DC_ContractTypeEnum.Value == DerivativeContractTypeEnum.FLEX);
            if (isValueW)
                UTITypeIndicator = "W";

            //clearing leg indicator
            string clearingLegIndicator = string.Empty;
            switch (pSide)
            {
                case TypeSideAllocation.Dealer:
                    clearingLegIndicator = "A";
                    break;
                case TypeSideAllocation.Clearer:
                    clearingLegIndicator = "C";
                    break;
                default:
                    throw new NotImplementedException($"Side: {pSide} is not implemented");
            }

            string execId;
            int len;
            switch (pRule)
            {
                case UTIRule.EUREX_L2_C7_3:
                    #region EUREX_L2_C7_3
                    // PL 20170406 [23055]
                    string transactionId = string.Empty;
                    string transactionIdSuffix = string.Empty;
                    
                    #if DEBUG
                    if (StrFunc.IsEmpty(UtiComponents.Trade_executionID))
                    {
                        transactionId = "ALERT";
                        transactionIdSuffix = "DEBUG";
                    }
                    #endif

                    //transaction ID & transaction ID suffix 
                    if (StrFunc.IsFilled(UtiComponents.Trade_executionID))
                    {
                        execId = UtiComponents.Trade_executionID;

                        //NB: Trade_executionID est constitué d'un suffixe de 10 car. et d'un radical de 1 à 19 car. Il est issu de la donnée TradeReportID.
                        //    TradeReportID (571) contains the unique transaction ID. The ID is variable length alphanumeric string with up to 29 characters, 
                        //    where the initial (up to) 19 characters represent the transaction ID and the last 10 digits represent the suffix, which increases with each adjust-ment. 
                        //    Note that the suffix is always numeric. The ID is globally unique across the clearing sys-tem, will not be changed for the lifetime of the transaction and will not be re-issued.
                        if (execId.Length < (19 + 10))
                        {
                            if (execId.Length < 10)
                            {
                                //Tip: on considère que le suffixe fait défaut. On le rajoute par défaut à "0", afin de ne pas empêcher la génération de l'UTI .
                                execId += new String('0', 10);
                            }
                            execId = new String('0', (19 + 10) - execId.Length) + execId;
                        }

                        //Prendre les 19 premiers caractères
                        len = 19;
                        transactionId = execId.Substring(0, len);

                        //Prendre les 10 caractères à partir du 20ème caractère (donc de 20 à 29)
                        len = 10;
                        transactionIdSuffix = execId.Substring(19, len);
                    }
                    transactionId = BuildElementaryElement(transactionId, 19, PadMode.Left, '0');
                    transactionIdSuffix = BuildElementaryElement(transactionIdSuffix, 10, PadMode.Left, '0');

                    ret = UTITypeIndicator + clearingLegIndicator + transactionId + transactionIdSuffix;
                    #endregion EUREX_L2_C7_3
                    break;

                case UTIRule.EUREX_REFIT: //LP 18062024 [WI970] UTI/PUTI EUREX_REFIT
                    #region EUREX_REFIT

                    string transactionIdNum = string.Empty;
                    string transactionIdNumSuffix = string.Empty;
                    string typeIndicator = "T";

                    //transaction ID & transaction ID suffix 
                    if (StrFunc.IsFilled(UtiComponents.Trade_executionID))
                    {
                        string executionID = UtiComponents.Trade_executionID;
                        if (executionID.Length < (19 + 10))
                        {
                            if (executionID.Length < 10)
                                executionID += new String('0', 10);
                            executionID = new String('0', (19 + 10) - executionID.Length) + executionID;
                        }

                        //Take the first 19 characters
                        len = 19;
                        transactionIdNum = executionID.Substring(0, len);

                        //Take 10 characters from the 20th character (so from 20 to 29)
                        len = 10;
                        transactionIdNumSuffix = executionID.Substring(19, len);
                    }
                    transactionIdNum = BuildElementaryElement(transactionIdNum, 19, PadMode.Left, '0');
                    transactionIdNumSuffix = BuildElementaryElement(transactionIdNumSuffix, 10, PadMode.Left, '0');

                    //clearing leg indicator
                    string clearingLeg = string.Empty;
                    switch (pSide)
                    {
                        case TypeSideAllocation.Dealer:
                            clearingLeg = "T";
                            break;
                        case TypeSideAllocation.Clearer:
                            clearingLeg = "C";
                            break;
                        default:
                            throw new NotImplementedException($"Side: {pSide} is not implemented");
                    }

                    ret = typeIndicator + transactionIdNum + transactionIdNumSuffix + clearingLeg;
                    #endregion EUREX_REFIT
                    break;


                default:
                    #region EUREX, EUREX_L2
                    fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');

                    //trade date
                    string tradeDate = string.Empty;
                    if (DtFunc.IsDateTimeFilled(UtiComponents.Trade_tradeDate))
                        tradeDate = DtFunc.DateTimeToStringyyyyMMdd(UtiComponents.Trade_tradeDate);
                    tradeDate = BuildElementaryElement(tradeDate, 8, PadMode.Right, fillerString);

                    //product id
                    string productId = UtiComponents.DC_Symbol;
                    productId = BuildElementaryElement(productId, 4, PadMode.Right, fillerString);

                    //transaction ID number
                    string transactionIdNumber = string.Empty;
                    if (StrFunc.IsFilled(UtiComponents.Trade_executionID))
                    {
                        execId = UtiComponents.Trade_executionID;
                        if (UtiComponents.DC_ContractTypeEnum.HasValue && (UtiComponents.DC_ContractTypeEnum == DerivativeContractTypeEnum.FLEX))
                        {
                            //Prendre les 9 premiers caractères
                            len = 9;
                            if (execId.Length < len)
                                len = execId.Length;
                            transactionIdNumber = execId.Substring(0, len);
                        }
                        else
                        {
                            //Prendre les 6 premiers caractères
                            len = 6;
                            if (execId.Length < len)
                                len = execId.Length;
                            transactionIdNumber = execId.Substring(0, len);
                        }
                    }
                    transactionIdNumber = BuildElementaryElement(transactionIdNumber, 9, PadMode.Right, fillerString);

                    //transaction ID suffix number
                    string transactionIdSuffixNumber = string.Empty;
                    if (StrFunc.IsFilled(UtiComponents.Trade_executionID))
                    {
                        execId = UtiComponents.Trade_executionID;
                        if (UtiComponents.DC_ContractTypeEnum.HasValue && (UtiComponents.DC_ContractTypeEnum == DerivativeContractTypeEnum.FLEX))
                        {
                            if (execId.Length > 10)
                            {
                                //	Prendre les 5 caractères à partir du 10ème caractère (donc de 10 à 14)
                                len = 5;
                                if ((execId.Length - 10) < len)
                                    len = (execId.Length - 10 + 1);
                                transactionIdSuffixNumber = execId.Substring(9, len);
                            }
                        }
                        else
                        {
                            if (execId.Length > 7)
                            {
                                //Prendre les 5 caractères à partir du 7ème caractère (donc de 7 à 11)
                                len = 5;
                                if ((execId.Length - 7) < len)
                                    len = (execId.Length - 7 + 1);
                                transactionIdSuffixNumber = execId.Substring(6, len);
                            }
                        }
                    }
                    //transactionIdSuffixNumber = BuildElementaryElement(transactionIdSuffixNumber, 5, PadMode.Right, ' ');
                    transactionIdSuffixNumber = BuildElementaryElement(transactionIdSuffixNumber, 5, PadMode.Left, '0');

                    //orderID
                    string orderId = UtiComponents.Trade_orderID;
                    orderId = BuildElementaryElement(orderId, 9, PadMode.Right, fillerString);

                    //buy code
                    string buyCode = string.Empty;
                    if (StrFunc.IsFilled(UtiComponents.Trade_tradeSide))
                        buyCode = StrFunc.FirstUpperCase(UtiComponents.Trade_tradeSide.Substring(0, 1));
                    buyCode = BuildElementaryElement(buyCode, 1, PadMode.Right, fillerString);

                    ret = UTITypeIndicator + tradeDate + productId + transactionIdNumber + transactionIdSuffixNumber + orderId + buyCode + clearingLegIndicator;
                    #endregion EUREX, EUREX_L2
                    break;
            }
            return ret;
        }

        /// <summary>
        /// Génération de l'identifiant de trade selon la règle LCH.CLEARNET-SA
        /// </summary>
        /// <returns></returns>
        //PL 20151029 add L2
        private string BuildTradeIdUsingLCHCLEARNETSAMethod(UTIRule pRule)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret;

            if (UTITools.IsREFITRULE(pRule))
            {
                // FI 20240704 [WI987] 
                throw new NotImplementedException($"UTI Rule: {pRule} is not implemented on LCH.Clearnet-SA.");
            }
            else
            {
                char fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');

                //Business Date
                string businessDate = string.Empty;
                if (DtFunc.IsDateTimeFilled(UtiComponents.Trade_businessDate))
                    businessDate = DtFunc.DateTimeToStringyyyyMMdd(UtiComponents.Trade_businessDate);
                businessDate = BuildElementaryElement(businessDate, 8, PadMode.Right, fillerString);

                //Trade Leg ID
                string tradeLegID = string.Empty;
                if (StrFunc.IsFilled(UtiComponents.Trade_executionID))
                {
                    string execId = UtiComponents.Trade_executionID;
                    //Prendre les 10 premiers caractères
                    int len = 10;
                    if (execId.Length < 10)
                        len = execId.Length;
                    tradeLegID = execId.Substring(0, len);
                }
                //tradeLegID = BuildElementaryElement(tradeLegID, 10, PadMode.Right, ' ');
                tradeLegID = BuildElementaryElement(tradeLegID, 10, PadMode.Left, '0');

                ret = businessDate + tradeLegID;
            }

            return ret;
        }

        /// <summary>
        /// Génération de l'identifiant de trade selon la règle EURONEXT CLEARING
        /// </summary>
        /// <param name="pRule"></param>
        /// FI 20240704 [WI987] Add
        /// <returns></returns>
        private string BuildTradeIdUsingEURONEXTCLEARINGMethod(UTIRule pRule)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret = string.Empty;

            if (UTITools.IsREFITRULE(pRule))
            {
                //Trade TUI
                string tradeTUI = UtiComponents.Trade_executionID;
                tradeTUI = BuildElementaryElement(tradeTUI, 9, PadMode.Right, '0');

                //Trade Side
                string tradeSide = UtiComponents.Trade_tradeSide.ToUpper().Substring(0, 2);
                tradeSide = BuildElementaryElement(tradeSide, 2, PadMode.Right, ' ');

                //Trade Date
                string tradeDate = string.Empty;
                if (DtFunc.IsDateTimeFilled(UtiComponents.Trade_tradeDate))
                    tradeDate = DtFunc.DateTimeToStringyyyyMMdd(UtiComponents.Trade_tradeDate);
                tradeDate = BuildElementaryElement(tradeDate, 8, PadMode.Right, ' ');

                ret = tradeTUI + tradeSide + tradeDate;
            }

            return ret;
        }


        /// <summary>
        /// Retourne un UTI construit selon la règle de SPHERES
        /// </summary>
        /// <param name="pSide"></param>
        /// <returns></returns>
        //PL 20151029 add L2
        private string BuildTradeIdUsingSPHERESMethod(UTIRule pRule, string pCS = null)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            char fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');

            string ret;
            if (UTITools.IsREFITRULE(pRule))
            {
                //Trade Type
                string tradeTypeRefit = (UtiComponents.DC_ContractTypeEnum.HasValue && (UtiComponents.DC_ContractTypeEnum.Value == DerivativeContractTypeEnum.FLEX)) ? "O" : "E";
                tradeTypeRefit = BuildElementaryElement(tradeTypeRefit, 1, PadMode.Right, fillerString);

                //Trade Date
                string tradeDateRefit = (DtFunc.IsDateTimeFilled(UtiComponents.Trade_tradeDate)) ? DtFunc.DateTimeToStringyyMMdd(UtiComponents.Trade_tradeDate) : string.Empty;
                tradeDateRefit = BuildElementaryElement(tradeDateRefit, 6, PadMode.Right, fillerString);

                //CFI
                string cfiCategory = string.Empty;
                string cfiGroup = string.Empty;
                string cfi = UtiComponents.Asset_CfiCode;
                if (StrFunc.IsFilled(cfi))
                {
                    cfiCategory = cfi.Substring(0, 1);
                    cfiGroup = cfi.Substring(1, 1);
                }

                //Contract
                string contractRefit = UtiComponents.Asset_ISIN;

                if (!StrFunc.IsFilled(contractRefit))
                {
                    //Market
                    string marketRefit = UtiComponents.Market_MIC;
                    marketRefit = BuildElementaryElement(marketRefit, 4, PadMode.Right, fillerString);

                    //Contract
                    string symbolAttribute = GetContractSymbolAndAttributeForSPHERESMethod(UtiComponents.DC_Symbol, UtiComponents.DC_Attribute);
                    contractRefit = BuildElementaryElement((marketRefit + symbolAttribute), 12, PadMode.Right, 'X');
                }

                //Trade ID
                string tradeIdRefit = (UtiComponents.Trade_id > 0) ? UtiComponents.Trade_id.ToString() : string.Empty;
                tradeIdRefit = BuildElementaryElement(tradeIdRefit, 10, PadMode.Left, '0');

                //Trade Side
                string tradeSideRefit = string.Empty;
                if (StrFunc.IsFilled(UtiComponents.Trade_tradeSide))
                    tradeSideRefit = StrFunc.FirstUpperCase(UtiComponents.Trade_tradeSide.Substring(0, 1));
                tradeSideRefit = BuildElementaryElement(tradeSideRefit, 1, PadMode.Right, fillerString);

                ret = tradeTypeRefit + tradeDateRefit + cfiCategory + cfiGroup + contractRefit + tradeIdRefit + tradeSideRefit;
            }
            else
            {
                //Trade Type
                string tradeType = (UtiComponents.DC_ContractTypeEnum.HasValue && (UtiComponents.DC_ContractTypeEnum.Value == DerivativeContractTypeEnum.FLEX)) ? "O" : "E";
                tradeType = BuildElementaryElement(tradeType, 1, PadMode.Right, fillerString);

                //Dealer Code
                string dealerCode;
                if (StrFunc.IsFilled(UtiComponents.Dealer_Actor_BIC))
                    dealerCode = UtiComponents.Dealer_Actor_BIC.PadRight(11, 'X');
                else if (StrFunc.IsFilled(UtiComponents.Dealer_Actor_LEI))
                    dealerCode = UtiComponents.Dealer_Actor_LEI.Substring(7, 10).PadRight(11, fillerString);
                else
                    dealerCode = UtiComponents.Dealer_Actor_id.ToString().PadLeft(11, '0');
                dealerCode = BuildElementaryElement(dealerCode, 11, PadMode.Right, fillerString);

                //Trade Date
                string tradeDate = (DtFunc.IsDateTimeFilled(UtiComponents.Trade_tradeDate)) ? DtFunc.DateTimeToStringyyyyMMdd(UtiComponents.Trade_tradeDate) : string.Empty;
                tradeDate = BuildElementaryElement(tradeDate, 8, PadMode.Right, fillerString);

                //Market
                string market = UtiComponents.Market_MIC;
                market = BuildElementaryElement(market, 4, PadMode.Right, fillerString);

                //Contract
                string contract = GetContractSymbolAndAttributeForSPHERESMethod(UtiComponents.DC_Symbol, UtiComponents.DC_Attribute);
                contract = BuildElementaryElement(contract, 6, PadMode.Right, fillerString);

                //Trade Id 
                // FI 20170217 [19618] tradeId est alimenté avec l'idT du trade
                //string tradeId = (tradeIdentification != null) ? tradeIdentification.otcmlId : string.Empty;
                string tradeId = (UtiComponents.Trade_id > 0) ? UtiComponents.Trade_id.ToString() : string.Empty;
                tradeId = BuildElementaryElement(tradeId, 10, PadMode.Left, '0');

                //Trade Side 
                string tradeSide = string.Empty;
                if (StrFunc.IsFilled(UtiComponents.Trade_tradeSide))
                    tradeSide = StrFunc.FirstUpperCase(UtiComponents.Trade_tradeSide.Substring(0, 1));
                tradeSide = BuildElementaryElement(tradeSide, 1, PadMode.Right, fillerString);

                //Indicator 
                string indicator = "X";

                ret = tradeType + dealerCode + tradeDate + market + contract + tradeId + tradeSide + indicator;

            }
            return ret;
        }

        /// <summary>
        /// Génération du code unique pour une position (PUTI)
        /// </summary>
        /// <param name="pRule">Méthode de calcul</param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        //PL 20151029 add L2
        //PL 20160428 [22107] EUREX C7 3.0 Release - New signature, add pSide
        private string BuildPositionId(UTIRule pRule, TypeSideAllocation pSide)
        {
            string ret;
            switch (pRule)
            {
                case UTIRule.CCP:
                case UTIRule.CCP_L2:
                case UTIRule.CCP_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildPositionIdUsingCCPMethod(pRule, pSide);
                    break;
                case UTIRule.CCEG:
                case UTIRule.CCEG_L2:
                case UTIRule.CCEG_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildPositionIdUsingCCEGMethod(pRule);
                    break;
                case UTIRule.EUREX:
                case UTIRule.EUREX_L2:
                case UTIRule.EUREX_L2_C7_3: //PL 20160426 [22107] Newness EUREX C7 3.0 Release
                case UTIRule.EUREX_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildPositionIdUsingEUREXMethod(pRule, pSide);
                    break;
                case UTIRule.LCHCLEARNETSA:
                case UTIRule.LCHCLEARNETSA_L2:
                case UTIRule.LCHCLEARNETSA_REFIT:
                    ret = BuildPositionIdUsingLCHCLEARNETSAMethod(pRule);
                    break;
                case UTIRule.EURONEXTCLEARING_REFIT: // FI 20240425 [26593] UTI/PUTI REFIT
                    ret = BuildPositionIdUsingEURONEXTCLEARINGMethod(pRule);
                    break;
                case UTIRule.SPHERES:
                case UTIRule.SPHERES_L2:
                case UTIRule.SPHERES_REFIT: //LP 20240625 [WI985] PUTI REFIT
                    ret = BuildPositionIdUsingSPHERESMethod(pRule);
                    break;
                default:
                    throw new NotImplementedException($"UTI Rule: {pRule} is not implemented.");
            }

            return ret;
        }

        /// <summary>
        /// Retourne le code PUTI selon les règles propre à la chambre de compensation du trade
        /// </summary>
        /// <param name="pRule"></param>
        /// <param name="pSide"></param>
        /// <returns></returns>
        //PL 20151029 add L2
        //PL 20160428 [22107] EUREX C7 3.0 Release - New signature, add pSide
        private string BuildPositionIdUsingCCPMethod(UTIRule pRule, TypeSideAllocation pSide)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret;

            string codeBIC = UtiComponents.Css_BIC;
            string identifier = UtiComponents.Css_Identifier;

            switch (codeBIC)
            {
                case BIC_CCeG:
                    ret = BuildPositionIdUsingCCEGMethod(pRule);
                    break;
                case BIC_EUREX:
                    ret = BuildPositionIdUsingEUREXMethod(pRule, pSide);
                    break;
                case BIC_LCHClearnetSA:
                    ret = BuildPositionIdUsingLCHCLEARNETSAMethod(pRule);
                    break;
                case BIC_EURONEXTCLEARING:  // FI 20240704 [WI987] Add
                    ret = BuildPositionIdUsingEURONEXTCLEARINGMethod(pRule);
                    break;
                default:
                    if (StrFunc.IsFilled(codeBIC))
                        throw new NotImplementedException($"Actor BIC: {codeBIC} is not implemented");
                    else
                        throw new NotImplementedException($"Actor Identifier: {identifier} is not implemented, BIC is unknown");
            }
            return ret;
        }

        /// <summary>
        /// Retourne le code PUTI Méthode CCeG
        /// </summary>
        /// <returns></returns>
        /// FI 20140218 [19631] add Method
        /// FI 20140602 [20023] Modification de l'alimentation de subaccount
        /// PL 20151029 add L2 
        /// FI 20240425 [26593] UTI/PUTI REFIT
        private string BuildPositionIdUsingCCEGMethod(UTIRule pRule)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret;
            char fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');

            if (UTITools.IsREFITRULE(pRule))
            {
                //Participant Code (Abicode)
                string participantCode = string.Empty;
                int idAEntity = UtiComponents.Entity_id;
                if (idAEntity > 0)
                    participantCode = UtiComponents.Entity_CSSMemberCode;
                //participantCode = BuildElementaryElement(participantCode, 5, PadMode.Right, ' ');
                participantCode = BuildElementaryElement(participantCode, 5, PadMode.Left, '0');

                //Account
                string accountType = string.Empty;
                if (UtiComponents.Dealer_Actor_id > 0)
                {
                    if (UtiComponents.Dealer_Actor_IsCLIENT)
                        accountType = "C";
                    else
                        // RD 20171206 [23604]    
                        // D'après la doc "20171130_1219_Emir_Reporting_Guide-RTS2-10_0.pdf" (voir ticket 23604):
                        // Can be "H" for house accounts, or "C" for client accounts.
                        //accountType = "P";
                        accountType = "H";
                }
                accountType = BuildElementaryElement(accountType, 1, PadMode.Right, fillerString);

                //SubAccount
                string subAccount = BuildElementaryElement("*OMN", 4, PadMode.Left, fillerString).Replace("*","X");

                string Separator = BuildElementaryElement("0", 10, PadMode.Left, '0');

                //Product ID
                string productId = UtiComponents.Asset_ISIN;
                productId = BuildElementaryElement(productId, 12, PadMode.Right, fillerString);

                ret = participantCode + accountType + subAccount + Separator + productId;

            }
            else
            {

                // RD 20171206 [23604] D'après la doc "20171130_1219_Emir_Reporting_Guide-RTS2-10_0.pdf" (voir ticket 23604),
                // il s'agit d'un tiret "-" et non de underscore "_"
                //Position Indicator => Longueur 1 remplir avec espace (tiret en L2)
                //string positionIndicator = fillerString.ToString();
                string positionIndicator = (UTITools.IsLevel2(pRule) ? '-' : ' ').ToString();

                //Participant Code (Abicode)
                string participantCode = string.Empty;
                int idAEntity = UtiComponents.Entity_id;
                if (idAEntity > 0)
                    participantCode = UtiComponents.Entity_CSSMemberCode;
                //participantCode = BuildElementaryElement(participantCode, 5, PadMode.Right, ' ');
                participantCode = BuildElementaryElement(participantCode, 5, PadMode.Left, '0');

                //Account
                string accountType = string.Empty;
                if (UtiComponents.Dealer_Actor_id > 0)
                {
                    if (UtiComponents.Dealer_Actor_IsCLIENT)
                        accountType = "C";
                    else
                        // RD 20171206 [23604]    
                        // D'après la doc "20171130_1219_Emir_Reporting_Guide-RTS2-10_0.pdf" (voir ticket 23604):
                        // Can be "H" for house accounts, or "C" for client accounts.
                        //accountType = "P";
                        accountType = "H";
                }
                accountType = BuildElementaryElement(accountType, 1, PadMode.Right, fillerString);

                // FI 20140602 [20023] Mise en commentaire du pavé subaccount
                //SubAccount
                //string subAccount = UtiComponents.Clearer_Book_Identifier;
                //if (!String.IsNullOrEmpty(subAccount))
                //{
                //    subAccount = BuildElementaryElement(subAccount, 4, PadMode.Right, ' ');
                //}
                //else
                //{
                //    //PL 20140523 Blanc pour l'instant...
                //    subAccount = new String(' ', 4);
                //}

                //SubAccount
                // FI 20140602 [20023] Alimentation de subaccount selon la donc EMIR-TR.docx 
                // Longueur4;remplir avec espaces
                // Spheres n'utilise pas UtiComponents.Clearer_Book_Identifier qui n'était de toute façon pas alimenté jusqu'à ici lorsque le PUTI était calculé depuis les menus "calcul des UTI (Trades)" et "calcul des UTI (Positions)"
                // RD 20171206 [23604]                                 
                //string subAccount = new String(fillerString, 4);
                //******************************************************************************************************************************************
                // NOTE:
                // -----
                // Actuellement dans Spheres, on ne sait pas distinguer les comptes ségrégués des comptes omnibus. 
                // En outre, pour l'instant XI nous indique qu'aucun de leurs clients sur CC&G ne gèrent de comptes ségrégués.
                // La totalité des comptes de leurs clients sont des comptes omnibus.
                // Pour ces raisons là, nous avons opté pour mettre dans Subaccount, EN DUR, la valeur "_OMN".
                // Le jour où un compte ségrégué se présente sur CC&G, il faudrait le traiter, probablement avec une évolution du référentiel de Spheres 
                // pour le distinguer du compte omnibus, et ainsi valoriser Subaccount avec les 4 premiers caractères du compte ségrégué. 
                //******************************************************************************************************************************************
                string subAccount = BuildElementaryElement("OMN", 4, PadMode.Left, fillerString);

                //Product ID
                string productId = UtiComponents.Asset_ISIN;
                productId = BuildElementaryElement(productId, 12, PadMode.Right, fillerString);

                ret = positionIndicator + participantCode + accountType + subAccount + productId;
            }

            return ret;
        }

        /// <summary>
        /// Retourne un PUTI construit selon la règle de SPHERES
        /// </summary>
        /// <returns></returns>
        // PL 20151029 add L2
        private string BuildPositionIdUsingSPHERESMethod(UTIRule pRule)
        {
            if ((null == UtiComponents))
                throw new NullReferenceException("utiComponents is null");

            string ret;

            char fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');


            if (UTITools.IsREFITRULE(pRule))
            {
                //Position Type
                string positionType = string.Empty;
                if (UtiComponents.Dealer_Actor_id > 0)
                {
                    if (UtiComponents.Dealer_Actor_IsCLIENT)
                        positionType = "C";
                    else
                        positionType = "H";
                }
                positionType = BuildElementaryElement(positionType, 1, PadMode.Right, fillerString);

                //Position date
                string positionDate = (DtFunc.IsDateTimeFilled(UtiComponents.PosUti_OpeningTrade_TradeDate)) ? DtFunc.DateTimeToStringyyMMdd(UtiComponents.PosUti_OpeningTrade_TradeDate) : string.Empty;
                positionDate = BuildElementaryElement(positionDate, 6, PadMode.Right, fillerString);

                //CFI
                string cfiCategory = string.Empty;
                string cfiGroup = string.Empty;
                string cfi = UtiComponents.Asset_CfiCode;
                if (StrFunc.IsFilled(cfi))
                {
                    cfiCategory = cfi.Substring(0, 1);
                    cfiGroup = cfi.Substring(1, 1);
                }

                //Contract
                string contractRefit = UtiComponents.Asset_ISIN;
                if (!StrFunc.IsFilled(contractRefit))
                {
                    //Market
                    string marketRefit = UtiComponents.Market_MIC;
                    marketRefit = BuildElementaryElement(marketRefit, 4, PadMode.Right, fillerString);

                    //Contract
                    string symbolAttribute = GetContractSymbolAndAttributeForSPHERESMethod(UtiComponents.DC_Symbol, UtiComponents.DC_Attribute);
                    contractRefit = BuildElementaryElement((marketRefit + symbolAttribute), 12, PadMode.Right, 'X');
                }

                //PositionID
                string positionID = UtiComponents.PosUti_IdPosUti.ToString();
                positionID = BuildElementaryElement(positionID, 10, PadMode.Right, '0');

                //Position Type
                string positionSide = (UtiComponents.PosUti_OpeningTrade_TradeSide == SideTools.FirstUCaseBuyerSeller(BuyerSellerEnum.SELLER)) ? "S" : "L";
                positionSide = BuildElementaryElement(positionSide, 1, PadMode.Left, ' ');

                ret = positionType + positionDate + cfiCategory + cfiGroup + contractRefit + positionID + positionSide;
            }
            else
            {

                //Position Indicator
                string positionIndicator = "P";

                //Dealer Account
                string dealerAccount = string.Empty;
                if (UtiComponents.Dealer_Book_Id > 0)
                    dealerAccount = UtiComponents.Dealer_Book_Id.ToString();
                dealerAccount = BuildElementaryElement(dealerAccount, 10, PadMode.Left, '0');

                //Market
                string market = UtiComponents.Market_MIC;
                market = BuildElementaryElement(market, 4, PadMode.Right, fillerString);

                //Contract
                string contract = GetContractSymbolAndAttributeForSPHERESMethod(UtiComponents.DC_Symbol, UtiComponents.DC_Attribute);
                contract = BuildElementaryElement(contract, 6, PadMode.Right, fillerString);

                //PutCall
                string putCall = string.Empty;
                if (UtiComponents.DC_Category == "O")
                {
                    if (UtiComponents.Asset_PutCallEnum.HasValue)
                    {
                        if (UtiComponents.Asset_PutCallEnum.Value == PutOrCallEnum.Put)
                            putCall = "P";
                        else if (UtiComponents.Asset_PutCallEnum.Value == PutOrCallEnum.Call)
                            putCall = "C";
                    }
                }
                else if (UtiComponents.DC_Category == "F")
                {
                    putCall = "F";
                }
                putCall = BuildElementaryElement(putCall, 1, PadMode.Right, fillerString);


                //Asset
                string asset;
                if (String.IsNullOrEmpty(UtiComponents.Asset_ISIN))
                {
                    string maturityDate = DtFunc.IsDateTimeFilled(UtiComponents.Asset_MaturityDate) ? DtFunc.DateTimeToStringyyyyMMdd(UtiComponents.Asset_MaturityDate) : string.Empty;
                    string strike = StrFunc.FmtDecimalToInvariantCulture(UtiComponents.Asset_StrikePrice);
                    asset = BuildElementaryElement(maturityDate, 8, PadMode.Right, fillerString) + BuildElementaryElement(strike, 11, PadMode.Left, '0');
                }
                else
                {
                    asset = UtiComponents.Asset_ISIN;
                    asset = BuildElementaryElement(asset, 19, PadMode.Right, fillerString);
                }

                //Indicator
                string indicator = "X";

                ret = positionIndicator + dealerAccount + market + contract + putCall + asset + indicator;

            }

            return ret;
        }

        /// <summary>
        /// Retourne le code PUTI Méthode EUREX
        /// </summary>
        /// <returns></returns>
        //FI 20140218 [19631] add Method
        //FI 20140916 [20353] Modify Method
        //PL 20151029 add L2
        //PL 20160428 [22107] EUREX C7 3.0 Release - New signature, add pSide
        private string BuildPositionIdUsingEUREXMethod(UTIRule pRule, TypeSideAllocation pSide)
        {
            string ret = string.Empty;
            char fillerString = '_';

            //UTI type indicator
            string UTITypeIndicator = "P";

            switch (pRule)
            {
                case UTIRule.EUREX_L2_C7_3:
                    #region EUREX_L2_C7_3
                    //INFO: UTI également sur les contrats Flex 
                    //PL 20160426 [22107] Newness EUREX C7 3.0 Release

                    //clearing leg indicator
                    string clearingLegIndicator;
                    switch (pSide)
                    {
                        case TypeSideAllocation.Dealer:
                            clearingLegIndicator = "A";
                            break;
                        case TypeSideAllocation.Clearer:
                            clearingLegIndicator = "C";
                            break;
                        default:
                            throw new NotImplementedException($"Side: {pSide} is not implemented");
                    }

                    //Position ID
                    string positionId = string.Empty;
                    if (StrFunc.IsFilled(UtiComponents.Trade_positionID)) 
                    {
                        string posId = UtiComponents.Trade_positionID; 
                        //Prendre les 11 premiers caractères
                        int len = 11;
                        if (posId.Length < len)
                            len = posId.Length;
                        positionId = posId.Substring(0, len);
                    }
                    positionId = BuildElementaryElement(positionId, 11, PadMode.Left, '0');

                    ret = UTITypeIndicator + clearingLegIndicator + positionId;
                    #endregion EUREX_L2_C7_3
                    break;

                case UTIRule.EUREX_REFIT: //LP 20240625 [WI986] PUTI EUREX REFIT

                    //PositionID
                    string positionID = UtiComponents.Trade_positionID.ToString();
                    positionID = BuildElementaryElement(positionID, 11, PadMode.Right, '0');

                    //clearing leg indicator
                    string clearingLeg;
                    switch (pSide)
                    {
                        case TypeSideAllocation.Dealer:
                            clearingLeg = "T";
                            break;
                        case TypeSideAllocation.Clearer:
                            clearingLeg = "C";
                            break;
                        default:
                            throw new NotImplementedException($"Side: {pSide} is not implemented");
                    }

                    ret = UTITypeIndicator + positionID + clearingLeg;
                    break;
                default:
                    #region EUREX, EUREX_L2
                    //WARNING: Pas d'UTI sur les contrats Flex (voir page 16 de la doc Reporting by Eurex Clearing according to EMIR Artcicle 9, version 1.6)  
                    Boolean isFLEX = (this.UtiComponents.DC_ContractTypeEnum.HasValue && this.UtiComponents.DC_ContractTypeEnum.Value == DerivativeContractTypeEnum.FLEX);
                    if (!isFLEX)
                    {
                        fillerString = (UTITools.IsLevel2(pRule) ? '_' : ' ');

                        //member id
                        string memberId = string.Empty;
                        int idAEntity = UtiComponents.Entity_id;
                        if (idAEntity > 0)
                            memberId = UtiComponents.Entity_CSSMemberCode;
                        memberId = BuildElementaryElement(memberId, 5, PadMode.Right, fillerString);

                        //Account name
                        string accountType = UtiComponents.Clearer_Compartment_Code;
                        accountType = BuildElementaryElement(accountType, 20, PadMode.Right, '0');

                        //product id
                        string productId = UtiComponents.DC_Symbol;
                        productId = BuildElementaryElement(productId, 4, PadMode.Right, fillerString);

                        //contract class code
                        string contractClassCode = string.Empty;
                        if (UtiComponents.DC_Category == "F")
                            contractClassCode = UtiComponents.DC_Category;
                        else if (UtiComponents.DC_Category == "O")
                        {
                            if (UtiComponents.Asset_PutCallEnum.HasValue)
                                contractClassCode = StrFunc.FirstUpperCase(UtiComponents.Asset_PutCallEnum.Value.ToString().Substring(0, 1));
                        }
                        else
                            throw new NotImplementedException($"Category: {UtiComponents.DC_Category} is not implemented");
                         
                        contractClassCode = BuildElementaryElement(contractClassCode, 1, PadMode.Right, fillerString);

                        //contract expiration YearMonth
                        string expirationYearMonth = string.Empty;
                        if (StrFunc.IsFilled(UtiComponents.Asset_MaturityMonthYear) && UtiComponents.Asset_MaturityMonthYear.Length >= 6)
                            expirationYearMonth = UtiComponents.Asset_MaturityMonthYear.Substring(2, 4);
                        expirationYearMonth = BuildElementaryElement(expirationYearMonth, 4, PadMode.Right, fillerString);

                        //version number
                        string versionNumber = string.Empty;
                        if (UtiComponents.DC_Category == "F")
                        {
                            versionNumber = "0";
                        }
                        else if (UtiComponents.DC_Category == "O")
                        {
                            versionNumber = StrFunc.IsFilled(UtiComponents.DC_Attribute) ? UtiComponents.DC_Attribute : "0";
                        }
                        else
                            throw new NotImplementedException($"Category: {UtiComponents.DC_Category} is not implemented");
                        
                        versionNumber = BuildElementaryElement(versionNumber, 1, PadMode.Right, '0');

                        //strike price
                        string strikePrice = string.Empty;
                        if (UtiComponents.DC_Category == "O")
                        {
                            strikePrice = StrFunc.FmtAmountToInvariantCulture(UtiComponents.Asset_StrikePrice.ToString());
                            string[] sStrikePrice = strikePrice.Split('.');
                            if (UtiComponents.DC_StrikeDecLocator.HasValue && UtiComponents.DC_StrikeDecLocator.Value >= 1)
                            {
                                sStrikePrice[1] = sStrikePrice[1].Substring(0, UtiComponents.DC_StrikeDecLocator.Value);
                                strikePrice = sStrikePrice[0] + sStrikePrice[1];
                            }
                            else
                            {
                                strikePrice = sStrikePrice[0];
                            }
                        }
                        strikePrice = BuildElementaryElement(strikePrice, 6, PadMode.Left, '0');

                        ret = UTITypeIndicator + memberId + accountType + productId + contractClassCode + expirationYearMonth + versionNumber + strikePrice;
                    }
                    #endregion EUREX, EUREX_L2
                    break;
            }
            return ret;
        }


        /// <summary>
        /// Retourne le code PUTI Méthode LCH.Clearnet-SA
        /// </summary>
        /// <param name="pRule"></param>
        /// <returns></returns>
        // FI 20140218 [19631] add Method
        private string BuildPositionIdUsingLCHCLEARNETSAMethod(UTIRule pRule)
        {
            throw new NotImplementedException("LCH.Clearnet-SA PUTI is not implemented");
        }

        /// <summary>
        /// Retourne le code PUTI Méthode EURONEXT CLEARING
        /// </summary>
        /// <returns></returns>
        /// FI 20240704 [WI987] Add
        private string BuildPositionIdUsingEURONEXTCLEARINGMethod(UTIRule pRule)
        {
            string ret = string.Empty;
            if (UTITools.IsREFITRULE(pRule))
            {
                //position Id
                string positionId = UtiComponents.Trade_positionID;
                positionId = BuildElementaryElement(positionId, 30, PadMode.Left, 'X');
                ret = positionId;
            }
            return ret;
        }

        /// <summary>
        /// Retourne le code émetteur 
        /// <para>la property issuer doit être renseigné</para>
        /// <para>Retourne un string de 10 caractères (11 caractères avec la méthode EUREX_L2_C7_3)</para>
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pRule"></param>
        /// <returns></returns>
        /// PL 20160427 [22107] EUREX C7 3.0 Release - New signature, add pRule
        /// EG 20180307 [23769] Gestion dbTransaction
        private string BuildIssuer(string pCS, UTIRule pRule)
        {
            return BuildIssuer(pCS, null, pRule);
        }

        /// <summary>
        /// Retourne le code émetteur 
        /// <para>la property issuer doit être renseigné</para>
        /// <para>Retourne un string de 10 caractères (11 caractères avec la méthode EUREX_L2_C7_3)</para>
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pRule"></param>
        /// <returns></returns>
        /// PL 20160427 [22107] EUREX C7 3.0 Release - New signature, add pRule
        /// EG 20180307 [23769] Gestion dbTransaction
        /// FI 20240425 [26593] UTI/PUTI REFIT (Refactoring)
        private string BuildIssuer(string pCS, IDbTransaction pDbTransaction, UTIRule pRule)
        {
            if ((null == Issuer))
                throw new InvalidOperationException("issuer is null");

            string ret = string.Empty;
            Boolean isREFITRule = UTITools.IsREFITRULE(pRule);
            Boolean isSpheresRULE = UTITools.IsSpheresRULE(pRule);

            if (isREFITRule)
            {
                int len = 20;
                switch (Issuer.First)
                {
                    case UTIIssuerIdent.ISSUER:
                        ret = Issuer.Second;
                        break;
                    case UTIIssuerIdent.IDA:
                    case UTIIssuerIdent.BIC:
                        Pair<UTIIssuerIdent, string> newIssuer = ConvertIssuer((pCS,pDbTransaction), Issuer, UTIIssuerIdent.LEI);
                        if (null != newIssuer)
                            ret = newIssuer.Second;
                        break;
                    default:
                        throw new NotImplementedException($"Ident: {Issuer.First} is not implemented");
                }

                ret = ret.PadRight(len, ' ');
            }
            else
            {
                int len = 10;
                Pair<UTIIssuerIdent, string> newIssuer = null;

                switch (Issuer.First)
                {
                    case UTIIssuerIdent.ISSUER:
                        ret = GetIssuerCode(Issuer, pRule);
                        break;
                    case UTIIssuerIdent.BIC:
                    case UTIIssuerIdent.IDA:
                        newIssuer = ConvertIssuer((pCS, pDbTransaction), Issuer, isSpheresRULE? UTIIssuerIdent.LEI : UTIIssuerIdent.MIC);
                        if (null != newIssuer)
                            ret = GetIssuerCode(newIssuer, pRule);
                        break;
                    default:
                        throw new NotImplementedException($"Ident: {Issuer.First} is not implemented");
                }

                //Cas particulier de EUREX C7 3.0 Release où l'issuer est sur 11 car. (E01XEURECAG)
                if (pRule == UTIRule.EUREX_L2_C7_3)
                {
                    if (((null == newIssuer) && (Issuer.First == UTIIssuerIdent.MIC)) || ((null != newIssuer) && (newIssuer.First == UTIIssuerIdent.MIC)))
                        len = 11;
                }

                ret = ret.PadRight(len, ' ');
            }

            return ret;
        }



        /// <summary>
        /// Retourne un code issuer à partir d'un code MIC
        /// <para>Ce mode de determination du code issuer est valide uniquement pour des acteurs CCP</para>
        /// </summary>
        /// <param name="pMIC"></param>
        /// <param name="pRule"></param>
        /// <returns></returns>
        //PL 20160427 [22107] EUREX C7 3.0 Release - New signature, add pRule
        private static String GetIssuerCodeFromMIC(string pMIC, UTIRule pRule)
        {
            if (StrFunc.IsEmpty(pMIC))
                throw new ArgumentException("parameter pMIC is empty or null");

            if (pRule == UTIRule.EUREX_L2_C7_3)
            {
                return ESMA_UTIMethod1 + MIC_EXCHANGE_EUREX + pMIC.Substring(0, 4);
            }
            else
            {
                return "000" + pMIC.Substring(0, 4) + "000";
            }
        }

        /// <summary>
        /// Retourne un code issuer à partir d'un code LEI
        /// <para>Un code LEI est constitué de 20 caractères</para>
        /// </summary>
        /// <param name="pLEI"></param>
        /// <returns></returns>
        private static String GetIssuerCodeFromLEI(string pLEI)
        {
            if (StrFunc.IsEmpty(pLEI))
                throw new ArgumentException("parameter pLEI is empty or null");
            if (pLEI.Length < 8)
                throw new ArgumentException("parameter pLEI is not valid, it must contain more than 8 characters");

            string ret = pLEI.Substring(6, 10);

            return ret;
        }

        /// <summary>
        /// Génère un code Issuer à partir des identification ISSUER,MIC ou LEI
        /// </summary>
        /// <param name="pIssuer"></param>
        /// <param name="pRule"></param>
        /// <returns></returns>
        //PL 20160427 [22107] EUREX C7 3.0 Release - New signature, add pRule
        private static string GetIssuerCode(Pair<UTIIssuerIdent, string> pIssuer, UTIRule pRule)
        {
            string ret;
            switch (pIssuer.First)
            {
                case UTIIssuerIdent.ISSUER:
                    if (pRule==UTIRule.EUREX_L2_C7_3)
                        ret = pIssuer.Second.PadRight(11, '0');
                    else  
                        ret = pIssuer.Second.PadRight(10, '0');
                    break;
                case UTIIssuerIdent.MIC:
                    ret = GetIssuerCodeFromMIC(pIssuer.Second, pRule);
                    break;
                case UTIIssuerIdent.LEI:
                    ret = GetIssuerCodeFromLEI(pIssuer.Second);
                    break;
                default:
                    throw new NotImplementedException($"Issuer Ident: {pIssuer.First} is not implemented");
            }
            return ret;
        }

        /// <summary>
        /// Retourne le code MIC ou LEI d'un acteur à partir de son code (BIC,IDA)
        /// <para>Retourne Null lorsque ces codes sont non renseignés</para>
        /// </summary>
        /// <param name="connection"></param>
        /// <param name="issuer"></param>
        /// <param name="targetIssuerIdent">MIC Or LEI</param>
        /// <returns></returns>
        /// EG 20180307 [23769] Gestion dbTransaction
        /// FI 20240425 [26593] UTI/PUTI REFIT 
        private static Pair<UTIIssuerIdent, string> ConvertIssuer((string CS, IDbTransaction DbTransaction) connection, Pair<UTIIssuerIdent, string> issuer, UTIIssuerIdent targetIssuerIdent)
        {
            Pair<UTIIssuerIdent, string> ret = null;

            switch (issuer.First)
            {
                case UTIIssuerIdent.BIC:
                case UTIIssuerIdent.IDA:
                    int idA;
                    if (issuer.First == UTIIssuerIdent.IDA)
                    {
                        if (false == IntFunc.IsPositiveInteger(issuer.Second))
                            throw new FormatException(StrFunc.AppendFormat("Issuer idA: {0} is not valid", issuer.Second));
                        idA = IntFunc.IntValue2(issuer.Second);
                    }
                    else
                    {
                        string scheme;
                        if (issuer.First == UTIIssuerIdent.BIC)
                            scheme = Cst.OTCml_ActorBicScheme;
                        else
                            throw new NotImplementedException($"Ident: {issuer.First} is not implemented");

                        idA = ActorTools.GetIdAFromScheme(connection.CS, connection.DbTransaction, issuer.Second, scheme);
                    }

                    if (idA == 0)
                        throw new NullReferenceException(StrFunc.AppendFormat("Actor (Ident:{0}, Value:{1}) is unknown", issuer.First.ToString(), issuer.Second));

                    SQL_Actor sqlActor = new SQL_Actor(connection.CS, idA)
                    {
                        DbTransaction = connection.DbTransaction
                    };
                    if (sqlActor.LoadTable(new string[] { "ISO10383_ALPHA4", "ISO17442" }))
                    {
                        switch (targetIssuerIdent)
                        {
                            case UTIIssuerIdent.MIC:
                                if (StrFunc.IsFilled(sqlActor.ISO10383_ALPHA4))
                                {
                                    ret = new Pair<UTIIssuerIdent, string>(UTIIssuerIdent.MIC, sqlActor.ISO10383_ALPHA4);
                                }
                                else if (StrFunc.IsFilled(sqlActor.ISO17442))
                                {
                                    ret = new Pair<UTIIssuerIdent, string>(UTIIssuerIdent.LEI, sqlActor.ISO17442);
                                }
                                break;
                            case UTIIssuerIdent.LEI:
                                // FI 20240425 [26593] UTI/PUTI REFIT => priorité à LEI t
                                if (StrFunc.IsFilled(sqlActor.ISO17442))
                                {
                                    ret = new Pair<UTIIssuerIdent, string>(UTIIssuerIdent.LEI, sqlActor.ISO17442);
                                }
                                else if (StrFunc.IsFilled(sqlActor.ISO10383_ALPHA4))
                                {
                                    ret = new Pair<UTIIssuerIdent, string>(UTIIssuerIdent.MIC, sqlActor.ISO10383_ALPHA4);
                                }
                                break;
                            default:
                                throw new NotImplementedException($"targetIssuerIdent: {targetIssuerIdent} is not implemented");
                        }
                    }
                    break;
                default:
                    throw new NotImplementedException($"Ident: {issuer.First} is not implemented");
            }
            return ret;
        }

        /// <summary>
        ///  Retourne {Missing} si la donnée est inconnue ou retourne la donnée 
        /// </summary>
        /// <param name="pData">Représente la donnée</param>
        /// <param name="pTotalWith">taille finale</param>
        /// <param name="pAlign">Alignement</param>
        /// <param name="paddingChar">caractère de remplissage</param>
        /// <returns></returns>
        private static string BuildElementaryElement(string pData, int pTotalWith, PadMode pAlign, char pPaddingChar)
        {
            string ret = string.Empty;
            if (StrFunc.IsEmpty(pData))
            {
                ret = Missing;
            }
            else
            {
                if (pAlign == PadMode.Left)
                    ret = pData.PadLeft(pTotalWith, pPaddingChar);
                else if (pAlign == PadMode.Right)
                    ret = pData.PadRight(pTotalWith, pPaddingChar);
            }
            return ret;
        }

        /// <summary>
        /// Retourne les 6 premiers caractères de la concatenation du ContractSymbol et Attribute
        /// </summary>
        /// <param name="derivativeContract"></param>
        private static string GetContractSymbolAndAttributeForSPHERESMethod(string pContractSymbol, string pAttribute)
        {
            string contractSymbol = pContractSymbol;
            string contratAttribute = pAttribute;

            string ret = contractSymbol + contratAttribute;
            int len = 6;
            if (ret.Length < 6)
                len = ret.Length;
            ret = ret.Substring(0, len);

            return ret;
        }

        /// <summary>
        /// Gérère le code final complet
        /// <para>Si le code généré à partie des informations {pIssuer} et {pId} n'est pas conforme, Spheres génère string.Empty</para>
        /// </summary>
        /// <param name="pIssuer">cette donnée doit être le résulat de la méthode BuidIssuer</param>
        /// <param name="pId">cette donnée doit être le résulat de la méthode BuidTradeId ou BuidPositionId</param>
        private static string BuilResult(string pIssuer, string pId)
        {
            // issuer
            string issuer = pIssuer;
            if (StrFunc.IsFilled(issuer) && issuer.Trim().Length == 0)
                issuer = string.Empty;

            // tradeId
            string id = pId;
            if (StrFunc.IsFilled(id) && id.Contains(Missing))
                id = string.Empty;

            string ret = string.Empty;
            if (StrFunc.IsFilled(issuer) && StrFunc.IsFilled(id))
                ret = issuer + id;

            if (StrFunc.IsFilled(ret) && ret.Length > 52)
                ret = string.Empty;

            return ret;
        }
    }
}