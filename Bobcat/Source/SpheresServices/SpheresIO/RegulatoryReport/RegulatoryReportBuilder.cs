using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Xml.Serialization;
using EFS.ACommon;
//
using EFS.ApplicationBlocks.Data;
using EFS.Common;
using EFS.Common.IO;
using EFS.LoggerClient;
using EFS.LoggerClient.LoggerService;
using EFS.Process;
//
using EfsML.Business;
using EfsML.Enum;
//
using FpML.Interface;
//
namespace EFS.SpheresIO
{
    /// <summary>
    /// RReportProcess include Start method for:
    /// Capture task parameters
    /// Delete RReport and RReportdet tables for the same treatment date
    /// Read and store datalayout informations
    /// Handle buider methods creation in relation to input parameteres   
    /// </summary>
    public class RegulatoryReportProcess
    {
        #region Members
        protected string m_Cs;
        protected DateTime m_BeginDate;
        public const string endDateParamName = "pEndDate";
        protected DateTime m_EndDate;
        public const string openParamName = "pOpen";
        protected bool m_Open;
        public const string openAndClosedParamName = "pOpenAndClosed";
        protected bool m_OpenAndClosed;
        public const string openAndClosedBeginDateParamName = "pOpenAndClosedBeginDate";
        protected DateTime m_OpenAndClosedBeginDate;
        public const string primaryParamName = "pPrimary";
        protected bool m_Primary;
        public const string derivativeParamName = "pDerivate";
        protected bool m_Derivate;
        public const string derivativeBeginDateParamName = "pDerivateBeginDate";
        protected DateTime m_DerivativeBeginDate;
        public const string instrumentGroupParamName = "pInstrumentGroup";
        protected Int32 m_InstrumentGroup;
        public const string tradesListParamName = "pTradesList";
        protected string m_TradesList;
        private List<Int32> m_FilteredTradesList;
        public const string repositoryStyleParamName = "pRepositoryStyle";
        protected string m_RepositoryStyle;
        public const string regulatoryCountryParamName = "pRegulatoryCountry";
        protected string m_RegulatoryCountry;
        public const string regulatorySubSystemParamName = "pRegulatorySubSystem";
        protected string m_RegulatorySubSystem;
        public const string taskIdentifierParamName = "pTaskIdentifier";
        protected string m_TaskIdentifier;
        public const string logLevelParamName = "pLogLevel";
        protected string m_LogLevel;
        public const string processIdParamName = "pProcessLogId";
        protected string m_ProcessId;
        protected RRDataLayout m_DataLayout;
        protected ProcessBase m_Process;
        private List<string> m_InstrumentsList;
        protected string m_IdRReport;
        private string m_Instrument;
        #endregion
        #region Accessors
        public string Cs
        {
            get { return this.m_Cs; }
            set { this.m_Cs = value; }
        }
        public DateTime BeginDate
        {
            get { return this.m_BeginDate; }
            set { this.m_BeginDate = value; }
        }
        public DateTime EndDate
        {
            get { return this.m_EndDate; }
            set { this.m_EndDate = value; }
        }
        public bool Open
        {
            get { return this.m_Open; }
            set { this.m_Open = value; }
        }
        public bool OpenAndClosed
        {
            get { return this.m_OpenAndClosed; }
            set { this.m_OpenAndClosed = value; }
        }
        public DateTime OpenAndClosedBeginDate
        {
            get { return this.m_OpenAndClosedBeginDate; }
            set { this.m_OpenAndClosedBeginDate = value; }
        }
        public bool Primary
        {
            get { return this.m_Primary; }
            set { this.m_Primary = value; }
        }
        public bool Derivate
        {
            get { return this.m_Derivate; }
            set { this.m_Derivate = value; }
        }
        public DateTime DerivativeBeginDate
        {
            get { return this.m_DerivativeBeginDate; }
            set { this.m_DerivativeBeginDate = value; }
        }
        public Int32 InstrumentGroup
        {
            get { return this.m_InstrumentGroup; }
            set { this.m_InstrumentGroup = value; }
        }
        public string TradesList
        {
            get { return this.m_TradesList; }
            set { this.m_TradesList = value; }
        }
        public List<Int32> FilteredTradesList
        {
            get { return this.m_FilteredTradesList; }
            set { this.m_FilteredTradesList = value; }
        }
        public string RepositoryStyle
        {
            get { return this.m_RepositoryStyle; }
            set { this.m_RepositoryStyle = value; }
        }
        public string RegulatoryCountry
        {
            get { return this.m_RegulatoryCountry; }
            set { this.m_RegulatoryCountry = value; }
        }
        public string RegulatorySubSystem
        {
            get { return this.m_RegulatorySubSystem; }
            set { this.m_RegulatorySubSystem = value; }
        }
        public string TaskIdentifier
        {
            get { return this.m_TaskIdentifier; }
            set { this.m_TaskIdentifier = value; }
        }
        public string LogLevel
        {
            get { return this.m_LogLevel; }
            set { this.m_LogLevel = value; }
        }
        public string ProcessId
        {
            get { return this.m_ProcessId; }
            set { this.m_ProcessId = value; }
        }
        public RRDataLayout DataLayout
        {
            get { return this.m_DataLayout; }
            set { this.m_DataLayout = value; }
        }
        public ProcessBase Process
        {
            get { return this.m_Process; }
            set { this.m_Process = value; }
        }
        public List<string> InstrumentsList
        {
            get { return this.m_InstrumentsList; }
            set { this.m_InstrumentsList = value; }
        }
        public string IdRReport
        {
            get { return this.m_IdRReport; }
            set { this.m_IdRReport = value; }
        }
        public string Instrument
        {
            get { return this.m_Instrument; }
            set { this.m_Instrument = value; }
        }
        #endregion
        #region constructor
        public RegulatoryReportProcess(string pCs)
        {
            Cs = pCs;
            m_InstrumentsList = new List<string>();
            m_FilteredTradesList = new List<Int32>();
        }
        #endregion

        /// <summary>
        /// Capture task parameters
        /// Delete RReport and RReportdet tables for the same treatment date
        /// Read and store datalayout informations
        /// Handle buider methods creation in relation to input parameteres   
        /// </summary>
        /// <param name="m_IOTask"></param>
        /// <param name="Process"></param>
        /// <param name="ReportType"></param>
        /// <param name="UserId"></param>
        /// FI 20170215 [XXXXX] Modify
        public void Start(IOTask m_IOTask, ProcessBase pProcess, string pReportType, int pUserId)
        {
            GetParameters(m_IOTask);
            
            //GS 20110811: set english like default culture
            //FI 20170215 [XXXXX] Appel ThreadTools.SetCurrentCulture
            //SystemTools.SetCurrentCulture(Cst.EnglishCulture);
            ThreadTools.SetCurrentCulture(Cst.EnglishCulture);

            
            RRDeleter Deleter;
            Deleter = new RRDeleter(Cs, EndDate, pReportType);
            Deleter.Delete(Cs, EndDate, pReportType);
            
            AddRReportTreatment(EndDate, pReportType, RegulatorySubSystem, pUserId, ProcessId);
            IdRReport = GetIdRReport(ProcessId);
            RReportInstrumentsList(InstrumentGroup, EndDate, InstrumentsList);
            string currentProduct;
            string currentInstrument;
            // in use only if there are filtered trades list into input parameters
            if (TradesList != null)
            {
                GetFilteredTradesList(TradesList, FilteredTradesList);
                if (FilteredTradesList.Count > 0)
                {
                    foreach (Int32 idt in FilteredTradesList)
                    {
                        currentInstrument = GetInstrument(idt);
                        currentProduct = GetProductIdentifier(currentInstrument);
                        bool isInTheScopeInstrument = IsInTheScopeInstrumentFromFilteredTrade(idt);

                        if (isInTheScopeInstrument == false)
                        {
                            
                            Logger.Log(new LoggerData(LogLevelEnum.Info, "The instrument " + currentInstrument + " is out-of-the scope."));
                        }
                        else
                        {
                            RRDataLayout.Retreive(Cs, currentProduct);
                            RetrieveBuildReportByProduct(currentInstrument, currentProduct, pProcess, pReportType, pUserId, idt);
                        }
                    }
                }
            }
            // no trade filter applied 
            else
            {
                foreach (String instrumentsInList in InstrumentsList)
                {
                    currentInstrument = instrumentsInList;
                    currentProduct = GetProductIdentifier(currentInstrument);
                    RRDataLayout.Retreive(Cs, currentProduct);
                    RetrieveBuildReportByProduct(currentInstrument, currentProduct, pProcess, pReportType, pUserId, Int32.MinValue);
                }

            }
        }

        /// <summary>
        /// Capture task parameters and feed local object 
        /// </summary>
        /// <param name="m_IOTask"></param>
        public void GetParameters(IOTask m_IOTask)
        {
            EndDate = Convert.ToDateTime(m_IOTask.GetTaskParamValue(endDateParamName));
            // First Day in the Month
            BeginDate = new DateTime(EndDate.Year, EndDate.Month, 1);
            Open = Convert.ToBoolean(m_IOTask.GetTaskParamValue(openParamName));
            OpenAndClosed = Convert.ToBoolean(m_IOTask.GetTaskParamValue(openAndClosedParamName));
            OpenAndClosedBeginDate = Convert.ToDateTime(m_IOTask.GetTaskParamValue(openAndClosedBeginDateParamName));
            Primary = Convert.ToBoolean(m_IOTask.GetTaskParamValue(primaryParamName));
            Derivate = Convert.ToBoolean(m_IOTask.GetTaskParamValue(derivativeParamName));
            DerivativeBeginDate = Convert.ToDateTime(m_IOTask.GetTaskParamValue(derivativeBeginDateParamName));
            InstrumentGroup = Convert.ToInt32(m_IOTask.GetTaskParamValue(instrumentGroupParamName));
            RepositoryStyle = m_IOTask.GetTaskParamValue(repositoryStyleParamName);
            TradesList = m_IOTask.GetTaskParamValue(tradesListParamName);
            RegulatoryCountry = m_IOTask.GetTaskParamValue(regulatoryCountryParamName);
            RegulatorySubSystem = m_IOTask.GetTaskParamValue(regulatorySubSystemParamName);
            TaskIdentifier = m_IOTask.GetTaskParamValue(taskIdentifierParamName);
            LogLevel = m_IOTask.GetTaskParamValue(logLevelParamName);
            ProcessId = m_IOTask.GetTaskParamValue(processIdParamName);
        }

        /// <summary>
        /// add one row into rreport table for each execute treatment 
        /// </summary>
        /// <param name="pDtReport"></param>
        /// <param name="pReportType"></param>
        /// <param name="pSubSystem"></param>
        /// <param name="pUserId"></param>
        /// <param name="pProcessId"></param>
        protected void AddRReportTreatment(DateTime pDtReport, string pReportType, string pSubSystem, int pUserId, string pProcessId)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "DTREPORT", DbType.Date), pDtReport); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "REPORTTYPE", DbType.String), pReportType);
            parameters.Add(new DataParameter(Cs, "SUBSYSTEM", DbType.String), pSubSystem);
            // FI 20200820 [25468] dates systemes en UTC
            parameters.Add(DataParameter.GetParameter(Cs, DataParameter.ParameterEnum.DTINS), OTCmlHelper.GetDateSysUTC(Cs));
            parameters.Add(DataParameter.GetParameter(Cs, DataParameter.ParameterEnum.IDAINS), pUserId);
            parameters.Add(new DataParameter(Cs, "PROCESSID", DbType.String), pProcessId);
            StrBuilder sqlInsert = new StrBuilder();
            sqlInsert += SQLCst.INSERT_INTO_DBO + "RREPORT" + Cst.CrLf;
            sqlInsert += "(DTREPORT,REPORTTYPE,SUBSYSTEM,DTINS,IDAINS,PROCESSID) values " + Cst.CrLf;
            sqlInsert += @"(@DTREPORT,@REPORTTYPE,@SUBSYSTEM,@DTINS,@IDAINS,@PROCESSID)" + Cst.CrLf;
            DataHelper.ExecuteNonQuery(Cs, CommandType.Text, sqlInsert.ToString(), parameters.GetArrayDbParameter());

        }

        /// <summary>
        /// Read a report id concerning specific process available into RREPORT table
        /// </summary>
        /// <param name="pProcessId">current proccess id</param>
        /// <returns>IdRReport relative to current process</returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected string GetIdRReport(string pProcessId)
        {
            string idRReport = string.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "PROCESSID", DbType.String), pProcessId);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " IDRREPORT as IDRREPORT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + "RREPORT" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "PROCESSID = @PROCESSID" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["IDRREPORT"]))
                        return idRReport = Convert.ToString(dr["IDRREPORT"]);
                }
            }
            return idRReport;
        }

        /// <summary>
        /// Returns in-the-scope Puma2 instruments from GINSTR table
        /// </summary>
        /// <param name="pInstrumentGroup"></param>
        /// <param name="pEndDate"></param>
        /// <param name="pInstrumentsList"></param>
        protected void RReportInstrumentsList(Int32 pInstrumentGroup, DateTime pEndDate, List<string> pInstrumentsList)
        {
            pInstrumentsList.Clear();

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDGINSTR", DbType.Int32), pInstrumentGroup);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), pEndDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " i.IDENTIFIER as INSTRIDENTIFIER " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.GINSTR.ToString() + " ginstr " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.INSTRG + " instrg " + SQLCst.ON + " (ginstr.IDGINSTR = instrg.IDGINSTR) " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.INSTRUMENT + " i " + SQLCst.ON + " (i.IDI = instrg.IDI) " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ginstr.IDGINSTR = @IDGINSTR " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(instrg.DTDISABLED is NULL or instrg.DTDISABLED > @ENDDATE) " + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                string instrumentIdentifier = Convert.ToString(row["INSTRIDENTIFIER"]);
                pInstrumentsList.Add(instrumentIdentifier);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected void RetrieveBuildReportByProduct(String pInstrument, String pProduct, ProcessBase pProcess, String pReportType, int pUserId, Int32 pIdt)
        {
            // GS 20120308: "swap per swaption" is a specific instrument into BA referential
            // This instrument is a swaption then it is a out-of-the scope in this version
            // The swaption will be handled in a future release  
            if (pInstrument == "swap per swaption")
            {
                
                
                Logger.Log(new LoggerData(LogLevelEnum.Info, "The instrument " + pInstrument + " is out-of-the scope."));
            }
            else
            {
                switch (pProduct)
                {
                    case "swap":
                        RRBuilder Swap;
                        Swap = new RRBuilderSwap(Cs, BeginDate, EndDate, Open, OpenAndClosed, OpenAndClosedBeginDate, Primary, Derivate, DerivativeBeginDate, pInstrument, RepositoryStyle, RegulatorySubSystem, TradesList, IdRReport, pProcess, DataLayout, pUserId, ProcessId, pReportType, pIdt);
                        Swap.Build();
                        break;
                    case "capFloor":
                        RRBuilder Cap;
                        Cap = new RRBuilderCap(Cs, BeginDate, EndDate, Open, OpenAndClosed, OpenAndClosedBeginDate, Primary, Derivate, DerivativeBeginDate, pInstrument, RepositoryStyle, RegulatorySubSystem, TradesList, IdRReport, pProcess, DataLayout, pUserId, ProcessId, pReportType, pIdt);
                        Cap.Build();
                        break;
                    case "bondOption":
                        RRBuilder BondOption;
                        BondOption = new RRBuilderBondOption(Cs, BeginDate, EndDate, Open, OpenAndClosed, OpenAndClosedBeginDate, Primary, Derivate, DerivativeBeginDate, pInstrument, RepositoryStyle, RegulatorySubSystem, TradesList, IdRReport, pProcess, DataLayout, pUserId, ProcessId, pReportType, pIdt);
                        BondOption.Build();
                        break;
                    case "fxSimpleOption":
                        RRBuilder FxSimpleOption;
                        FxSimpleOption = new RRBuilderFxSimpleOption(Cs, BeginDate, EndDate, Open, OpenAndClosed, OpenAndClosedBeginDate, Primary, Derivate, DerivativeBeginDate, pInstrument, RepositoryStyle, RegulatorySubSystem, TradesList, IdRReport, pProcess, DataLayout, pUserId, ProcessId, pReportType, pIdt);
                        FxSimpleOption.Build();
                        break;
                    case "fxBarrierOption":
                        RRBuilder FxBarrierOption;
                        FxBarrierOption = new RRBuilderFxBarrierOption(Cs, BeginDate, EndDate, Open, OpenAndClosed, OpenAndClosedBeginDate, Primary, Derivate, DerivativeBeginDate, pInstrument, RepositoryStyle, RegulatorySubSystem, TradesList, IdRReport, pProcess, DataLayout, pUserId, ProcessId, pReportType, pIdt);
                        FxBarrierOption.Build();

                        break;
                    case "fxDigitalOption":
                        RRBuilder FxDigitalOption;
                        FxDigitalOption = new RRBuilderFxDigitalOption(Cs, BeginDate, EndDate, Open, OpenAndClosed, OpenAndClosedBeginDate, Primary, Derivate, DerivativeBeginDate, pInstrument, RepositoryStyle, RegulatorySubSystem, TradesList, IdRReport, pProcess, DataLayout, pUserId, ProcessId, pReportType, pIdt);
                        FxDigitalOption.Build();
                        break;
                }
            }
        }

        /// <summary>
        /// Returns product identifier from PRODUCT table
        /// </summary>
        /// <param name="pInstrument">instrument identifier</param>
        /// <returns></returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected string GetProductIdentifier(string pInstrument)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), pInstrument);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " p.IDENTIFIER as PRODUCTIDENTIFIER " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.INSTRUMENT.ToString() + " i " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.PRODUCT + " p " + SQLCst.ON + " (p.IDP = i.IDP) " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "i.IDENTIFIER = @INSTRUMENTIDENTIFIER " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                    return Convert.ToString((dr["PRODUCTIDENTIFIER"]));
                else
                    return String.Empty;
            }
        }

        /// <summary>
        /// Feed the list of trade object using a string that contains a comma-separated list of trade 
        /// </summary>
        /// <param name="pTradesListString"></param>
        /// <param name="pFilteredTradesList"></param>
        protected void GetFilteredTradesList(String pTradesListString, List<Int32> pFilteredTradesList)
        {
            pFilteredTradesList.Clear();
            char charSeparator = ',';

            foreach (string trade in pTradesListString.Split(charSeparator))
            {
                Int32 idt = GetTradeId(trade);
                pFilteredTradesList.Add(idt);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pTradeIdentifier"></param>
        /// <returns></returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected Int32 GetTradeId(String pTradeIdentifier)
        {
            Int32 idt = Int32.MinValue;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDENTIFIER", DbType.String), pTradeIdentifier);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " t.IDT as IDT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + "  t " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDENTIFIER = @IDENTIFIER" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["IDT"]))
                        idt = Convert.ToInt32(dr["IDT"]);
                }
            }
            return idt;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <returns></returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected string GetInstrument(Int32 pIdt)
        {
            string instrument = string.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " i.IDENTIFIER as INSTRUMENT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.INSTRUMENT + " i " + SQLCst.ON + " i.IDI = t.IDI " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["INSTRUMENT"]))
                        return instrument = Convert.ToString(dr["INSTRUMENT"]);
                }
            }
            return instrument;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <returns></returns>
        protected bool IsInTheScopeInstrumentFromFilteredTrade(Int32 pIdt)
        {

            bool ret = false;
            string instrumentByFilterTrade = GetInstrument(pIdt);

            foreach (string instrument in InstrumentsList)
            {
                if (instrument == instrumentByFilterTrade)
                    ret = true;
            }
            return ret;

        }
    }

    /// <summary>
    /// Delete RReport and RReportdet tables on the same treatment date
    /// </summary>
    public class RRDeleter
    {
        #region Members
        protected string m_Cs;
        protected DateTime m_EndDate;
        protected string m_ReportType;
        #endregion
        #region Accessors
        public string Cs
        {
            get { return this.m_Cs; }
            set { this.m_Cs = value; }
        }
        public DateTime EndDate
        {
            get { return this.m_EndDate; }
            set { this.m_EndDate = value; }
        }
        public string ReportType
        {
            get { return this.m_ReportType; }
            set { this.m_ReportType = value; }
        }
        #endregion
        #region constructor
        public RRDeleter(string pCs, DateTime pEndDate, string pReportType)
        {
            Cs = pCs;
            EndDate = pEndDate;
            ReportType = pReportType;

        }
        #endregion

        /// <summary>
        /// Returns process ID from RREPORT table 
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pEndDate"></param>
        /// <param name="pReportType"></param>
        /// <returns>Process id for specific treatment date and report type</returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        private string GetProcessId(string pCS, DateTime pEndDate, string pReportType)
        {
            string processId = string.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(pCS, "ENDDATE", DbType.Date), pEndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(pCS, "REPORTTYPE", DbType.String), pReportType);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " PROCESSID as PROCESSID " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + "RREPORT" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "REPORTTYPE = @REPORTTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "DTREPORT = @ENDDATE" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["PROCESSID"]))
                        return processId = Convert.ToString(dr["PROCESSID"]);
                }
            }
            return processId;
        }

        /// <summary>
        /// delete RREPORTDET rows relative to a specific process id  
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pProcessId"></param>
        private void DeleteRReportdet(string pCS, string pProcessId)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(pCS, "PROCESSID", DbType.String), pProcessId);
            StrBuilder sqlDelete = new StrBuilder();
            sqlDelete += SQLCst.DELETE_DBO + "RREPORTDET" + Cst.CrLf;
            sqlDelete += SQLCst.WHERE + "PROCESSID = @PROCESSID" + Cst.CrLf;
            DataHelper.ExecuteNonQuery(pCS, CommandType.Text, sqlDelete.ToString(), parameters.GetArrayDbParameter());
        }

        /// <summary>
        /// delete RREPORT row relative to a specific process id  
        /// </summary>
        /// <param name="pCS"></param>
        /// <param name="pProcessId"></param>
        private void DeleteRReport(string pCS, string pProcessId)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(pCS, "PROCESSID", DbType.String), pProcessId);
            StrBuilder sqlDelete = new StrBuilder();
            sqlDelete += SQLCst.DELETE_DBO + "RREPORT" + Cst.CrLf;
            sqlDelete += SQLCst.WHERE + "PROCESSID = @PROCESSID" + Cst.CrLf;
            DataHelper.ExecuteNonQuery(pCS, CommandType.Text, sqlDelete.ToString(), parameters.GetArrayDbParameter());
        }

        /// <summary>
        /// call methods for deleting rows into RREPORT and RREPORTDET tables using a specific process id
        /// </summary>
        /// <param name="pCS"></param>
        public void Delete(string pCS, DateTime pEndDate, string pReportType)
        {
            string processId = GetProcessId(pCS, pEndDate, pReportType);
            this.DeleteRReportdet(pCS, processId);
            this.DeleteRReport(pCS, processId);
        }
    }

    /// <summary>
    /// Datalayout class
    /// handle static fields 
    /// create missing value log messages using the alert level parameters from the datalayout 
    /// feed source attribute for each data tag (process/static/missing)
    /// </summary>
    public class RRDataLayout
    {
        #region Members
        protected static DataSet m_DataLayout;
        protected static string m_Cs;
        public struct DataLayoutInformation
        {
            public string datatype;
            public string dataLength;
            public string dataStart;
            public string alignment;
            public string fillChar;
            public string grpSeparator;
            public string decSeparator;
            public string dataSeparator;
            public string defaultValue;
            public string defaultRule;
            public bool isMeaning;
            public bool isFromProcess;
            public string staticValue;
            public string missingAlertLevel;
            public string idIoParsing;
        };
        #endregion
        #region Accessors
        public static DataSet DataLayout
        {
            get { return m_DataLayout; }
            set { m_DataLayout = value; }
        }
        public string Cs
        {
            get { return m_Cs; }
            set { m_Cs = value; }
        }
        #endregion
        #region constructor
        public RRDataLayout(string pCs)
        {
            m_Cs = pCs;
        }
        #endregion

        /// <summary>
        /// create dataset contains specific product (eg: IRS, CAP) datalayout informations from RREPORT_DATALAYOUT
        /// </summary>
        /// <param name="Cs"></param>
        /// <param name="Product"></param>
        public static void Retreive(string pCs, string pProduct)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(pCs, "PRODUCT", DbType.String), pProduct);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " dl.DATA_TYPE as DATA_TYPE, dl.FIELD_NAME as FIELD_NAME, dl.FORMA_TECNICA as FORMA_TECNICA, dl.IS_MEANING as IS_MEANING, " + Cst.CrLf;
            sqlSelect += "dl.IS_FROM_PROCESS as IS_FROM_PROCESS, dl.STATIC_VALUE as STATIC_VALUE, dl.MISSING_ALERT_LEVEL as MISSING_ALERT_LEVEL, io.IDIOPARSING as IDIOPARSING, " + Cst.CrLf;
            sqlSelect += "io.DATALENGTH as DATALENGTH, io.DATASTART as DATASTART, io.ALIGNMENT as ALIGNMENT, io.FILLCHAR as FILLCHAR, io.GRPSEPARATOR as GRPSEPARATOR, io.DECSEPARATOR as DECSEPARATOR," + Cst.CrLf;
            sqlSelect += "io.FORMAT as FORMAT, io.DATASEPARATOR as DATASEPARATOR, io.DEFAULTVALUE as DEFAULTVALUE, io.DEFAULTRULE as DEFAULTRULE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + "RREPORT_DATALAYOUT" + " dl " + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.IOPARSINGDET + " io " + SQLCst.ON + "(io.IDIOPARSING = dl.IDIOPARSING)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "io.IDIOPARSINGDET = dl.FIELD_NAME";
            sqlSelect += SQLCst.WHERE + "dl.PRODUCT = @PRODUCT";
            DataLayout = DataHelper.ExecuteDataset(pCs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
        }

        /// <summary>
        /// Feed DataLayoutInformation reference using datalayout dataset
        /// cicle on forma tecnica e field name
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFieldName"></param>
        /// <param name="pDLInformation"></param>
        public static void GetDataLayoutInformation(string pFormaTecnicaName, string pFieldName, ref DataLayoutInformation pDLInformation)
        {
            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();

            foreach (DataRow row in rows)
            {
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                string fieldName = Convert.ToString(row["FIELD_NAME"]);
                //
                if (formaTecnica == pFormaTecnicaName & fieldName == pFieldName)
                {
                    pDLInformation.datatype = Convert.ToString(row["DATA_TYPE"]);
                    pDLInformation.isMeaning = Convert.ToBoolean(row["IS_MEANING"]);
                    pDLInformation.isFromProcess = Convert.ToBoolean(row["IS_FROM_PROCESS"]);
                    pDLInformation.staticValue = Convert.ToString(row["STATIC_VALUE"]);
                    pDLInformation.missingAlertLevel = Convert.ToString(row["MISSING_ALERT_LEVEL"]);
                    pDLInformation.idIoParsing = Convert.ToString(row["IDIOPARSING"]);
                    pDLInformation.dataLength = Convert.ToString(row["DATALENGTH"]);
                    pDLInformation.dataStart = Convert.ToString(row["DATASTART"]);
                    pDLInformation.alignment = Convert.ToString(row["ALIGNMENT"]);
                    pDLInformation.fillChar = Convert.ToString(row["FILLCHAR"]);
                    pDLInformation.grpSeparator = Convert.ToString(row["GRPSEPARATOR"]);
                    pDLInformation.decSeparator = Convert.ToString(row["DECSEPARATOR"]);
                    pDLInformation.dataSeparator = Convert.ToString(row["DATASEPARATOR"]);
                    pDLInformation.defaultValue = Convert.ToString(row["DEFAULTVALUE"]);
                    pDLInformation.defaultRule = Convert.ToString(row["DEFAULTRULE"]);
                }
            }

        }

        /// <summary>
        /// cicle on datalayout dataset for specific forma tecnica and returns count of meaning fields
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <returns>number of meaning fields into datalayout table for specific forma tecnica</returns>
        public static int MaxCountFieldInDataLayout(string pFormaTecnicaName)
        {
            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();

            int count = 0;
            foreach (DataRow row in rows)
            {
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                Boolean isMeaning = Convert.ToBoolean(row["IS_MEANING"]);
                //
                if (formaTecnica == pFormaTecnicaName & isMeaning == true)
                {
                    count++;
                }
            }
            return count;
        }

        /// <summary>
        /// create and feed data objects for each static field into datalayout
        /// to detect a static field (isFromProcess attribut=false)
        /// The following values are passed to the method:
        /// source="static" string
        /// staticValue= static value from datalayout
        /// </summary>
        /// <param name="pFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public static void HandleStaticData(RegulatoryReportReportFormaTecnica pFormaTecnica, int pDataIndex)
        {

            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();
            //
            foreach (DataRow row in rows)
            {
                bool isFromProcess = Convert.ToBoolean(row["IS_FROM_PROCESS"]);
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                if (formaTecnica == pFormaTecnica.name & isFromProcess == false)
                {
                    string fieldName = Convert.ToString(row["FIELD_NAME"]);
                    string source = Convert.ToString("static");
                    string staticValue = GetStaticValue(formaTecnica, fieldName);
                    pFormaTecnica.data[pDataIndex] = RRBuilder.BuildDataObject(pDataIndex, fieldName, source, staticValue);
                    pDataIndex++;
                }
            }

        }

        /// <summary>
        /// returns formatted out-of-the-scope data
        /// fill data using out-of-the-scope character for the entire data lenght
        /// 
        /// to do: remplace this method with a common method  
        /// merge GetFormattedMissingData and GetFormattedOutOfTheScopeData methods
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFieldName"></param>
        /// <param name="pOutOfTheScopeValue"></param>
        /// <returns>        
        /// Oasi examples for a field having 10 characters in lenght
        /// Missing value is "=" character - the returned value is "=========="
        /// Out of the scope value is "*" character (used into intrinsic values) - the returned value is "**********"
        /// </returns>
        public static string GetFormattedOutOfTheScopeData(string pFormaTecnicaName, string pFieldName, string pOutOfTheScopeValue)
        {
            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();

            string value = null;
            foreach (DataRow row in rows)
            {
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                string fieldName = Convert.ToString(row["FIELD_NAME"]);

                if (formaTecnica == pFormaTecnicaName & fieldName == pFieldName)
                {
                    UInt16 dataLength = Convert.ToUInt16(row["DATALENGTH"]);
                    char fillChar = Convert.ToChar(pOutOfTheScopeValue);
                    string missingValue = pOutOfTheScopeValue;
                    value = missingValue.PadLeft(dataLength, fillChar);
                    return value;
                }
            }
            return value;
        }

        /// <summary>
        /// to do: remplace this method with a common method  
        /// merge GetFormattedMissingData and GetFormattedOutOfTheScopeData methods
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFieldName"></param>
        /// <param name="pMissingValue"></param>
        /// <returns></returns>
        public static string GetFormattedMissingData(string pFormaTecnicaName, string pFieldName, string pMissingValue)
        {
            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();

            string value = null;
            foreach (DataRow row in rows)
            {
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                string fieldName = Convert.ToString(row["FIELD_NAME"]);

                if (formaTecnica == pFormaTecnicaName & fieldName == pFieldName)
                {
                    UInt16 dataLength = Convert.ToUInt16(row["DATALENGTH"]);
                    char fillChar = Convert.ToChar(pMissingValue);
                    string missingValue = pMissingValue;
                    value = missingValue.PadLeft(dataLength, fillChar);
                    return value;
                }
            }
            return value;
        }

        /// <summary>
        /// formatted static value
        /// fill data using static value character from datalayout for the entire data lenght
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFieldName"></param>
        public static string GetStaticValue(string pFormaTecnicaName, string pFieldName)
        {
            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();

            string value = null;
            foreach (DataRow row in rows)
            {
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                string fieldName = Convert.ToString(row["FIELD_NAME"]);

                if (formaTecnica == pFormaTecnicaName & fieldName == pFieldName)
                {
                    UInt16 dataLength = Convert.ToUInt16(row["DATALENGTH"]);
                    string staticValue = Convert.ToString(row["STATIC_VALUE"]);

                    int count = staticValue.Length;

                    if (count == dataLength)
                        value = staticValue;
                    else
                    {
                        char fillChar = Convert.ToChar(row["STATIC_VALUE"]);
                        value = staticValue.PadLeft(dataLength, fillChar);
                    }
                    return value;
                }
            }
            return value;
        }

        /// <summary>
        /// returns formatted data using datalayout and parsing parameters
        /// handle decimal and string data type
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFieldName"></param>
        /// <param name="pDataValue"></param>
        /// <returns></returns>
        public static string GetFormattedProcessData(string pFormaTecnicaName, string pFieldName, string pDataValue)
        {
            DataTable dt = DataLayout.Tables[0];
            DataRow[] rows = dt.Select();

            string value;
            foreach (DataRow row in rows)
            {
                string formaTecnica = Convert.ToString(row["FORMA_TECNICA"]);
                string fieldName = Convert.ToString(row["FIELD_NAME"]);
                //
                if (formaTecnica == pFormaTecnicaName & fieldName == pFieldName)
                {
                    string dataType = Convert.ToString(row["DATA_TYPE"]);
                    // decimal format from datalayout
                    if (dataType == "decimal")
                    {
                        UInt16 dataLength = Convert.ToUInt16(row["DATALENGTH"]);
                        char fillChar = Convert.ToChar(row["FILLCHAR"]);
                        // GS FI 20110812: to do convert string in decimal using invariant culture
                        //decimal ConvertDataValueInDecimalType = DecFunc.DecValueFromInvariantCulture(pDataValue); 
                        decimal ConvertDataValueInDecimalType = Convert.ToDecimal(pDataValue);
                        //
                        string dataFormat = Convert.ToString(row["FORMAT"]);
                        string format = String.Empty;
                        //
                        switch (dataFormat)
                        {

                            case "##.#####":
                                format = "0:0.00000";
                                break;
                            case "##.######":
                                format = "0:0.000000";
                                break;
                            case "##.########":
                                format = "0:0.00000000";
                                break;
                            case "#,##0.0":
                                format = "0:0.0";
                                break;
                            case "#,##0.00":
                                format = "0:0.00";
                                break;
                            case "#,##0.000":
                                format = "0:0.000";
                                break;
                            case "#,##0.0000":
                                format = "0:0.0000";
                                break;
                            case "#,##0.00000":
                                format = "0:0.00000";
                                break;
                            case "#,##0.000000":
                                format = "0:0.000000";
                                break;
                            case "#,##0.0000000":
                                format = "0:0.0000000";
                                break;
                            case "#,##0.00000000":
                                format = "0:0.00000000";
                                break;
                            case "#,##0.000000000":
                                format = "0:0.000000000";
                                break;
                            case "#,##0.0000000000":
                                format = "0:0.0000000000";
                                break;
                        }
                        //string decSeparator = Convert.ToString(row["DECSEPARATOR"]);
                        //string grpSeparator = Convert.ToString(row["GRPSEPARATOR"]);
                        string alignment = Convert.ToString(row["ALIGNMENT"]);
                        // right alignment use PadLeft
                        if (alignment == "RIGHT")
                            value = String.Format("{" + format + "}", ConvertDataValueInDecimalType).Replace(".", string.Empty).PadLeft(dataLength, fillChar);
                        // left alignment use PadRight
                        else
                            value = String.Format("{" + format + "}", ConvertDataValueInDecimalType).Replace(".", string.Empty).PadRight(dataLength, fillChar);
                        //
                        return value;
                    }
                    // decimal format from datalayout
                    if (dataType == "string")
                    {
                        UInt16 dataLength = Convert.ToUInt16(row["DATALENGTH"]);
                        // using pad replace only if parsing datalengh is longest than value length  
                        if (dataLength > pDataValue.Length)
                        {
                            char fillChar = Convert.ToChar(row["FILLCHAR"]);
                            value = pDataValue.PadLeft(dataLength, fillChar);
                        }
                        else
                            value = pDataValue;
                    }
                }
                value = pDataValue;
            }
            value = pDataValue;
            return value;
        }
    }

    /// <summary>
    /// empty class 
    /// the report is builded from specific child classes created for each product 
    /// </summary>
    public class RRBuilder
    {
        #region Members
        protected string m_Cs;
        private string m_DomesticCurrency;
        protected DateTime m_BeginDate;
        protected DateTime m_EndDate;
        protected bool m_Open;
        protected bool m_OpenAndClosed;
        protected DateTime m_OpenAndClosedBeginDate;
        protected bool m_Primary;
        protected bool m_Derivate;
        protected DateTime m_DerivativeBeginDate;
        protected string m_InstrumentIdentifier;
        protected string m_RepositoryStyle;
        protected string m_RegulatorySubSystem;
        protected string m_IdRReport;
        protected Int32 m_Idt;
        // 
        protected ProcessBase m_Process;
        protected RegulatoryReport m_Report;
        protected RegulatoryReportReport m_ReportReport;
        protected RRDataLayout m_DataLayout;
        protected RRBusiness m_Business;
        protected RRPuma2 m_Puma2;
        protected RRLog m_Log;
        protected RRStore m_Store;
        private List<Int32> m_OpenTradesList;
        private List<Int32> m_OpenAndClosedTradesList;
        private int m_UserId;
        private string m_ProcessId;
        private string m_ReportType;
        private string m_BeginMessage;
        private string m_EndMessage;
        private string m_TradeIdentifier;
        #endregion
        #region Accessors
        public string Cs
        {
            get { return this.m_Cs; }
            set { this.m_Cs = value; }
        }
        public string DomesticCurrency
        {
            get { return this.m_DomesticCurrency; }
            set { this.m_DomesticCurrency = value; }
        }
        public DateTime BeginDate
        {
            get { return this.m_BeginDate; }
            set { this.m_BeginDate = value; }
        }
        public DateTime EndDate
        {
            get { return this.m_EndDate; }
            set { this.m_EndDate = value; }
        }
        public bool Open
        {
            get { return this.m_Open; }
            set { this.m_Open = value; }
        }
        public bool OpenAndClosed
        {
            get { return this.m_OpenAndClosed; }
            set { this.m_OpenAndClosed = value; }
        }
        public DateTime OpenAndClosedBeginDate
        {
            get { return this.m_OpenAndClosedBeginDate; }
            set { this.m_OpenAndClosedBeginDate = value; }
        }
        public bool Primary
        {
            get { return this.m_Primary; }
            set { this.m_Primary = value; }
        }
        public bool Derivate
        {
            get { return this.m_Derivate; }
            set { this.m_Derivate = value; }
        }
        public DateTime DerivativeBeginDate
        {
            get { return this.m_DerivativeBeginDate; }
            set { this.m_DerivativeBeginDate = value; }
        }
        public string RepositoryStyle
        {
            get { return this.m_RepositoryStyle; }
            set { this.m_RepositoryStyle = value; }
        }
        public string InstrumentIdentifier
        {
            get { return this.m_InstrumentIdentifier; }
            set { this.m_InstrumentIdentifier = value; }
        }
        public string RegulatorySubSystem
        {
            get { return this.m_RegulatorySubSystem; }
            set { this.m_RegulatorySubSystem = value; }
        }
        public string IdRReport
        {
            get { return this.m_IdRReport; }
            set { this.m_IdRReport = value; }
        }
        public ProcessBase Process
        {
            get { return this.m_Process; }
            set { this.m_Process = value; }
        }
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public RegulatoryReportReport ReportReport
        {
            get { return this.m_ReportReport; }
            set { this.m_ReportReport = value; }
        }
        public RRBusiness Business
        {
            get { return this.m_Business; }
            set { this.m_Business = value; }
        }
        public RRPuma2 Puma2
        {
            get { return this.m_Puma2; }
            set { this.m_Puma2 = value; }
        }
        public RRStore Store
        {
            get { return this.m_Store; }
            set { this.m_Store = value; }
        }
        public List<Int32> OpenTradesList
        {
            get { return this.m_OpenTradesList; }
            set { this.m_OpenTradesList = value; }
        }
        public List<Int32> OpenAndClosedTradesList
        {
            get { return this.m_OpenAndClosedTradesList; }
            set { this.m_OpenAndClosedTradesList = value; }
        }
        public RRDataLayout DataLayout
        {
            get { return this.m_DataLayout; }
            set { this.m_DataLayout = value; }
        }
        public RRLog Log
        {
            get { return this.m_Log; }
            set { this.m_Log = value; }
        }
        public int UserId
        {
            get { return this.m_UserId; }
            set { this.m_UserId = value; }
        }
        public string ProcessId
        {
            get { return this.m_ProcessId; }
            set { this.m_ProcessId = value; }
        }
        public string ReportType
        {
            get { return this.m_ReportType; }
            set { this.m_ReportType = value; }
        }
        public Int32 Idt
        {
            get { return this.m_Idt; }
            set { this.m_Idt = value; }
        }
        public string BeginMessage
        {
            get { return this.m_BeginMessage; }
            set { this.m_BeginMessage = value; }
        }
        public string EndMessage
        {
            get { return this.m_EndMessage; }
            set { this.m_EndMessage = value; }
        }
        public string TradeIdentifier
        {
            get { return this.m_TradeIdentifier; }
            set { this.m_TradeIdentifier = value; }
        }
        #endregion
        #region constructor
        //
        public RRBuilder(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, 
            bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, 
            string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
        {
            Cs = pCs;
            m_DomesticCurrency = "EUR";
            m_EndDate = pEndDate;
            m_BeginDate = pBeginDate;
            m_Open = pOpen;
            m_OpenAndClosed = pOpenAndClosed;
            m_OpenAndClosedBeginDate = pOpenAndClosedBeginDate;
            m_Primary = pPrimary;
            m_Derivate = pDerivate;
            m_DerivativeBeginDate = pDerivativeBeginDate;
            m_InstrumentIdentifier = pInstrumentIdentifier;
            m_RepositoryStyle = pRepositoryStyle;
            m_RegulatorySubSystem = pRegulatorySubSystem;
            m_Process = pProcess;
            m_DataLayout = pDataLayout;
            m_Business = null;
            m_Report = null;
            m_ReportReport = null;
            m_OpenTradesList = new List<Int32>();
            m_OpenAndClosedTradesList = new List<Int32>();
            m_IdRReport = pIdRReport;
            m_UserId = pUserId;
            m_ProcessId = pProcessId;
            m_ReportType = pReportType;
            m_Idt = pIdt;
        }
        public RRBuilder(string pCs)
        {
            Cs = pCs;
            m_Report = null;
            m_Business = null;
            m_OpenTradesList = new List<Int32>();
            m_OpenAndClosedTradesList = new List<Int32>();
        }
        #endregion

        virtual public void SelectOpenTradesList(List<Int32> pOpenTradesList) { }
        virtual public void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList) { }

        /// <summary>
        /// BuildDataObject
        /// Build the object "Data"
        /// </summary>
        /// <param name="pDataId"></param>
        /// <param name="pDataSource"></param>
        /// <param name="pDataValue"></param>
        /// <returns></returns>
        static public RegulatoryReportReportFormaTecnicaData BuildDataObject(int pDataIndex, string pDataId, string pDataSource, string pDataValue)
        {
            return new RegulatoryReportReportFormaTecnicaData(pDataIndex, pDataId, pDataSource, pDataValue);
        }

        /// <summary>
        /// 
        /// </summary>
        public void Build()
        {
            // filtered trades 
            if (Idt != Int32.MinValue)
            {
                bool isRemovedTrade = IsRemovedTrade(Idt, EndDate);
                if (isRemovedTrade == true)
                {
                    String tradeidentifier = GetTradeIdentifier(Idt);

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Info, "The filtered trade " + tradeidentifier + " is removed. The process is stopped for this trade."));
                }
                else
                {
                    SelectOpenTradesList(OpenTradesList);
                    if (OpenAndClosedBeginDate != DateTime.MinValue)
                        SelectOpenAndClosedTradesList(OpenAndClosedTradesList);
                    bool isCandidateTrade = IsCandidateTrade(Idt, OpenTradesList, OpenAndClosedTradesList);
                    bool isOpenTrade = IsOpenTrade(Idt, OpenTradesList, OpenAndClosedTradesList);

                    if (isCandidateTrade == true)
                    {
                        if (isOpenTrade == true)
                            InizializeReport(Idt, true);
                        else
                            InizializeReport(Idt, false);
                    }
                }
            }
            // cycle on trades by product
            else
            {
                if (Open == true)
                    CycleOpenTrades();
                if (OpenAndClosed == true && OpenAndClosedBeginDate != DateTime.MinValue)
                    CycleOpenAndClosedTrades();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public virtual void BuildReport()
        {
        }

        /// <summary>
        /// 
        /// </summary>
        protected void CycleOpenTrades()
        {
            SelectOpenTradesList(OpenTradesList);
            if (OpenTradesList.Count == 0)
            {
                
                Logger.Log(new LoggerData(LogLevelEnum.Info, "Instrument id [" + InstrumentIdentifier + "]. No rows are selected for open trades."));
            }
            else
            {

                
                Logger.Log(new LoggerData(LogLevelEnum.Info, "Begin Cycle Instrument id [" + InstrumentIdentifier + "]. Count [" + OpenTradesList.Count + "]."));

                foreach (Int32 idt in OpenTradesList)
                {
                    if (!IsRemovedTrade(idt, EndDate))
                    {
                        InizializeReport(idt, true);
                    }
                }
                

                
                Logger.Log(new LoggerData(LogLevelEnum.Info, "End Cycle Instrument id [" + InstrumentIdentifier + "]."));
            }

        }

        /// <summary>
        /// 
        /// </summary>
        protected void CycleOpenAndClosedTrades()
        {
            SelectOpenAndClosedTradesList(OpenAndClosedTradesList);
            if (OpenAndClosedTradesList.Count == 0)
            {
                
                Logger.Log(new LoggerData(LogLevelEnum.Info, "Instrument id [ " + InstrumentIdentifier + "]. No rows are selected for open and closed trades."));
            }
            else
            {
                foreach (Int32 idt in OpenAndClosedTradesList)
                {
                    if (!IsRemovedTrade(idt, EndDate))
                    {
                        InizializeReport(idt, false);
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        protected void InizializeReport(Int32 pIdt, bool pIsOpen)
        {
            Int32 idt = pIdt;
            TradeIdentifier = GetTradeIdentifier(idt);
            BeginMessage = GetBeginMessage();
            EndMessage = GetEndMessage();

            
            Logger.Log(new LoggerData(LogLevelEnum.Info, BeginMessage));

            //
            BuildReport();

            if (pIsOpen == true)
                SetOpenTradesStatus();
            else
                SetOpenAndClosedTradesStatus();

            Business.FeedReportBusiness(idt, Open, Derivate, DerivativeBeginDate, RepositoryStyle);

            if (Report.trade.header.isInTheScope == true)
            {
            Puma2.FeedReportPuma2(RegulatorySubSystem, Log);
            Store.Store(idt);
        }
        }

        /// <summary>
        /// SetOpenTradesStatus
        /// set status open=true for each open trade
        /// </summary>
        protected void SetOpenTradesStatus()
        {
            Report.trade.header.isOpen = true;
            Report.trade.header.isOpenAndClosed = false;
        }

        /// <summary>
        /// SetOpenAndClosedTradesStatus
        /// set status openAndClosed = true for each openAndClosed trade
        /// </summary>
        /// <param name="pIdt"></param>
        protected void SetOpenAndClosedTradesStatus()
        {
            Report.trade.header.isOpen = false;
            Report.trade.header.isOpenAndClosed = true;
        }

        /// <summary>
        /// returns true if a trade is removed
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pEndDate"></param>
        /// <returns></returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected bool IsRemovedTrade(Int32 pIdt, DateTime pEndDate)
        {
            bool ret = false;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), pEndDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " count(*) as COUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'RMV' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT <= @ENDDATE " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    int count = Convert.ToInt32(dr["COUNT"]);
                    if (count > 0)
                        ret = true;
                    else
                        ret = false;
                }
            }
            return ret;
        }

        protected string GetTradeIdentifier(Int32 pIdT)
        {
            string tradeIdentifier = string.Empty;
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdT);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " t.IDENTIFIER as IDENTIFIER" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + "  t " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["IDENTIFIER"]))
                        tradeIdentifier = Convert.ToString(dr["IDENTIFIER"]);
                }
            }
            return tradeIdentifier;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pInstrument"></param>
        /// <returns></returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected string GetProduct(String pInstrument)
        {
            string product = string.Empty;
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "INSTRUMENT", DbType.String), pInstrument);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " p.IDENTIFIER as PRODUCT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.PRODUCT.ToString() + " p " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.INSTRUMENT + " i " + SQLCst.ON + " i.IDP = p.IDP " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "i.IDENTIFIER = @INSTRUMENT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["PRODUCT"]))
                        product = Convert.ToString(dr["PRODUCT"]);
                }
            }
            return product;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>message</returns>
        protected string GetBeginMessage()
        {
            string message = "<b>Process trade identifier = " + Convert.ToString(TradeIdentifier) + "</b>";
            return message;
        }

        protected string GetEndMessage()
        {
            string message = "<b>End processing of the trade [identifier = " + Convert.ToString(TradeIdentifier) + "]</b>";
            return message;
        }

        /// <summary>
        /// returns true for open or open and closed trade 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pOpenTradesList"></param>
        /// <param name="pOpenAndClosedTradesList"></param>
        /// <returns></returns>
        protected bool IsCandidateTrade(Int32 pIdt, List<Int32> pOpenTradesList, List<Int32> pOpenAndClosedTradesList)
        {
            bool ret = false;

            foreach (Int32 id in pOpenTradesList)
            {
                if (pIdt == id)
                    ret = true;
            }

            if (ret == false)
            {
                foreach (Int32 id in pOpenAndClosedTradesList)
                {
                    if (pIdt == id)
                        ret = true;
                }
            }
            return ret;
        }

        /// <summary>
        /// returns true for open trade
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pOpenTradesList"></param>
        /// <param name="pOpenAndClosedTradesList"></param>
        /// <returns></returns>
        protected bool IsOpenTrade(Int32 pIdt, List<Int32> pOpenTradesList, List<Int32> pOpenAndClosedTradesList)
        {
            bool ret = false;

            foreach (Int32 id in pOpenTradesList)
            {
                if (pIdt == id)
                    ret = true;
            }
            return ret;
        }

    }

    /// <summary>
    /// Build a swap report 
    /// </summary>
    public class RRBuilderSwap : RRBuilder
    {
        public RRBuilderSwap(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
            :
            base(pCs, pBeginDate, pEndDate, pOpen, pOpenAndClosed, pOpenAndClosedBeginDate, pPrimary, pDerivate, pDerivativeBeginDate, pInstrumentIdentifier, pRepositoryStyle, pRegulatorySubSystem, pTradesList, pIdRReport, pProcess, pDataLayout, pUserId, pProcessId, pReportType, pIdt)
        { }

        public override void BuildReport()
        {
            Report = new RegulatoryReport();
            Business = new RRBusinessSwap(Cs, DomesticCurrency, Process, Report, BeginDate, EndDate, OpenAndClosedBeginDate, DerivativeBeginDate, InstrumentIdentifier, RepositoryStyle);
            Puma2 = new RRPuma2Swap(DomesticCurrency, Report);
            Log = new RRLog(Report, ReportReport);
            Store = new RRStore(Cs, Report, IdRReport, UserId, ProcessId, ReportType);
        }

        /// <summary>
        /// Feed list contains the open trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>  
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenTradesList(List<Int32> pOpenTradesList)
        {
            pOpenTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT <= @ENDDATE) and (ev.DTENDADJ >= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect, parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenTradesList.Add(idt);
            }
        }

        /// <summary>
        /// Feed list contains open and closed trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenAndClosedTradesList"></param>
        public override void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList)
        {
            pOpenAndClosedTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "OPENANDCLOSEDBEGINDATE", DbType.Date), OpenAndClosedBeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT >= @OPENANDCLOSEDBEGINDATE) and (ev.DTENDADJ <= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenAndClosedTradesList.Add(idt);
            }
        }
    }

    /// <summary>
    /// Build a cap report 
    /// </summary>
    public class RRBuilderCap : RRBuilder
    {
        public RRBuilderCap(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
            :
            base(pCs, pBeginDate, pEndDate, pOpen, pOpenAndClosed, pOpenAndClosedBeginDate, pPrimary, pDerivate, pDerivativeBeginDate, pInstrumentIdentifier, pRepositoryStyle, pRegulatorySubSystem, pTradesList, pIdRReport, pProcess, pDataLayout, pUserId, pProcessId, pReportType, pIdt)

        { }

        /// <summary>
        /// 
        /// </summary>
        public override void BuildReport()
        {
            Report = new RegulatoryReport();
            Business = new RRBusinessCap(Cs, DomesticCurrency, Process, Report, BeginDate, EndDate, OpenAndClosedBeginDate, DerivativeBeginDate, InstrumentIdentifier, RepositoryStyle);
            Puma2 = new RRPuma2Cap(DomesticCurrency, Report);
            Log = new RRLog(Report, ReportReport);
            Store = new RRStore(Cs, Report, IdRReport, UserId, ProcessId, ReportType);
        }

        /// <summary>
        /// Feed list contains open trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenTradesList(List<Int32> pOpenTradesList)
        {
            pOpenTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT < @ENDDATE) and (ev.DTENDADJ >= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenTradesList.Add(idt);
            }
        }

        /// <summary>
        /// Feed list contains open and closed trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList)
        {
            pOpenAndClosedTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "OPENANDCLOSEDBEGINDATE", DbType.Date), OpenAndClosedBeginDate);// FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);
            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT >= @OPENANDCLOSEDBEGINDATE) and (ev.DTENDADJ <= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenAndClosedTradesList.Add(idt);
            }
        }
    }

    /// <summary>
    /// Build a BondOption report 
    /// </summary>
    public class RRBuilderBondOption : RRBuilder
    {
        public RRBuilderBondOption(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
            :
            base(pCs, pBeginDate, pEndDate, pOpen, pOpenAndClosed, pOpenAndClosedBeginDate, pPrimary, pDerivate, pDerivativeBeginDate, pInstrumentIdentifier, pRepositoryStyle, pRegulatorySubSystem, pTradesList, pIdRReport, pProcess, pDataLayout, pUserId, pProcessId, pReportType, pIdt)
        { }

        /// <summary>
        /// 
        /// </summary>
        public override void BuildReport()
        {
            Report = new RegulatoryReport();
            Business = new RRBusinessBondOption(Cs, DomesticCurrency, Process, Report, BeginDate, EndDate, OpenAndClosedBeginDate, DerivativeBeginDate, InstrumentIdentifier, RepositoryStyle);
            Puma2 = new RRPuma2BondOption(DomesticCurrency, Report);
            Log = new RRLog(Report, ReportReport);
            Store = new RRStore(Cs, Report, IdRReport, UserId, ProcessId, ReportType);
        }


        /// <summary>
        /// Feed list contains the open trades at the treatment date
        /// </summary>  
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenTradesList(List<Int32> pOpenTradesList)
        {
            string product = GetProduct(InstrumentIdentifier);

            pOpenTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "DATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "PRODUCT", DbType.String), product);
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.VW_INSTR_PRODUCT ns on (ns.IDI = tr.IDI) and (ns.GPRODUCT in ('FX','OTC','SEC'))
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT in ('EXECUTED','INTERMED') and (ns.PRODUCT_IDENTIFIER = @PRODUCT) and
            (ec.DTEVENT <= @DATE) and (ev.DTENDADJ > @DATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenTradesList.Add(idt);
            }
        }


        /// <summary>
        /// Feed list contains open and closed trades at the treatment date
        /// </summary>
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList)
        {
            string product = GetProduct(InstrumentIdentifier);

            pOpenAndClosedTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "OPENANDCLOSEDBEGINDATE", DbType.Date), OpenAndClosedBeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "DATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "PRODUCT", DbType.String), product);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.VW_INSTR_PRODUCT ns on (ns.IDI = tr.IDI) and (ns.GPRODUCT in ('FX','OTC','SEC'))
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT in ('EXECUTED','INTERMED') and (ns.PRODUCT_IDENTIFIER = @PRODUCT) and 
            (ec.DTEVENT >= @OPENANDCLOSEDBEGINDATE) and (ev.DTENDADJ <= @DATE)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenAndClosedTradesList.Add(idt);
            }
        }

    }

    /// <summary>
    /// Build a FxSimpleOption report 
    /// </summary>
    public class RRBuilderFxSimpleOption : RRBuilder
    {
        public RRBuilderFxSimpleOption(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
            :
            base(pCs, pBeginDate, pEndDate, pOpen, pOpenAndClosed, pOpenAndClosedBeginDate, pPrimary, pDerivate, pDerivativeBeginDate, pInstrumentIdentifier, pRepositoryStyle, pRegulatorySubSystem, pTradesList, pIdRReport, pProcess, pDataLayout, pUserId, pProcessId, pReportType, pIdt)
        { }

        /// <summary>
        /// 
        /// </summary>
        public override void BuildReport()
        {
            Report = new RegulatoryReport();
            Business = new RRBusinessFxSimpleOption(Cs, DomesticCurrency, Process, Report, BeginDate, EndDate, OpenAndClosedBeginDate, DerivativeBeginDate, InstrumentIdentifier, RepositoryStyle);
            Puma2 = new RRPuma2FxSimpleOption(DomesticCurrency, Report);
            Log = new RRLog(Report, ReportReport);
            Store = new RRStore(Cs, Report, IdRReport, UserId, ProcessId, ReportType);
        }

        /// <summary>
        /// Feed list contains open trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenTradesList(List<Int32> pOpenTradesList)
        {
            pOpenTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), EndDate);
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);
            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.EVW_FXOPTION_TRADE_LIFECYCLE evw on (evw.IDT = tr.IDT)
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (evw.TRANSACTION_DATE <= @ENDDATE) and (evw.EXPIRY_DATE > @ENDDATE) and
            (evw.GLOBAL_STATUS in ('OPEN', 'OPEN_KI') or (evw.GLOBAL_STATUS  in ('CANCELED','ABANDONED','CLOSED_KO','EXPIRED','EXERCISED') and evw.GLOBAL_STATUS_DATE > @ENDDATE)) and 
            (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenTradesList.Add(idt);
            }
        }

        /// <summary>
        /// Feed list contains open trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenAndClosedTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList)
        {
            pOpenAndClosedTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "OPENANDCLOSEDBEGINDATE", DbType.Date), OpenAndClosedBeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);
            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.EVW_FXOPTION_TRADE_LIFECYCLE evw on (evw.IDT = tr.IDT)
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (evw.GLOBAL_STATUS_DATE <= @ENDDATE) and (evw.TRANSACTION_DATE >= @OPENANDCLOSEDBEGINDATE) and
            (evw.GLOBAL_STATUS  in ('CANCELED','ABANDONED','CLOSED_KO','EXPIRED','EXERCISED')) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenAndClosedTradesList.Add(idt);
            }
        }
    }

    /// <summary>
    /// Build a FxBarrierOption report 
    /// </summary>
    public class RRBuilderFxBarrierOption : RRBuilder
    {
        public RRBuilderFxBarrierOption(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
            :
            base(pCs, pBeginDate, pEndDate, pOpen, pOpenAndClosed, pOpenAndClosedBeginDate, pPrimary, pDerivate, pDerivativeBeginDate, pInstrumentIdentifier, pRepositoryStyle, pRegulatorySubSystem, pTradesList, pIdRReport, pProcess, pDataLayout, pUserId, pProcessId, pReportType, pIdt)
        { }

        /// <summary>
        /// 
        /// </summary>
        public override void BuildReport()
        {
            Report = new RegulatoryReport();
            Business = new RRBusinessFxBarrierOption(Cs, DomesticCurrency, Process, Report, BeginDate, EndDate, OpenAndClosedBeginDate, DerivativeBeginDate, InstrumentIdentifier, RepositoryStyle);
            Puma2 = new RRPuma2FxBarrierOption(DomesticCurrency, Report);
            Log = new RRLog(Report, ReportReport);
            Store = new RRStore(Cs, Report, IdRReport, UserId, ProcessId, ReportType);
        }

        /// <summary>
        /// Feed list contains the open trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenTradesList(List<Int32> pOpenTradesList)
        {
            pOpenTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), EndDate);
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT <= @ENDDATE) and (ev.DTENDADJ >= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenTradesList.Add(idt);
            }
        }

        /// <summary>
        /// Feed list contains the open and closed trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenAndClosedTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList)
        {
            pOpenAndClosedTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "OPENANDCLOSEDBEGINDATE", DbType.Date), OpenAndClosedBeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT >= @OPENANDCLOSEDBEGINDATE) and (ev.DTENDADJ <= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenAndClosedTradesList.Add(idt);
            }
        }
    }

    /// <summary>
    /// Build a FxDigitalOption report 
    /// </summary>
    public class RRBuilderFxDigitalOption : RRBuilder
    {
        public RRBuilderFxDigitalOption(string pCs, DateTime pBeginDate, DateTime pEndDate, bool pOpen, bool pOpenAndClosed, DateTime pOpenAndClosedBeginDate, bool pPrimary, bool pDerivate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pRepositoryStyle, string pRegulatorySubSystem, string pTradesList, string pIdRReport, ProcessBase pProcess, RRDataLayout pDataLayout, int pUserId, string pProcessId, string pReportType, Int32 pIdt)
            :
            base(pCs, pBeginDate, pEndDate, pOpen, pOpenAndClosed, pOpenAndClosedBeginDate, pPrimary, pDerivate, pDerivativeBeginDate, pInstrumentIdentifier, pRepositoryStyle, pRegulatorySubSystem, pTradesList, pIdRReport, pProcess, pDataLayout, pUserId, pProcessId, pReportType, pIdt)
        { }

        /// <summary>
        /// 
        /// </summary>
        public override void BuildReport()
        {
            Report = new RegulatoryReport();
            Business = new RRBusinessFxDigitalOption(Cs, DomesticCurrency, Process, Report, BeginDate, EndDate, OpenAndClosedBeginDate, DerivativeBeginDate, InstrumentIdentifier, RepositoryStyle);
            Puma2 = new RRPuma2FxDigitalOption(DomesticCurrency, Report);
            Log = new RRLog(Report, ReportReport);
            Store = new RRStore(Cs, Report, IdRReport, UserId, ProcessId, ReportType);
        }

        /// <summary>
        /// Feed list contains the open trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenTradesList(List<Int32> pOpenTradesList)
        {
            pOpenTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.DateTime), BeginDate);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), EndDate);
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);

            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT <= @ENDDATE) and (ev.DTENDADJ >= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenTradesList.Add(idt);
            }
        }

        /// <summary>
        /// Feed list contains the open and closed trades at the treatment date
        /// REMARK: multientity environment is not handled!!!!!
        /// to do: add filter relative to specific accounting entity
        /// </summary>
        /// <param name="pOpenAndClosedTradesList"></param>
        // EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        public override void SelectOpenAndClosedTradesList(List<Int32> pOpenAndClosedTradesList)
        {
            pOpenAndClosedTradesList.Clear();
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "OPENANDCLOSEDBEGINDATE", DbType.Date), OpenAndClosedBeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "INSTRUMENTIDENTIFIER", DbType.String), InstrumentIdentifier);
            string sqlSelect = @"select tr.IDT
            from dbo.TRADE tr
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            where (tr.IDSTENVIRONMENT = 'REGULAR') and (tr.IDSTACTIVATION  = 'REGULAR') and (tr.IDSTBUSINESS != 'PRETRADE') and
            (ec.DTEVENT >= @OPENANDCLOSEDBEGINDATE) and (ev.DTENDADJ <= @ENDDATE) and (ns.IDENTIFIER = @INSTRUMENTIDENTIFIER)";
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            foreach (DataRow row in rows)
            {
                Int32 idt = Convert.ToInt32(row["IDT"]);
                if (!IsRemovedTrade(idt, EndDate))
                    pOpenAndClosedTradesList.Add(idt);
            }
        }
    }

    /// <summary>
    ///  Feed report business section
    /// </summary>
    public class RRBusiness
    {
        #region Members
        private string m_Cs;
        private DateTime m_BeginDate;
        private DateTime m_EndDate;
        private DateTime m_OpenAndClosedBeginDate;
        private DateTime m_DerivativeBeginDate;
        private string m_InstrumentIdentifier;
        private string m_RepositoryStyle;
        private RegulatoryReport m_Report;
        private ProcessBase m_Process;
        private string m_WarningMessage;
        private string m_DomesticCurrency;
        #endregion
        #region Accessors
        public string Cs
        {
            get { return this.m_Cs; }
            set { this.m_Cs = value; }
        }
        public DateTime BeginDate
        {
            get { return this.m_BeginDate; }
            set { this.m_BeginDate = value; }
        }
        public DateTime EndDate
        {
            get { return this.m_EndDate; }
            set { this.m_EndDate = value; }
        }
        public DateTime OpenAndClosedBeginDate
        {
            get { return this.m_OpenAndClosedBeginDate; }
            set { this.m_OpenAndClosedBeginDate = value; }
        }
        public DateTime DerivativeBeginDate
        {
            get { return this.m_DerivativeBeginDate; }
            set { this.m_DerivativeBeginDate = value; }
        }
        public string InstrumentIdentifier
        {
            get { return this.m_InstrumentIdentifier; }
            set { this.m_InstrumentIdentifier = value; }
        }
        public string RepositoryStyle
        {
            get { return this.m_RepositoryStyle; }
            set { this.m_RepositoryStyle = value; }
        }
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public ProcessBase Process
        {
            get { return this.m_Process; }
            set { this.m_Process = value; }
        }
        public string WarningMessage
        {
            get { return this.m_WarningMessage; }
            set { this.m_WarningMessage = value; }
        }
        public string DomesticCurrency
        {
            get { return this.m_DomesticCurrency; }
            set { this.m_DomesticCurrency = value; }
        }
        #endregion
        #region constructor
        public RRBusiness(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
        {
            Cs = pCs;
            m_DomesticCurrency = pDomesticCurrency;
            BeginDate = pBeginDate;
            EndDate = pEndDate;
            OpenAndClosedBeginDate = pOpenAndClosedBeginDate;
            DerivativeBeginDate = pDerivativeBeginDate;
            RepositoryStyle = pActorRepositoryStyle;
            InstrumentIdentifier = pInstrumentIdentifier;
            Report = pReport;
            Process = pProcess;
            WarningMessage = null;
        }
        #endregion constructor

        virtual protected void LinearDepreciationClosingDate(Int32 pIdt) { }
        virtual protected void LinearDepreciationReceived(Int32 pIdt) { }
        virtual protected void LinearDepreciationPaid(Int32 pIdt) { }
        virtual protected void BondUnderlyingQuotation(Int32 pIdt) { }
        virtual protected void LinearDepreciationNetted() { }
        virtual protected void LinearDepreciationRemaining() { }
        virtual protected void IntrinsicValue() { }
        virtual public void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle) { }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <param name="pDerivativeBeginDate"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void ExchangedCleanCashFlows(Int32 pIdt, string pTradeIdentifier, DateTime pDerivativeBeginDate, string pProductIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.DateTime), pDerivativeBeginDate);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.IDE as IDE, e.EVENTTYPE as EVENTTYPE, ec.DTEVENT as SETTLEMENT_DATE, e.IDA_PAY as IDAPAY," + Cst.CrLf;
            sqlSelect += "e.IDA_REC as IDAREC, e.UNIT as CASHFLOW_IDC, el.VALUE as CASHFLOW_UIC, e.VALORISATION as CASHFLOW_VALORIZATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + " e.IDT = t.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + " ec.IDE = e.IDE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " el " + SQLCst.ON + "(el.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ec.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
            // 
            if (pProductIdentifier == "swap" || pProductIdentifier == "capFloor")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE in ('INT', 'UPF', 'CSH','PRM')" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            // Prime
            if (pProductIdentifier == "bondOption" || pProductIdentifier == "fxSimpleOption")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            if (pProductIdentifier == "fxBarrierOption")
            {
                sqlSelect += SQLCst.AND + " (e.EVENTTYPE in ('CCU', 'PCU', 'SCU') " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'REC')) " + Cst.CrLf;
            }
            // (payout)
            if (pProductIdentifier == "fxDigitalOption")
            {
                sqlSelect += SQLCst.AND + " ( e.EVENTTYPE = 'PAO' " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS in ('REC', 'STL')) " + Cst.CrLf;
            }
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.ORDERBY + "ec.DTEVENT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();

            if (rows.Length != 0)
            {
                Report.trade.dataDocument.business.InstantiateExchangedCashFlows();
                Report.trade.dataDocument.business.exchangedCashFlows.cleanCashFlows = new RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsCleanCashFlow[rows.Length];
                int i = 0;
                foreach (DataRow row in rows)
                {
                    RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsCleanCashFlow clean = new RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsCleanCashFlow
                    {
                        eventId = Convert.ToUInt64(row["IDE"]),
                        eventType = Convert.ToString(row["EVENTTYPE"]),
                        settlementDate = Convert.ToDateTime(row["SETTLEMENT_DATE"]),
                        idaPay = Convert.ToUInt16(row["IDAPAY"]),
                        idaRec = Convert.ToUInt16(row["IDAREC"]),
                        idc = Convert.ToString(row["CASHFLOW_IDC"]),
                        uicCurrencyCode = Convert.ToString(row["CASHFLOW_UIC"]),
                        amount = Convert.ToDecimal(row["CASHFLOW_VALORIZATION"])
                    };
                    if (clean.idc != DomesticCurrency)
                    {
                        string pIdc = clean.idc;
                        decimal pIdcAmount = clean.amount;
                        DateTime pFixingDate = Report.trade.header.endDate;
                        CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);

                        if (info != null)
                        {
                            clean.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsCleanCashFlowCounterValueAmount
                            {
                                idc1 = info.Idc1,
                                idc2 = info.Idc2,
                                quoteBasis = info.QuoteBasis,
                                fixingDate = info.FixingDate,
                                value = info.CounterValue,
                                fxAsset = GetFxAssetIdentifier(info.IdAsset),
                                fxQuotation = info.Quotation
                            };
                        }
                        else
                        {
                            WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";
                            // FI 20200623 [XXXXX] SetErrorWarning
                            Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                            
                            Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                        }
                    }
                    clean.id = Convert.ToString("cleanCashFlows") + Convert.ToString(i);
                    Report.trade.dataDocument.business.exchangedCashFlows.cleanCashFlows[i] = clean;
                    i++;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <param name="pDerivativeBeginDate"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void ExchangedGrossCashFlows(Int32 pIdt, string pTradeIdentifier, DateTime pDerivativeBeginDate, string pProductIdentifier)
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.Date), pDerivativeBeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);// FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ec.DTEVENT as SETTLEMENT_DATE, " + Cst.CrLf;
            sqlSelect += " e.UNIT as CASHFLOW_IDC, el.VALUE as CASHFLOW_UIC," + Cst.CrLf;
            sqlSelect += "sum ( case when e.IDA_PAY = @MAINACTORIDA then e.VALORISATION * (-1) " + Cst.CrLf;
            sqlSelect += "when e.IDA_REC = @MAINACTORIDA then (e.VALORISATION) end) as NETTED_CASHFLOW_VALORIZATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + " e.IDT = t.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + " ec.IDE = e.IDE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " el " + SQLCst.ON + "(el.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ec.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
            // 
            if (pProductIdentifier == "swap" || pProductIdentifier == "capFloor")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE in ('INT', 'UPF', 'CSH','PRM')" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            // Prime
            if (pProductIdentifier == "bondOption" || pProductIdentifier == "fxSimpleOption")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            if (pProductIdentifier == "fxBarrierOption")
            {
                sqlSelect += SQLCst.AND + " (e.EVENTTYPE in ('CCU', 'PCU', 'SCU') " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'REC')) " + Cst.CrLf;
            }
            // (payout)
            if (pProductIdentifier == "fxDigitalOption")
            {
                sqlSelect += SQLCst.AND + " ( e.EVENTTYPE = 'PAO' " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS in ('REC', 'STL')) " + Cst.CrLf;
            }
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.GROUPBY + " ec.DTEVENT,e.UNIT, el.VALUE " + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();

            if (rows.Length != 0)
            {
                Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows = new RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsGrossCashFlow[rows.Length];
                int i = 0;
                foreach (DataRow row in rows)
                {
                    RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsGrossCashFlow gross = new RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsGrossCashFlow
                    {
                        settlementDate = Convert.ToDateTime(row["SETTLEMENT_DATE"]),
                        idc = Convert.ToString(row["CASHFLOW_IDC"]),
                        uicCurrencyCode = Convert.ToString(row["CASHFLOW_UIC"]),
                        id = Convert.ToString("grossCashFlows") + Convert.ToString(i)
                    };

                    if (false == Convert.IsDBNull(row["NETTED_CASHFLOW_VALORIZATION"]))
                    {
                        gross.amount = Convert.ToDecimal(row["NETTED_CASHFLOW_VALORIZATION"]);
                        if (Convert.ToDecimal(row["NETTED_CASHFLOW_VALORIZATION"]) > 0)
                        {
                            gross.idaPay = Report.trade.dataDocument.repository.counterparty.ida;
                            gross.idaRec = Report.trade.dataDocument.repository.mainActor.ida;
                        }
                        if (Convert.ToDecimal(row["NETTED_CASHFLOW_VALORIZATION"]) < 0)
                        {
                            gross.idaPay = Report.trade.dataDocument.repository.mainActor.ida;
                            gross.idaRec = Report.trade.dataDocument.repository.counterparty.ida;
                        }

                        if (gross.idc != DomesticCurrency)
                        {
                            string pIdc = gross.idc;
                            decimal pIdcAmount = gross.amount;
                            DateTime pFixingDate = Report.trade.header.endDate;
                            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                            //
                            if (info != null)
                            {
                                gross.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessExchangedCashFlowsGrossCashFlowCounterValueAmount
                                {
                                    idc1 = info.Idc1,
                                    idc2 = info.Idc2,
                                    quoteBasis = info.QuoteBasis,
                                    fixingDate = info.FixingDate,
                                    value = info.CounterValue,
                                    fxAsset = GetFxAssetIdentifier(info.IdAsset),
                                    fxQuotation = info.Quotation
                                };
                            }
                            else
                            {
                                // FI 20200623 [XXXXX] SetErrorWarning
                                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                                
                                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                                
                                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                            }
                        }
                    }
                    Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[i] = gross;
                    i++;
                }
            }
        }

        /// <summary>
        /// forward clean cash flow
        /// add 1 row for each settlement date
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void ForwardCleanCashFlows(Int32 pIdt, string pTradeIdentifier, string pProductIdentifier)
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.IDE as IDE, e.EVENTTYPE as EVENTTYPE, ec.DTEVENT as SETTLEMENT_DATE, e.IDA_PAY as IDAPAY," + Cst.CrLf;
            sqlSelect += "e.IDA_REC as IDAREC, e.UNIT as CASHFLOW_IDC, el.VALUE as CASHFLOW_UIC, e.VALORISATION as CASHFLOW_VALORIZATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + " e.IDT = t.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + " ec.IDE = e.IDE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " el " + SQLCst.ON + "(el.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ec.DTEVENT > @ENDDATE" + Cst.CrLf;
            // 
            if (pProductIdentifier == "swap" || pProductIdentifier == "capFloor")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE in ('INT', 'UPF', 'CSH','PRM')" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            // Prime
            if (pProductIdentifier == "bondOption" || pProductIdentifier == "fxSimpleOption")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            if (pProductIdentifier == "fxBarrierOption")
            {
                sqlSelect += SQLCst.AND + " (e.EVENTTYPE in ('CCU', 'PCU', 'SCU') " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'REC')) " + Cst.CrLf;
            }
            // (payout)
            if (pProductIdentifier == "fxDigitalOption")
            {
                sqlSelect += SQLCst.AND + " ( e.EVENTTYPE = 'PAO' " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS in ('REC', 'STL')) " + Cst.CrLf;
            }
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.ORDERBY + "ec.DTEVENT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();

            if (rows.Length != 0)
            {
                Report.trade.dataDocument.business.InstantiateForwardCashFlows();
                Report.trade.dataDocument.business.forwardCashFlows.cleanCashFlows = new RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsCleanCashFlow[rows.Length];
                int i = 0;
                foreach (DataRow row in rows)
                {
                    RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsCleanCashFlow clean = new RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsCleanCashFlow
                    {
                        eventId = Convert.ToUInt64(row["IDE"]),
                        eventType = Convert.ToString(row["EVENTTYPE"]),
                        settlementDate = Convert.ToDateTime(row["SETTLEMENT_DATE"]),
                        idaPay = Convert.ToUInt16(row["IDAPAY"]),
                        idaRec = Convert.ToUInt16(row["IDAREC"]),
                        idc = Convert.ToString(row["CASHFLOW_IDC"]),
                        uicCurrencyCode = Convert.ToString(row["CASHFLOW_UIC"])
                    };

                    if (false == Convert.IsDBNull(row["CASHFLOW_VALORIZATION"]))
                        clean.amount = Convert.ToDecimal(row["CASHFLOW_VALORIZATION"]);

                    if (clean.idc != DomesticCurrency)
                    {
                        string pIdc = clean.idc;
                        decimal pIdcAmount = clean.amount;
                        DateTime pFixingDate = Report.trade.header.endDate;
                        CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);

                        if (info != null)
                        {
                            clean.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsCleanCashFlowCounterValueAmount
                            {
                                idc1 = info.Idc1,
                                idc2 = info.Idc2,
                                quoteBasis = info.QuoteBasis,
                                fixingDate = info.FixingDate,
                                value = info.CounterValue,
                                fxAsset = GetFxAssetIdentifier(info.IdAsset),
                                fxQuotation = info.Quotation
                            };
                        }
                        else
                        {
                            // FI 20200623 [XXXXX] SetErrorWarning
                            Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                            WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                            
                            Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                        }
                    }
                    clean.id = Convert.ToString("cleanCashFlows") + Convert.ToString(i);
                    Report.trade.dataDocument.business.forwardCashFlows.cleanCashFlows[i] = clean;
                    i++;
                }
            }
        }

        /// <summary>
        /// cash flow resultant is the differential of each cash flow
        /// add 1 row for each cash flow happend in the same settlement date
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void ForwardGrossCashFlows(Int32 pIdt, string pTradeIdentifier, string pProductIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ec.DTEVENT as SETTLEMENT_DATE, " + Cst.CrLf;
            sqlSelect += " e.UNIT as CASHFLOW_IDC, el.VALUE as CASHFLOW_UIC," + Cst.CrLf;
            sqlSelect += "sum ( case when e.IDA_PAY = @MAINACTORIDA then e.VALORISATION * (-1) " + Cst.CrLf;
            sqlSelect += "when e.IDA_REC = @MAINACTORIDA then (e.VALORISATION) end) as NETTED_CASHFLOW_VALORIZATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + " e.IDT = t.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + " ec.IDE = e.IDE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " el " + SQLCst.ON + "(el.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (el.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ec.DTEVENT > @ENDDATE" + Cst.CrLf;
            // 
            if (pProductIdentifier == "swap" || pProductIdentifier == "capFloor")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE in ('INT', 'UPF', 'CSH','PRM')" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            // Prime
            if (pProductIdentifier == "bondOption" || pProductIdentifier == "fxSimpleOption")
            {
                sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'STL' " + Cst.CrLf;
            }
            if (pProductIdentifier == "fxBarrierOption")
            {
                sqlSelect += SQLCst.AND + " (e.EVENTTYPE in ('CCU', 'PCU', 'SCU') " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'REC')) " + Cst.CrLf;
            }
            // (payout)
            if (pProductIdentifier == "fxDigitalOption")
            {
                sqlSelect += SQLCst.AND + " ( e.EVENTTYPE = 'PAO' " + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ec.EVENTCLASS in ('REC', 'STL')) " + Cst.CrLf;
            }
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.GROUPBY + " ec.DTEVENT, e.UNIT, el.VALUE " + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            if (rows.Length != 0)
            {
                Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows = new RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsGrossCashFlow[rows.Length];
                int i = 0;
                foreach (DataRow row in rows)
                {
                    RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsGrossCashFlow gross = new RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsGrossCashFlow
                    {
                        settlementDate = Convert.ToDateTime(row["SETTLEMENT_DATE"]),
                        idc = Convert.ToString(row["CASHFLOW_IDC"]),
                        uicCurrencyCode = Convert.ToString(row["CASHFLOW_UIC"])
                    };
                    if (false == Convert.IsDBNull(row["NETTED_CASHFLOW_VALORIZATION"]))
                    {
                        gross.amount = Convert.ToDecimal(row["NETTED_CASHFLOW_VALORIZATION"]);
                        if (Convert.ToDecimal(row["NETTED_CASHFLOW_VALORIZATION"]) > 0)
                        {
                            gross.idaPay = Report.trade.dataDocument.repository.counterparty.ida;
                            gross.idaRec = Report.trade.dataDocument.repository.mainActor.ida;
                        }
                        if (Convert.ToDecimal(row["NETTED_CASHFLOW_VALORIZATION"]) < 0)
                        {
                            gross.idaPay = Report.trade.dataDocument.repository.mainActor.ida;
                            gross.idaRec = Report.trade.dataDocument.repository.counterparty.ida;
                        }

                        if (gross.idc != DomesticCurrency)
                        {
                            string pIdc = gross.idc;
                            decimal pIdcAmount = gross.amount;
                            DateTime pFixingDate = Report.trade.header.endDate;
                            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);

                            if (info != null)
                            {
                                gross.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessForwardCashFlowsGrossCashFlowCounterValueAmount
                                {
                                    idc1 = info.Idc1,
                                    idc2 = info.Idc2,
                                    quoteBasis = info.QuoteBasis,
                                    fixingDate = info.FixingDate,
                                    value = info.CounterValue,
                                    fxAsset = GetFxAssetIdentifier(info.IdAsset),
                                    fxQuotation = info.Quotation
                                };                                //
                            }
                            else
                            {
                                // FI 20200623 [XXXXX] SetErrorWarning
                                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                                
                                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                                
                                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                            }
                        }
                    }
                    gross.id = Convert.ToString("grossCashFlows") + Convert.ToString(i);
                    Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[i] = gross;
                    i++;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public class CounterValueInfo
        {
            #region Members
            protected string m_Idc1;
            protected string m_Idc2;
            protected string m_QuoteBasis;
            protected DateTime m_FixingDate;
            protected int m_IdAsset;
            protected decimal m_Quotation;
            protected decimal m_CounterValue;
            #endregion
            #region Accessors

            public string Idc1
            {
                get { return this.m_Idc1; }
                set { this.m_Idc1 = value; }
            }
            public string Idc2
            {
                get { return this.m_Idc2; }
                set { this.m_Idc2 = value; }
            }
            public string QuoteBasis
            {
                get { return this.m_QuoteBasis; }
                set { this.m_QuoteBasis = value; }
            }
            public DateTime FixingDate
            {
                get { return this.m_FixingDate; }
                set { this.m_FixingDate = value; }
            }
            public int IdAsset
            {
                get { return this.m_IdAsset; }
                set { this.m_IdAsset = value; }
            }
            public decimal Quotation
            {
                get { return this.m_Quotation; }
                set { this.m_Quotation = value; }
            }
            public decimal CounterValue
            {
                get { return this.m_CounterValue; }
                set { this.m_CounterValue = value; }
            }
            #endregion
            #region constructor
            public CounterValueInfo(string pIdc1, string pIdc2, FpML.Enum.QuoteBasisEnum pQuoteBasis, DateTime pFixingDate, int pIdAsset, decimal pQuotation, decimal pCounterValue)
            {
                m_Idc1 = pIdc1;
                m_Idc2 = pIdc2;
                m_QuoteBasis = Convert.ToString(pQuoteBasis);
                m_FixingDate = pFixingDate;
                m_IdAsset = pIdAsset;
                m_Quotation = pQuotation;
                m_CounterValue = pCounterValue;
            }
            #endregion
        }

        /// <summary>
        /// returns total number of days in a year
        /// </summary>
        /// <param name="pYear"></param>
        /// <returns></returns>
        protected int GetDaysInYear(int pYear)
        {

            int days = 0;
            for (int i = 1; i <= 12; i++)
            {
                days += DateTime.DaysInMonth(pYear, i);
            }
            return days;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <param name="pFixingDate"></param>
        /// <param name="pIdC"></param>
        /// <param name="pIdcAmount"></param>
        /// <param name="pIdMarketEnv"></param>
        /// <returns>exchangeAmount: EUR countervalue of pIdcAmount</returns>
        // EG 20180205 [23769] Upd EFS_TradeLibray constructor call  (substitution to the static class EFS_CURRENT)  
        protected CounterValueInfo ReadQuote_FXRate(int pIdT, string pTradeIdentifier, DateTime pFixingDate, string pIdc1, decimal pAmount)
        {
            string idc1 = pIdc1;
            string idc2 = DomesticCurrency;
            KeyQuote keyQuote = new KeyQuote(Cs, pFixingDate)
            {
                QuoteTiming = QuoteTimingEnum.Close
            };

            KeyAssetFxRate keyAsset = new KeyAssetFxRate
            {
                IdC1 = idc1,
                IdC2 = idc2
            };
            keyAsset.SetQuoteBasis(true);

            EFS_TradeLibrary tradeLibrary = new EFS_TradeLibrary(Cs, null, pIdT);
            IProductBase productBase = tradeLibrary.Product.ProductBase;

            SQL_Quote quote = new SQL_Quote(Cs, QuoteEnum.FXRATE, AvailabilityEnum.Enabled, productBase, keyQuote, keyAsset);
            if (!quote.IsLoaded)
                _ = quote.QuoteValueMessage;

            Cst.ErrLevel codeReturn = quote.QuoteValueCodeReturn;

            if (LevelStatusTools.IsCodeReturnSuccess(codeReturn))
            {
                decimal amount = pAmount;
                decimal exchangeRate = quote.QuoteValue;
                FpML.Enum.QuoteBasisEnum quoteBasis = keyAsset.QuoteBasis;
                //
                EFS_Cash cash = new EFS_Cash(Cs, idc1, idc2, amount, exchangeRate, quoteBasis);
                decimal exchangeAmount = cash.ExchangeAmountRounded;
                CounterValueInfo counterValueInfo = new CounterValueInfo(idc1, idc2, quoteBasis, pFixingDate, quote.IdAsset, exchangeRate, exchangeAmount);
                return counterValueInfo;
            }
            return null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pAssetId"></param>
        /// <returns></returns>
        protected string GetFxAssetIdentifier(Int32 pAssetId)
        {
            string fxAssetIdentifier = string.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDASSET", DbType.Int32), pAssetId);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " a.IDENTIFIER as IDENTIFIER" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.ASSET_FXRATE.ToString() + " a " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "a.IDASSET = @IDASSET" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["IDENTIFIER"]))
                        fxAssetIdentifier = Convert.ToString(dr["IDENTIFIER"]);
                }
            }
            return fxAssetIdentifier;
        }

        /// <summary>
        /// Feed the report trade.header section  
        /// (eg. product family, trade identifier, trade date, etc)
        /// </summary>
        /// <param name="pIdt"></param> 
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        protected void MainBusinessInfo(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.Date), BeginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            //
            string sqlSelect = String.Format(@"select pr.FAMILY as PRODUCTFAMILY, tr.IDENTIFIER as TRADEIDENTIFIER,
            tr.IDT_TEMPLATE as IDTTEMPLATE, trx.EFSMLVERSION as EFSMLVERSION, pr.IDENTIFIER as PRODUCTIDENTIFIER, ns.IDENTIFIER as INSTRUMENTIDENTIFIER,
            tr.DTTRADE as TRADEDATE, ev.DTENDADJ as TERMINATIONDATE, {0} as DTTIMESTAMP, ext.VALUE as FAIRVALUEHIERARCHY
            from dbo.TRADE tr
            inner join dbo.TRADEXML trx on (trx.IDT = tr.IDT)
            inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
            inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
            inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'TRD') and (ev.EVENTTYPE = 'DAT')
            inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS = 'GRP')
            left outer join dbo.EXTLID ext on (ext.ID = ns.IDI) and (ext.TABLENAME = 'INSTRUMENT') and (ext.IDENTIFIER = 'FAIRVALUEHIERARCHY')
            where (tr.IDT = @IDT)", DataHelper.SQLGetDate(Cs)) + Cst.CrLf;

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            Report.trade.header.idt = Convert.ToUInt16(pIdt);
            Report.trade.header.productFamily = Convert.ToString(row["PRODUCTFAMILY"]);
            Report.trade.header.identifier = Convert.ToString(row["TRADEIDENTIFIER"]);
            if (false == Convert.IsDBNull(row["IDTTEMPLATE"]))
                Report.trade.header.idtTemplate = Convert.ToUInt16(row["IDTTEMPLATE"]);
            Report.trade.header.eFSMLVersion = Convert.ToString(row["EFSMLVERSION"]);
            Report.trade.header.productIdentifier = Convert.ToString(row["PRODUCTIDENTIFIER"]);
            Report.trade.header.instrumentIdentifier = Convert.ToString(row["INSTRUMENTIDENTIFIER"]);
            Report.trade.header.sysDate = Convert.ToDateTime(row["DTTIMESTAMP"]);
            Report.trade.header.fairValueHierarchy = Convert.ToString(row["FAIRVALUEHIERARCHY"]);
            Report.trade.header.tradeDate = Convert.ToDateTime(row["TRADEDATE"]);
            Report.trade.header.terminationDate = Convert.ToDateTime(row["TERMINATIONDATE"]);
            Report.trade.header.beginDate = BeginDate;
            Report.trade.header.endDate = EndDate;
        }

        /// <summary>
        /// Feed the report trade.dataDocument.repository section  
        /// </summary>
        /// <param name="pIdt"></param> 
        protected void Repository(Int32 pIdt)
        {
            _ = Report.trade.header.instrumentIdentifier;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "b.IDENTIFIER as MAIN_ACTOR_BOOK_IDENTIFIER, b.EXTLLINK as MAIN_ACTOR_BOOK_EXTLLINK, ta.IDA as MAIN_ACTOR_IDA," + Cst.CrLf;
            sqlSelect += "a.IDENTIFIER as MAIN_ACTOR_IDENTIFIER, b.IDA_ENTITY as MAIN_ACTOR_BOOK_ENTITY_IDA, b.IDB as MAIN_ACTOR_BOOK_IDB, ta.BUYER_SELLER as MAIN_ACTOR_BUYER_SELLER," + Cst.CrLf;
            sqlSelect += "ta.LOCALCLASSDERV as MAIN_ACTOR_TRADE_LOCALCLASS, eNumLcs.EXTVALUE as MAIN_ACTOR_LOCALCLASS_EXTVALUE, ta.IASCLASSDERV as IAS_CATEGORY, taCtr.BUYER_SELLER as COUNTERPARTY_BUYER_SELLER, " + Cst.CrLf;
            sqlSelect += "aCtr.RESIDENCECODE as COUNTERPARTY_RESIDENCECODE, aCtr.IDCOUNTRYRESIDENCE as COUNTERPARTY_IDCOUNTRYRESID, aCtr.EXTLLINK as COUNTERPARTY_EXTLLINK," + Cst.CrLf;
            sqlSelect += "taCtr.IDA as COUNTERPARTY_IDA, aCtr.IDENTIFIER as COUNTERPARTY_IDENTIFIER, taCtr.IDB as COUNTERPARTY_BOOK_IDB, tid.TRADEID as FRONT_TRADEID," + Cst.CrLf;
            sqlSelect += "case when arCtr.IDROLEACTOR is not null then 1 else 0 end  as IS_COUNTERPARTY_CLIENT, lid.LINKID as LINKID" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t" + Cst.CrLf;
            // GS 20130521 [ticket 17909] improved role to detect the main actor book 
            // a book is managed when an accounting entity is assigned and a IAS/IFRS accounting category is available
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADEACTOR + " ta " + SQLCst.ON + "(ta.IDT = t.IDT)" + SQLCst.AND + " ta.IDROLEACTOR = 'COUNTERPARTY' " + SQLCst.AND + " ta.IASCLASSDERV is not null " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ACTOR + " a " + SQLCst.ON + "(ta.IDA = a.IDA)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.BOOK + " b " + SQLCst.ON + "(b.IDB = ta.IDB )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "b.IDA_ENTITY is not null" + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.ACTORROLE + " ar " + SQLCst.ON + "(ta.IDA = ar.IDA)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (ar.IDROLEACTOR) = 'CLIENT'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ENUM + " eNumLcs " + SQLCst.ON + "(eNumLcs.VALUE = ta.LOCALCLASSDERV)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (eNumLcs.CODE) = 'LOCALCLASSDERV'" + Cst.CrLf;
            // GS 20130521 [ticket 17909] improved role to detect the counterparty book 
            // a book is managed when an accounting entity is assigned and a IAS/IFRS accounting category is available
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADEACTOR + " taCtr " + SQLCst.ON + "(taCtr.IDT = t.IDT)" + SQLCst.AND + " taCtr.IDROLEACTOR = 'COUNTERPARTY' " + SQLCst.AND + " taCtr.IASCLASSDERV is null " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ACTOR + " aCtr " + SQLCst.ON + "(aCtr.IDA = taCtr.IDA)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "aCtr.IDA <> a.IDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (taCtr.BUYER_SELLER) in ('BUYER', 'SELLER')" + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.ACTORROLE + " arCtr " + SQLCst.ON + "(taCtr.IDA = arCtr.IDA)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (arCtr.IDROLEACTOR) = 'CLIENT'" + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.TRADEID + " tid " + SQLCst.ON + "tid.IDT = t.IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "tid.TRADEIDSCHEME = 'http://www.euro-finance-systems.fr/otcml/frontid'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "tid.IDA = ta.IDA" + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.LINKID + " lid " + SQLCst.ON + "lid.IDT   = t.IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "lid.LINKIDSCHEME = 'http://www.euro-finance-systems.fr/otcml/folderid'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "lid.IDA = ta.IDA" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ar.IDROLEACTOR is null" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            //
            Report.trade.dataDocument.repository.mainActor.ida = Convert.ToUInt16(row["MAIN_ACTOR_IDA"]);
            Report.trade.dataDocument.repository.mainActor.identifier = Convert.ToString(row["MAIN_ACTOR_IDENTIFIER"]);
            Report.trade.dataDocument.repository.mainActor.bookIdb = Convert.ToUInt16(row["MAIN_ACTOR_BOOK_IDB"]);
            Report.trade.dataDocument.repository.mainActor.bookIdentifier = Convert.ToString(row["MAIN_ACTOR_BOOK_IDENTIFIER"]);
            Report.trade.dataDocument.repository.mainActor.bookExtllink = Convert.ToString(row["MAIN_ACTOR_BOOK_EXTLLINK"]);
            Report.trade.dataDocument.repository.mainActor.bookEntityIda = Convert.ToUInt16(row["MAIN_ACTOR_BOOK_ENTITY_IDA"]);
            Report.trade.dataDocument.repository.mainActor.buyerSeller = Convert.ToString(row["MAIN_ACTOR_BUYER_SELLER"]);
            Report.trade.dataDocument.repository.mainActor.tradeLocalClass = Convert.ToString(row["MAIN_ACTOR_TRADE_LOCALCLASS"]);
            // Derivative or hedging
            Report.trade.dataDocument.repository.mainActor.iasCategory = Convert.ToString(row["IAS_CATEGORY"]);
            Report.trade.dataDocument.repository.mainActor.accountingLocalClass = Convert.ToString(row["MAIN_ACTOR_LOCALCLASS_EXTVALUE"]);
            Report.trade.dataDocument.repository.counterparty.ida = Convert.ToUInt16(row["COUNTERPARTY_IDA"]);
            Report.trade.dataDocument.repository.counterparty.identifier = Convert.ToString(row["COUNTERPARTY_IDENTIFIER"]);
            Report.trade.dataDocument.repository.counterparty.extllink = Convert.ToString(row["COUNTERPARTY_EXTLLINK"]);
            Report.trade.dataDocument.repository.counterparty.bookIdb = Convert.ToUInt16(row["COUNTERPARTY_BOOK_IDB"]);
            Report.trade.dataDocument.repository.counterparty.buyerSeller = Convert.ToString(row["COUNTERPARTY_BUYER_SELLER"]);
            Report.trade.dataDocument.repository.counterparty.residenceCode = Convert.ToString(row["COUNTERPARTY_RESIDENCECODE"]);
            Report.trade.dataDocument.repository.counterparty.idCountryResidence = Convert.ToString(row["COUNTERPARTY_IDCOUNTRYRESID"]);
            Report.trade.dataDocument.repository.counterparty.isClient = Convert.ToBoolean(row["IS_COUNTERPARTY_CLIENT"]);
            Report.trade.header.frontId = Convert.ToString(row["FRONT_TRADEID"]);
            //
            if ("RESIDENTE" == Convert.ToString(row["COUNTERPARTY_RESIDENCECODE"]))
                Report.trade.dataDocument.repository.counterparty.isCounterpartyResident = true;
            if ("NON RESIDENTE" == Convert.ToString(row["COUNTERPARTY_RESIDENCECODE"]))
                Report.trade.dataDocument.repository.counterparty.isCounterpartyResident = false;

            if (false == Convert.IsDBNull(row["LINKID"]))
            {
                Report.trade.header.isStructuredProduct = true;
                Report.trade.header.structuredIdentifier = Convert.ToString(row["LINKID"]);
            }
            else
            {
                Report.trade.header.isStructuredProduct = false;
                Report.trade.header.structuredIdentifier = String.Empty;
            }
        }

        /// <summary>
        /// Detect Master Agreement
        /// GS 20171121: ticket 23269 - Verifica su campi OTCml 0346 e 1495 [BANCAPERTA]
        /// </summary>
        // RD 20181127 suite  EG 20180426 Analyse du code Correction [CA2202]
        protected void AgreementExists(out bool agreementExists)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDA_1", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "IDA_2", DbType.Int32), Report.trade.dataDocument.repository.counterparty.ida);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), EndDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();

            sqlSelect += SQLCst.SELECT + "m.IDENTIFIER as IDENTIFIER" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.MASTERAGREEMENT.ToString() + " m " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "m.IDA_1 = @IDA_1" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "m.IDA_2 = @IDA_2" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "( m.DTDISABLED is null or m.DTDISABLED >= @ENDDATE)" + Cst.CrLf;
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                //
                if (dr.Read())
                {
                    agreementExists = true;
                }
                else
                {
                    agreementExists = false;
                }
            }
        }

        /// <summary>
        /// Feed Master Agreement section
        /// GS 20171121: ticket 23269 - Verifica su campi OTCml 0346 e 1495 [BANCAPERTA]
        /// </summary>
        protected void MasterAgreement()
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDA_1", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "IDA_2", DbType.Int32), Report.trade.dataDocument.repository.counterparty.ida);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), EndDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "m.IDMASTERAGREEMENT as IDMASTERAGREEMENT, m.IDENTIFIER as IDENTIFIER, m.DISPLAYNAME as DISPLAYNAME, m.IDA_1 as IDA_1, m.IDA_2 as IDA_2, m.DTSIGNATURE as DTSIGNATURE, m.AGREEMENTTYPE as AGREEMENTTYPE," + Cst.CrLf;
            // confirmation
            sqlSelect += "m.CONFIRMATIONTYPE as CONFIRMATIONTYPE, m.DTCONFIRMATION as DTCONFIRMATION, m.CONFIRMANNEXTYPE as CONFIRMANNEXTYPE, m.DTCONFIRMANNEX as DTCONFIRMANNEX, " + Cst.CrLf;
            // credit support agreement           
            sqlSelect += "m.CSAIDENTIFIER as CSAIDENTIFIER, m.CSATYPE as CSATYPE, m.DTCSA as DTCSA  " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.MASTERAGREEMENT.ToString() + " m " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "m.IDA_1 = @IDA_1" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "m.IDA_2 = @IDA_2" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "( m.DTDISABLED is null or m.DTDISABLED >= @ENDDATE)" + Cst.CrLf;

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            // Master Agreement
            Report.trade.dataDocument.repository.masterAgreement.id = Convert.ToUInt16(row["IDMASTERAGREEMENT"]);
            Report.trade.dataDocument.repository.masterAgreement.party1Ida = Convert.ToUInt16(row["IDA_1"]);
            Report.trade.dataDocument.repository.masterAgreement.party2Ida = Convert.ToUInt16(row["IDA_2"]);
            Report.trade.dataDocument.repository.masterAgreement.identifier = Convert.ToString(row["IDENTIFIER"]);
            Report.trade.dataDocument.repository.masterAgreement.displayname = Convert.ToString(row["DISPLAYNAME"]);
            Report.trade.dataDocument.repository.masterAgreement.signatureDate = Convert.ToDateTime(row["DTSIGNATURE"]);
            Report.trade.dataDocument.repository.masterAgreement.agreementType = Convert.ToString(row["AGREEMENTTYPE"]);
            // Confirmation
            if (false == Convert.IsDBNull(row["CONFIRMATIONTYPE"]))
            {
                Report.trade.dataDocument.repository.masterAgreement.confirmationType = Convert.ToString(row["CONFIRMATIONTYPE"]);
                Report.trade.dataDocument.repository.masterAgreement.confirmationDate = Convert.ToDateTime(row["DTCONFIRMATION"]);
            }
            if (false == Convert.IsDBNull(row["CONFIRMANNEXTYPE"]))
            {
                Report.trade.dataDocument.repository.masterAgreement.confirmationAnnexType = Convert.ToString(row["CONFIRMANNEXTYPE"]);
                Report.trade.dataDocument.repository.masterAgreement.confirmationAnnexDate = Convert.ToDateTime(row["DTCONFIRMANNEX"]);
            }
            // Credit Support Agreement
            if (false == Convert.IsDBNull(row["CSAIDENTIFIER"]))
            {
                Report.trade.dataDocument.repository.masterAgreement.creditSupportAgreementIdentifier = Convert.ToString(row["CSAIDENTIFIER"]);
                Report.trade.dataDocument.repository.masterAgreement.creditSupportAgreementType = Convert.ToString(row["CSATYPE"]);
                Report.trade.dataDocument.repository.masterAgreement.creditSupportAgreementDate = Convert.ToDateTime(row["DTCSA"]);
            }
        }


        /// <summary>
        /// The trade is out of the scope if the accounting categories is availables for each book
        /// GS 20130521 [ticket 17909] improved role to detect the main actor book 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void CheckAccountingCategories(Int32 pIdt)
        {
            int count = 0;
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + SQLCst.COUNT_ALL + SQLCst.AS + " COUNT " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADEACTOR + " ta " + SQLCst.ON + "(ta.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ta.IDROLEACTOR = 'COUNTERPARTY' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " upper (ta.BUYER_SELLER) in ('BUYER', 'SELLER') " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ta.IASCLASSDERV is not null " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["COUNT"]))
                        count = Convert.ToInt32((dr["COUNT"]));
                }
                if (count > 1)
                {
                    Report.trade.header.isInTheScope = false;

                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Trade scartato (out of the scope): Impossibile individuare il book gestito, entrambi i book hanno una categoria contabile IAS/IFRS assegnata.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }
        }

        /// <summary>
        /// Feed the report trade.dataDocument.repository.counterparty section with NDG (numero di direzione generale) 
        /// for each repository type
        /// in BIM repository the NDG is stored into actor identifier field (NdgInActorIdentifier case)
        /// in BA repository the NDG is stored into actor externallink field (NdgInActorExternalLink case)
        /// </summary>
        /// <param name="pActorRepositoryStyle"></param>
        /// <param name="pTradeIndentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void Ndg(string pActorRepositoryStyle, string pTradeIndentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "MAINACTORBOOKIDB", DbType.Int32), Report.trade.dataDocument.repository.mainActor.bookIdb);
            parameters.Add(new DataParameter(Cs, "COUNTERPARTYIDA", DbType.Int32), Report.trade.dataDocument.repository.counterparty.ida);
            parameters.Add(new DataParameter(Cs, "COUNTERPARTYBOOKIDB", DbType.Int32), Report.trade.dataDocument.repository.counterparty.bookIdb);
            //
            StrBuilder sqlSelect = new StrBuilder();

            switch (pActorRepositoryStyle)
            {
                case "NdgInActorIdentifier":
                    bool isCounterpartyClient = Convert.ToBoolean(Report.trade.dataDocument.repository.counterparty.isClient);
                    sqlSelect += SQLCst.SELECT + " a.IDENTIFIER as NDG,   " + Cst.CrLf;

                    // if counterparty is a client numero rapporto is substring of book identifier
                    // if counterparty isn't a client numero rapporto is substring of actor identifier
                    if (isCounterpartyClient == true)
                        sqlSelect += " substring(b.IDENTIFIER,9,8) as NUMERORAPPORTO" + Cst.CrLf;
                    else sqlSelect += "substring(a.IDENTIFIER,1,8) as NUMERORAPPORTO" + Cst.CrLf;

                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.ACTOR.ToString() + " a " + Cst.CrLf;
                    sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.BOOK.ToString() + " b " + SQLCst.ON + "b.IDB = @COUNTERPARTYBOOKIDB" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "a.IDA = @COUNTERPARTYIDA" + Cst.CrLf;
                    break;

                case "NdgInActorExternalLink":
                    sqlSelect += SQLCst.SELECT + " aCtr.EXTLLINK as NDG, b.EXTLLINK as NUMERORAPPORTO" + Cst.CrLf;
                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.ACTOR.ToString() + " a " + Cst.CrLf;
                    sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.BOOK.ToString() + " b " + SQLCst.ON + "b.IDB = @MAINACTORBOOKIDB" + Cst.CrLf;
                    sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.ACTOR.ToString() + " aCtr " + SQLCst.ON + "aCtr.IDA = @COUNTERPARTYIDA" + Cst.CrLf;
                    sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.BOOK.ToString() + " bCtr " + SQLCst.ON + "bCtr.IDB = @COUNTERPARTYBOOKIDB" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "a.IDA = @MAINACTORIDA" + Cst.CrLf;
                    break;

                default:
                    sqlSelect += SQLCst.SELECT + " a.IDENTIFIER as NDG, b.IDENTIFIER as NUMERORAPPORTO" + Cst.CrLf;
                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.ACTOR.ToString() + " a " + Cst.CrLf;
                    sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.BOOK.ToString() + " b " + SQLCst.ON + "b.IDB = @COUNTERPARTYBOOKIDB" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "a.IDA = @COUNTERPARTYIDA" + Cst.CrLf;
                    break;
            }

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    string numeroDirezioneGenerale = Convert.ToString(dr["NDG"]);
                    Report.trade.dataDocument.repository.counterparty.numeroDirezioneGenerale = numeroDirezioneGenerale;
                    string numeroRapporto = Convert.ToString(dr["NUMERORAPPORTO"]);
                    Report.trade.dataDocument.repository.counterparty.numeroRapporto = numeroRapporto;
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "NDG e numero rapporto non valorizzati per l'attore id [" + Report.trade.dataDocument.repository.counterparty.identifier + "].";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.repository.counterparty.numeroDirezioneGenerale = String.Empty;
                    Report.trade.dataDocument.repository.counterparty.numeroRapporto = String.Empty;
                }
            }
        }

        /// <summary>
        /// Feed the report trade.dataDocument.repository section using the NDG factorization
        /// for each repository type
        /// </summary>
        /// <param name="pActorRepositoryStyle"></param>
        /// <param name="pTradeIdentifier"></param>
        protected void NdgFactorization(string pActorRepositoryStyle, string pTradeIdentifier)
        {
            bool isCounterPartyClient = Report.trade.dataDocument.repository.counterparty.isClient;
            string numeroDirezioneGenerale = Report.trade.dataDocument.repository.counterparty.numeroDirezioneGenerale;
            string numeroRapporto = Report.trade.dataDocument.repository.counterparty.numeroRapporto;
            string counterpartyIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
            string codiceBanca = String.Empty;
            string codiceAziendale = String.Empty;
            string sportello = String.Empty;
            string numeroContoRapporto = String.Empty;
            string servizioProvenienza = String.Empty;

            switch (pActorRepositoryStyle)
            {
                case "NdgInActorIdentifier":
                    codiceBanca = Convert.ToString("84");

                    if (false == Convert.IsDBNull(Report.trade.dataDocument.repository.counterparty.numeroDirezioneGenerale))
                        codiceAziendale = Convert.ToString(Report.trade.dataDocument.repository.counterparty.numeroDirezioneGenerale);
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Codice Anagrafico non valorizzati per l'attore id [" + counterpartyIdentifier + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                        codiceAziendale = String.Empty;
                    }

                    servizioProvenienza = Convert.ToString("76");
                    string servizioRapporto = Convert.ToString("18");

                    if (isCounterPartyClient == true)
                    {
                        if (false == Convert.IsDBNull(numeroRapporto))
                        {
                            sportello = Convert.ToString(numeroRapporto.Substring(2, 3));
                            numeroContoRapporto = Convert.ToString(numeroRapporto.Substring(9, 8));
                        }
                        else
                        {
                            // FI 20200623 [XXXXX] SetErrorWarning
                            Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                            WarningMessage = "Codice Sportello non valorizzato per l'attore id [" + counterpartyIdentifier + "].";
                            
                            Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                            sportello = String.Empty;

                            WarningMessage = "Numero conto rapporto non valorizzati per l'attore id [" + counterpartyIdentifier + "].";
                            
                            Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                            numeroContoRapporto = String.Empty;
                        }
                    }
                    else
                    {
                        sportello = Convert.ToString("001");
                        char padNumeroContoRapporto = '0';
                        if (false == Convert.IsDBNull(numeroDirezioneGenerale))
                            numeroContoRapporto = Convert.ToString(numeroDirezioneGenerale.Substring(1, 8).PadLeft(8, padNumeroContoRapporto));
                        else
                        {
                            // FI 20200623 [XXXXX] SetErrorWarning
                            Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                            
                            WarningMessage = "Numero conto rapporto e numero direzione generale non valorizzati per l'attore id [" + counterpartyIdentifier + "].";

                            
                            Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                            numeroContoRapporto = String.Empty;
                        }
                    }

                    Report.trade.dataDocument.repository.counterparty.codiceBanca = codiceBanca;
                    Report.trade.dataDocument.repository.counterparty.codiceAziendale = codiceAziendale;
                    Report.trade.dataDocument.repository.counterparty.sportello = sportello;
                    Report.trade.dataDocument.repository.counterparty.numeroContoRapporto = numeroContoRapporto;
                    Report.trade.dataDocument.repository.counterparty.servizioProvenienza = servizioProvenienza;
                    Report.trade.dataDocument.repository.counterparty.servizioRapporto = servizioRapporto;
                    break;

                case "NdgInActorExternalLink":
                    // codiceBanca: The bank code is the first character of the bank book.
                    if (false == Convert.IsDBNull(numeroRapporto))
                        codiceBanca = Convert.ToString(numeroRapporto.Substring(0, 1));
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Codice banca non valorizzato per l'attore id [" + counterpartyIdentifier + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                    // 0125 field contains the cdg code of the counterparty for the book of the bank (stored in ACTOR.EXTLLINK of the counterparty).
                    char padCodiceAziendale = '0';
                    if (false == Convert.IsDBNull(numeroDirezioneGenerale))
                        codiceAziendale = (numeroDirezioneGenerale.PadLeft(16, padCodiceAziendale));
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                        WarningMessage = "Codice aziendale non valorizzato per l'attore id [" + counterpartyIdentifier + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                    // servizio provenienza
                    if (false == Convert.IsDBNull(numeroRapporto))
                        servizioProvenienza = Convert.ToString(numeroRapporto.Substring(1, 2));
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                        
                        WarningMessage = "Servizio provenienza non valorizzato per l'attore id [" + counterpartyIdentifier + "].";
                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }

                    string substringSportello = Convert.ToString(numeroRapporto.Substring(3, 3));
                    char padSportello = '0';

                    if (false == Convert.IsDBNull(numeroRapporto))
                    {
                        // 0120 field contains the subsidiary code (codice filiale) left padded by 0: the subsidiary code is included in the book external link of the bank, from 4th over 3 characters.
                        sportello = Convert.ToString(substringSportello.PadLeft(8, padSportello));
                        // numero rapporto - numero conto rapporto (655)
                        numeroContoRapporto = Convert.ToString(numeroRapporto.Substring(1, 15));
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                        
                        WarningMessage = "Sportello non valorizzato per l'attore id " + counterpartyIdentifier + "].";
                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                        
                        // FI 20200623 [XXXXX] SetErrorWarning
                        WarningMessage = "Numero conto rapporto non valorizzati per l'attore id [" + counterpartyIdentifier + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }

                    Report.trade.dataDocument.repository.counterparty.codiceBanca = codiceBanca;
                    Report.trade.dataDocument.repository.counterparty.codiceAziendale = codiceAziendale;
                    Report.trade.dataDocument.repository.counterparty.sportello = sportello;
                    Report.trade.dataDocument.repository.counterparty.numeroContoRapporto = numeroContoRapporto;
                    Report.trade.dataDocument.repository.counterparty.servizioProvenienza = servizioProvenienza;
                    break;
                default:
                    break;
            }

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void UicCountryCode(string pTradeIdentifier)
        {
            string idCountryResidence = Report.trade.dataDocument.repository.counterparty.idCountryResidence;
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "ID", DbType.String), idCountryResidence);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "exl.VALUE as UICCOUNTRYCODE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " exl " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "exl.TABLENAME = 'COUNTRY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "exl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "exl.ID = @ID" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                    Report.trade.dataDocument.repository.counterparty.uicCountryCode = Convert.ToString(dr["UICCOUNTRYCODE"]);
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Codice UIC del Paese di residenza della controparte assente. Censire il valore nell'anagrafica COUNTRY id [" + idCountryResidence + "].";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.repository.counterparty.uicCountryCode = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void MifidClientCategorisation(string pTradeIdentifier)
        {
            Int32 counterpartyIda = Report.trade.dataDocument.repository.counterparty.ida;
            string counterpartyIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
            //
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDA", DbType.Int32), counterpartyIda);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "exl.VALUE as MIFIDCLIENTCATEGORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLID.ToString() + " exl " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "exl.TABLENAME = 'ACTOR'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "exl.IDENTIFIER = 'MIFIDCLIENTCATEGORISATION'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "exl.ID = @IDA" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    string mifidClientCategorisation = Convert.ToString(dr["MIFIDCLIENTCATEGORISATION"]);
                    Report.trade.dataDocument.repository.counterparty.mifidClientCategorisation = mifidClientCategorisation;
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Classificazione Mifid assente. Censire il valore nell'anagrafica dell'attore id [" + counterpartyIdentifier + "].";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.repository.counterparty.mifidClientCategorisation = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void IasDerivativeClassification(string pTradeIdentifier)
        {
            Int32 mainActorBookIdb = Report.trade.dataDocument.repository.mainActor.bookIdb;
            string mainActorBookIdentifier = Report.trade.dataDocument.repository.mainActor.bookIdentifier;
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDB", DbType.Int32), mainActorBookIdb);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "exl.VALUE as IASDERIVATIVECLASSIFICATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLID.ToString() + " exl " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "exl.TABLENAME = 'BOOK'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "exl.IDENTIFIER = 'IASCLASSDERV'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "exl.ID = @IDB" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                    Report.trade.dataDocument.repository.mainActor.iasDerivativeClassification = Convert.ToString(dr["IASDERIVATIVECLASSIFICATION"]);
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Classificazione dei derivati ai fini IAS assente. Censire il valore per il book id [" + mainActorBookIdentifier + "].";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.repository.mainActor.iasDerivativeClassification = String.Empty;
                }
            }
        }

        /// <summary>
        /// Feed IASHedgedClassDerv from trade (extended field)
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // RD 20210304 Use TRADEXML.TRADEXML instead of TRADE.TRADEXML
        protected void IasHedgedDerivativeClassification(Int32 pIdt)
        {
            //Int32 mainActorBookIdb = Report.trade.dataDocument.repository.mainActor.bookIdb;
            //string mainActorBookIdentifier = Report.trade.dataDocument.repository.mainActor.bookIdentifier;
            //
            DataParameters parameters = new DataParameters();
            //parameters.Add(new DataParameter(Cs, "IDB", DbType.Int32), mainActorBookIdb);
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();

            sqlSelect += SQLCst.SELECT + @"trx.TRADEXML.value('declare default element namespace ""http://www.fpml.org/2007/FpML-4-4"";declare namespace efs=""http://www.efs.org/2007/EFSmL-3-0"";(efs:EfsML/trade/efs:tradeExtends/efs:tradeExtend[@scheme=""IASHedgedClassDerv""])[1]', 'varchar(64)') as IASHEDGEDCLASSDERV" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADEXML.ToString() + " trx " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "trx.IDT = @IDT" + Cst.CrLf;

            //sqlSelect += SQLCst.SELECT + "exl.VALUE as IASHEDGEDCLASSDERV" + Cst.CrLf;
            //sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLID.ToString() + " exl " + Cst.CrLf;
            //sqlSelect += SQLCst.WHERE + "exl.TABLENAME = 'BOOK'" + Cst.CrLf;
            //sqlSelect += SQLCst.AND + "exl.IDENTIFIER = 'IASHEDGEDCLASSDERV'" + Cst.CrLf;
            //sqlSelect += SQLCst.AND + "exl.ID = @IDB" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                    Report.trade.dataDocument.repository.mainActor.iasHedgedDerivativeClassification = Convert.ToString(dr["IASHEDGEDCLASSDERV"]);
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipologia portafoglio IAS coperto assente. Censire il valore sul trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.repository.mainActor.iasHedgedDerivativeClassification = String.Empty;
                }
            }
        }

        /// <summary>
        /// set isStructuredProduct= false when only one trade having same LINKID
        /// if only one trade have the same LINKID is not a structured trade
        /// </summary>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void CheckStructuredProducts()
        {
            if (Report.trade.header.isStructuredProduct == true)
            {
                int count = 0;
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "LINKID", DbType.String), Report.trade.header.structuredIdentifier);
                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + SQLCst.COUNT_ALL + SQLCst.AS + " COUNT " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.LINKID + " li " + SQLCst.ON + "(li.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "li.LINKIDSCHEME = 'http://www.euro-finance-systems.fr/otcml/folderid'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "li.LINKID = @LINKID " + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        if (false == Convert.IsDBNull(dr["COUNT"]))
                            count = Convert.ToInt32((dr["COUNT"]));
                    }
                    if (count < 2)
                    {
                        Report.trade.header.isStructuredProduct = false;
                        Report.trade.header.structuredIdentifier = String.Empty;
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void StructuredProduct()
        {
            if (Report.trade.header.isStructuredProduct == true)
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "LINKID", DbType.String), Report.trade.header.structuredIdentifier);
                parameters.Add(new DataParameter(Cs, "DTEND", DbType.Date), Report.trade.header.terminationDate); // FI 20201006 [XXXXX] DbType.Date
                StrBuilder sqlSelect = new StrBuilder();
                // min IDT is always the master on a structured trade
                sqlSelect += SQLCst.SELECT + SQLCst.MIN + "(t.IDT) as IDT" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.LINKID + " li " + SQLCst.ON + "(li.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eTrd " + SQLCst.ON + "(eTrd.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eTrd.EVENTCODE  = 'TRD'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eTrd.EVENTTYPE  = 'DAT'" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "li.LINKIDSCHEME = 'http://www.euro-finance-systems.fr/otcml/folderid'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "li.LINKID = @LINKID " + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eTrd.DTENDADJ = @DTEND " + Cst.CrLf;
                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        Int32 structuredMasterIdt = Convert.ToInt32(dr["IDT"]);
                        if (structuredMasterIdt == Report.trade.header.idt)
                            Report.trade.header.isStructuredMaster = true;
                        else
                            Report.trade.header.isStructuredMaster = false;
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pCs"></param>
        /// <param name="pIdt"></param>
        /// <param name="pEndDate"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pIsOpenAndClosed"></param>
        /// <returns></returns>
        public static DataSet RetrieveNotionalSchedule(string pCs, Int32 pIdt, DateTime pEndDate, bool pIsOpen, bool pIsOpenAndClosed)
        {
            bool isOpen = pIsOpen;
            bool isOpenAndClosed = pIsOpenAndClosed;
            //
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(pCs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(pCs, "ENDDATE", DbType.Date), pEndDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ecAmz.DTEVENT as NOTIONAL_STEP_END_DATE, eAmz.VALORISATION as NOTIONALVALUE_AMOUNT, " + Cst.CrLf;
            sqlSelect += " eAmz.UNIT as NOTIONALVALUE_IDC, extl.VALUE as NOTIONALVALUE_UIC " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eAmz " + SQLCst.ON + " eAmz.IDT = t.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eAmz.EVENTCODE  in ('INT', 'TER', 'TEI')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eAmz.EVENTTYPE  = 'NOM'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eAmz.STREAMNO   = (" + Cst.CrLf;
            sqlSelect += SQLCst.SELECT + "top 1(eStream.STREAMNO)" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eStream " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "eStream.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eStream.EVENTTYPE = 'NOM'" + Cst.CrLf;
            sqlSelect += SQLCst.ORDERBY + "eStream.VALORISATION desc, eStream.STREAMNO desc )" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecAmz " + SQLCst.ON + "ecAmz.IDE = eAmz.IDE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ecAmz.EVENTCLASS = 'REC' " + Cst.CrLf;
            if (isOpen == true & isOpenAndClosed == false)
                sqlSelect += SQLCst.AND + " ecAmz.DTEVENT > @ENDDATE " + Cst.CrLf;
            if (isOpen == false & isOpenAndClosed == true)
                sqlSelect += SQLCst.AND + " ecAmz.DTEVENT < @ENDDATE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = eAmz.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.ORDERBY + "eAmz.DTENDUNADJ" + Cst.CrLf;

            DataSet ret = DataHelper.ExecuteDataset(pCs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            return ret;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void ClosingMTMDate(Int32 pIdt, out DateTime pClosingDate)
        {

            DateTime closingDate = DateTime.MinValue;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.DateTime), Report.trade.header.beginDate);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.DTENDUNADJ as CLOSING_MTM_DATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "( e.IDT = t.IDT )" + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.EVENTPRICING + " ep " + SQLCst.ON + "( ep.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE  = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE  = 'MTM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.DTENDUNADJ between @BEGINDATE and @ENDDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.DTENDUNADJ = (" + Cst.CrLf;
            sqlSelect += SQLCst.SELECT + " max (e2.DTENDUNADJ) " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t2 " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e2 " + SQLCst.ON + "( e2.IDT = t2.IDT )" + Cst.CrLf;
            sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.EVENTPRICING + " ep2 " + SQLCst.ON + "( ep2.IDE = e2.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t2.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e2.EVENTCODE  = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e2.EVENTTYPE  = 'MTM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e2.DTENDUNADJ between @BEGINDATE and @ENDDATE ) " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CLOSING_MTM_DATE"]))
                    {
                        //Report.trade.dataDocument.business.closingEvents.closingDate = Convert.ToDateTime(dr["CLOSING_MTM_DATE"]);

                        closingDate = Convert.ToDateTime(dr["CLOSING_MTM_DATE"]);
                    }

                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Data di chiusura MTM di fine mese non disponibile. Eseguire il trattamento.";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }

            }
            pClosingDate = closingDate;
        }

        /// <summary>
        /// Feed MTM on mainactor side
        /// if mainactor is a MTM payer: it feed the pay amount using the MTM events values. It feed the other side (rec amount) with zero.
        /// if mainactor is a MTM receiver: it feed the receive amount the MTM events values. It feed the other side (pay amount)with zero.
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void MTM(Int32 pIdt)
        {
            // Initialize receive markToMarket by zero (to handle one MTM value es. in capFloor only one MTM is feed)  
            Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveAmount = Decimal.Zero;
            Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveIdc = String.Empty;
            Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveDate = DateTime.MinValue;

            // Initialize receive markToMarket by zero (to handle one MTM value es. in capFloor only one MTM is feed)
            Report.trade.dataDocument.business.closingEvents.markToMarket.toPayAmount = Decimal.Zero;
            Report.trade.dataDocument.business.closingEvents.markToMarket.toPayIdc = String.Empty;
            Report.trade.dataDocument.business.closingEvents.markToMarket.toPayDate = DateTime.MinValue;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CLOSINGMTMDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.closingDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);

            // data reader returns value on CLN eventclass if MAINACTOR receive MTM
            StrBuilder sqlSelectRec = new StrBuilder();
            sqlSelectRec += SQLCst.SELECT + "eMtm.VALORISATION as MTM_TO_RECEIVE, eMtm.UNIT as MTM_TO_RECEIVE_IDC, ecMtm.DTEVENT as MTM_TO_RECEIVE_DATE " + Cst.CrLf;
            sqlSelectRec += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelectRec += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eMtm " + SQLCst.ON + "( eMtm.IDT = t.IDT )" + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + " eMtm.EVENTTYPE  = 'MTM' " + Cst.CrLf;
            sqlSelectRec += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "( ecMtm.IDE = eMtm.IDE )" + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + " ecMtm.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelectRec += SQLCst.WHERE + " eMtm.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + " ecMtm.DTEVENT = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelectRec.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["MTM_TO_RECEIVE"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveAmountSpecified = true;
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveAmount = Convert.ToDecimal(dr["MTM_TO_RECEIVE"]);
                    }
                    if (false == Convert.IsDBNull(dr["MTM_TO_RECEIVE_IDC"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveIdcSpecified = true;
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveIdc = Convert.ToString(dr["MTM_TO_RECEIVE_IDC"]);
                    }
                    if (false == Convert.IsDBNull(dr["MTM_TO_RECEIVE_DATE"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveDateSpecified = true;
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveDate = Convert.ToDateTime(dr["MTM_TO_RECEIVE_DATE"]);
                    }
                }
            }

            // data reader returns value on CLN eventclass if MAINACTOR pay MTM
            StrBuilder sqlSelectPay = new StrBuilder();
            sqlSelectPay += SQLCst.SELECT + "eMtm.VALORISATION as MTM_TO_PAY, eMtm.UNIT as MTM_TO_PAY_IDC, ecMtm.DTEVENT as MTM_TO_PAY_DATE " + Cst.CrLf;
            sqlSelectPay += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelectPay += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eMtm " + SQLCst.ON + "( eMtm.IDT = t.IDT )" + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + " eMtm.EVENTTYPE  = 'MTM' " + Cst.CrLf;
            sqlSelectPay += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "( ecMtm.IDE = eMtm.IDE )" + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + " ecMtm.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelectPay += SQLCst.WHERE + " eMtm.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + " ecMtm.DTEVENT = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelectPay.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["MTM_TO_PAY"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toPayAmountSpecified = true;
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toPayAmount = Convert.ToDecimal(dr["MTM_TO_PAY"]);
                    }
                    if (false == Convert.IsDBNull(dr["MTM_TO_PAY_IDC"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toPayIdcSpecified = true;
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toPayIdc = Convert.ToString(dr["MTM_TO_PAY_IDC"]);
                    }

                    if (false == Convert.IsDBNull(dr["MTM_TO_PAY_DATE"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toPayDateSpecified = true;
                        Report.trade.dataDocument.business.closingEvents.markToMarket.toPayDate = Convert.ToDateTime(dr["MTM_TO_PAY_DATE"]);
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected void MTMNetted()
        {
            decimal pay = Report.trade.dataDocument.business.closingEvents.markToMarket.toPayAmount;
            decimal rec = Report.trade.dataDocument.business.closingEvents.markToMarket.toReceiveAmount;
            decimal netted = (rec - pay);
            Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void AccruedInterest(Int32 pIdt, string pTradeIdentifier)
        {
            // Initialize receive accruedInterest by zero (to handle one accruedInterest value es. in capFloor only one accruedInterestis feed)  
            Report.trade.dataDocument.business.closingEvents.accruedInterest.receivedAmount = Decimal.Zero;
            Report.trade.dataDocument.business.closingEvents.accruedInterest.receivedDate = DateTime.MinValue;
            // Initialize paid accruedInterest by zero (to handle one accruedInterest value es. in capFloor only one accruedInterestis feed) 
            Report.trade.dataDocument.business.closingEvents.accruedInterest.paidAmount = Decimal.Zero;
            Report.trade.dataDocument.business.closingEvents.accruedInterest.paidDate = DateTime.MinValue;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGMTMDATE", DbType.DateTime), Report.trade.dataDocument.business.closingEvents.closingDate);

            StrBuilder sqlSelectRec = new StrBuilder();
            sqlSelectRec += SQLCst.SELECT + " sum(eAin.VALORISATION) as ACC_INTEREST_RECEIVE, ecAin.DTEVENT as ACC_INTEREST_RECEIVE_DATE " + Cst.CrLf;
            sqlSelectRec += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelectRec += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eAin " + SQLCst.ON + "( eAin.IDT = t.IDT )" + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + " eAin.EVENTTYPE  = 'AIN' " + Cst.CrLf;
            sqlSelectRec += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecAin " + SQLCst.ON + "( ecAin.IDE = eAin.IDE )" + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + " ecAin.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + " ecAin.DTEVENT = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelectRec += SQLCst.WHERE + " eAin.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelectRec += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelectRec += SQLCst.GROUPBY + " ecAin.DTEVENT " + Cst.CrLf;
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelectRec.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["ACC_INTEREST_RECEIVE"]))
                        Report.trade.dataDocument.business.closingEvents.accruedInterest.receivedAmount = Convert.ToDecimal(dr["ACC_INTEREST_RECEIVE"]);
                    if (false == Convert.IsDBNull(dr["ACC_INTEREST_RECEIVE_DATE"]))
                        Report.trade.dataDocument.business.closingEvents.accruedInterest.receivedDate = Convert.ToDateTime(dr["ACC_INTEREST_RECEIVE_DATE"]);
                }
            }

            StrBuilder sqlSelectPay = new StrBuilder();
            sqlSelectPay += SQLCst.SELECT + " sum (eAin.VALORISATION) as ACC_INTEREST_PAY, ecAin.DTEVENT as ACC_INTEREST_PAY_DATE " + Cst.CrLf;
            sqlSelectPay += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelectPay += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eAin " + SQLCst.ON + "( eAin.IDT = t.IDT )" + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + " eAin.EVENTTYPE  = 'AIN' " + Cst.CrLf;
            sqlSelectPay += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecAin " + SQLCst.ON + "( ecAin.IDE = eAin.IDE )" + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + " ecAin.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + " ecAin.DTEVENT = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelectPay += SQLCst.WHERE + " eAin.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelectPay += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelectPay += SQLCst.GROUPBY + " ecAin.DTEVENT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelectPay.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["ACC_INTEREST_PAY"]))
                        Report.trade.dataDocument.business.closingEvents.accruedInterest.paidAmount = Convert.ToDecimal(dr["ACC_INTEREST_PAY"]);
                    if (false == Convert.IsDBNull(dr["ACC_INTEREST_PAY_DATE"]))
                        Report.trade.dataDocument.business.closingEvents.accruedInterest.paidDate = Convert.ToDateTime(dr["ACC_INTEREST_PAY_DATE"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected void AccruedInterestNetted()
        {
            decimal received = Report.trade.dataDocument.business.closingEvents.accruedInterest.receivedAmount;
            decimal paid = Report.trade.dataDocument.business.closingEvents.accruedInterest.paidAmount;
            decimal netted = (received - paid);
            Report.trade.dataDocument.business.closingEvents.accruedInterest.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected void SpotRate(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CLOSINGMTMDATE", DbType.DateTime), Report.trade.dataDocument.business.closingEvents.closingDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ep.SPOTRATE as SPOTRATE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "( e.IDT = t.IDT )" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT  = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTPRICING + " ep " + SQLCst.ON + "( ep.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["SPOTRATE"]))
                        Report.trade.dataDocument.business.closingEvents.spotRate = Convert.ToDecimal(dr["SPOTRATE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Greche non valorizzate. Eseguire il trattamento MTM sul trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.spotRate = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected void Greek(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CLOSINGMTMDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ep.VEGA as VEGA, ep.GAMMA as GAMMA, ep.DELTA as DELTA , ep.VOLATILITY as VOLATILITY, ep.SPOTRATE as SPOTRATE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "( e.IDT = t.IDT )" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT  = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTPRICING + " ep " + SQLCst.ON + "( ep.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VEGA"]))
                        Report.trade.dataDocument.business.closingEvents.greeks.vega = Convert.ToDecimal(dr["VEGA"]);
                    if (false == Convert.IsDBNull(dr["GAMMA"]))
                        Report.trade.dataDocument.business.closingEvents.greeks.gamma = Convert.ToDecimal(dr["GAMMA"]);
                    if (false == Convert.IsDBNull(dr["DELTA"]))
                        Report.trade.dataDocument.business.closingEvents.greeks.delta = Convert.ToDecimal(dr["DELTA"]);
                    if (false == Convert.IsDBNull(dr["VOLATILITY"]))
                        Report.trade.dataDocument.business.closingEvents.greeks.implicitVolatility = Convert.ToDecimal(dr["VOLATILITY"]);
                    if (false == Convert.IsDBNull(dr["SPOTRATE"]))
                        Report.trade.dataDocument.business.closingEvents.spotRate = Convert.ToDecimal(dr["SPOTRATE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Greche non valorizzate. Eseguire il trattamento MTM sul trade.";
                    
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.greeks.vega = Decimal.Zero;
                    Report.trade.dataDocument.business.closingEvents.greeks.gamma = Decimal.Zero;
                    Report.trade.dataDocument.business.closingEvents.greeks.delta = Decimal.Zero;
                    Report.trade.dataDocument.business.closingEvents.greeks.implicitVolatility = Decimal.Zero;
                    Report.trade.dataDocument.business.closingEvents.spotRate = Decimal.Zero;
                }
            }
        }

        #region GS20110630 calculation interests in progress (not available)
        ///// <summary>
        ///// return value of interest calculate between date interval using the quotation of the last day of mounth
        ///// </summary>
        ///// <param name="pStartDate"></param>
        ///// <param name="pMaturityDate"></param>
        ///// <param name="pDayCountFraction"></param>
        ///// <param name="pCurrency"></param>
        ///// <param name="pAmount"></param>
        ///// <param name="pFixedRate"></param>
        ///// <returns></returns>
        //protected string CalculateInterest(int pIdt, DateTime pStartDate, DateTime pMaturityDate, String pCurrency, Decimal pAmount, Decimal pQuote)
        //{
        //    try
        //    {
        //        decimal interest = 0;
        //        DateTime startDate = pStartDate;
        //        DateTime maturityDate = pMaturityDate;
        //        Decimal fixedRate = pQuote;
        //        DayCountFractionEnum dayCountFraction = DayCountFractionEnum.ACTACTISDA;
        //        //
        //        EFS_TradeLibrary tradeLibrary = null;
        //        tradeLibrary = new EFS_TradeLibrary(Cs, null, pIdt);
        //        FpML.Interface.IProductBase productBase = tradeLibrary.product.productBase;

        //        if (DtFunc.IsDateTimeFilled(startDate) && DtFunc.IsDateTimeFilled(maturityDate) && (0 < maturityDate.CompareTo(startDate)))
        //        {
        //            IInterval interval = ((IProductBase)productBase).CreateInterval(PeriodEnum.D, 0);
        //            EFS_DayCountFraction dcf = new EFS_DayCountFraction(startDate, maturityDate, dayCountFraction, interval);
        //            interest = pAmount * fixedRate * dcf.Factor;
        //            EFS_Cash cash = new EFS_Cash(Cs, interest, pCurrency);
        //            interest = cash.AmountRounded;
        //        }
        //        return StrFunc.FmtDecimalToInvariantCulture(interest);
        //    }
        //    catch (OTCmlException ex) { throw ex; }
        //    catch (Exception ex) { throw new OTCmlException("CalculateInterest", ex); }
        //}

        ///// <summary>
        ///// returns rate index quotation for the last day of the month 
        ///// </summary>
        ///// <param name="pIdt"></param>
        ///// <param name="pFixingDate"></param>
        ///// <param name="pRateIndexIdentifier"></param>
        ///// <returns></returns>
        //protected SQL_Quote ReadQuote_RateIndex(int pIdt, DateTime pFixingDate, string pRateIndexIdentifier)
        //{
        //    string logMessage = string.Empty;
        //    Cst.ErrLevel codeReturn = Cst.ErrLevel.UNDEFINED;
        //    string idMarketEnv = "DEFAULT_MARKET_ENV";
        //    string rateIndexIdentifier = pRateIndexIdentifier;
        //    //
        //    KeyQuote keyQuote = new KeyQuote(Cs, pFixingDate, idMarketEnv);
        //    keyQuote.QuoteTiming = QuoteTimingEnum.Close;
        //    //
        //    KeyAssetRateIndex keyAssetRateIndex = new KeyAssetRateIndex();
        //    keyAssetRateIndex.rateIndex_Identifier = rateIndexIdentifier;
        //    //
        //    EFS_TradeLibrary tradeLibrary = null;
        //    tradeLibrary = new EFS_TradeLibrary(Cs, null, pIdt);
        //    FpML.Interface.IProductBase productBase = tradeLibrary.product.productBase;
        //    // 
        //    SQL_Quote quote = new SQL_Quote(Cs, QuoteEnum.RATEINDEX, AvailabilityEnum.Enabled, productBase, keyQuote, keyAssetRateIndex);
        //    if (!quote.IsLoaded)
        //        logMessage = quote.QuoteValueMessage;
        //    codeReturn = quote.QuoteValueCodeReturn;
        //    //
        //    return quote;
        //}
        #endregion
    }

    /// <summary>
    /// Feed report business section for swap  
    /// </summary>
    public class RRBusinessSwap : RRBusiness
    {
        public RRBusinessSwap(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
            : base(pCs, pDomesticCurrency, pProcess, pReport, pBeginDate, pEndDate, pOpenAndClosedBeginDate, pDerivativeBeginDate, pInstrumentIdentifier, pActorRepositoryStyle)
        {
        }

        /// <summary>
        /// Discard out-of-the-scope trades for:
        /// Periodic zero coupon swap
        /// Zero coupon swap with amortizing notional
        /// Swap with not EUR notional amount currency
        /// Swap with roller coaster notional
        /// Swap without closing events at the extraction period
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void IsInTheScope(Int32 pIdt)
        {

            //Periodic zero coupon swap is out-of-the-scope
            //more than one known amount payment (INT/INT indicates that there is more than one amount payment
            DataParameters parameters01 = new DataParameters();
            parameters01.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect01 = new StrBuilder();
            sqlSelect01 += SQLCst.SELECT + " count (*) as OUTOFTHESCOPE" + Cst.CrLf;
            sqlSelect01 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eKna " + Cst.CrLf;
            sqlSelect01 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eKnaInt " + SQLCst.ON + "(eKnaInt.IDe_EVENT = eKna.IDE)" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eKnaInt.EVENTCODE= 'INT'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eKnaInt.EVENTCODE= 'INT'" + Cst.CrLf;
            sqlSelect01 += SQLCst.WHERE + "eKna.IDT = @IDT" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eKna.EVENTCODE= 'IRS'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eKna.EVENTTYPE = 'KNA'" + Cst.CrLf;
            DataSet dse01 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect01.ToString(), parameters01.GetArrayDbParameter());
            DataTable dt01 = dse01.Tables[0];
            DataRow[] rows01 = dt01.Select();
            DataRow row01 = rows01[0];

            bool isInTheScope = true;
            Int16 count = Convert.ToInt16(row01["OUTOFTHESCOPE"]);
            if (count != 0)
            {
                isInTheScope = false;
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                
                WarningMessage = "Trade scartato (out of the scope): Zero coupon swap con pagamento periodico.";

                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
            Report.trade.header.isInTheScope = isInTheScope;

            // Zero coupon swap with amortizing notional is out-of-the-scope
            if (isInTheScope == true)
            {
                DataParameters parameters02 = new DataParameters();
                parameters02.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                StrBuilder sqlSelect02 = new StrBuilder();
                sqlSelect02 += SQLCst.SELECT + "count (*) as OUTOFTHESCOPE" + Cst.CrLf;
                sqlSelect02 += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect02 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect02 += SQLCst.WHERE + " e.EVENTCODE  = 'IRS' " + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + " e.EVENTTYPE  = 'KNA' " + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + " exists (" + Cst.CrLf;
                sqlSelect02 += SQLCst.SELECT + "1" + Cst.CrLf;
                sqlSelect02 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e2 " + Cst.CrLf;
                sqlSelect02 += SQLCst.WHERE + "e2.EVENTCODE = 'INT'" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.EVENTTYPE = 'NOM'" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.STREAMNO = 1 " + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.IDT = @IDT" + Cst.CrLf;
                sqlSelect02 += SQLCst.GROUPBY + " e2.IDT " + Cst.CrLf;
                sqlSelect02 += SQLCst.HAVING + " count (*) >= 1 )" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
                //
                DataSet ds02 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect02.ToString(), parameters02.GetArrayDbParameter());
                DataTable dt02 = ds02.Tables[0];
                DataRow[] rows02 = dt02.Select();
                DataRow row02 = rows02[0];
                //
                count = Convert.ToInt16(row02["OUTOFTHESCOPE"]);
                if (count != 0)
                {
                    isInTheScope = false;
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                    
                    WarningMessage = "Trade scartato (out of the scope: Zero coupon swap con ammortamento del nozionale.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
                Report.trade.header.isInTheScope = isInTheScope;
            }

            //swap with not EUR notional amount currency is out-of-the-scope
            if (isInTheScope == true)
            {
                DataParameters parameters02 = new DataParameters();
                parameters02.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                StrBuilder sqlSelect02 = new StrBuilder();
                sqlSelect02 += SQLCst.SELECT + "count (*) as OUTOFTHESCOPE" + Cst.CrLf;
                sqlSelect02 += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect02 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e.EVENTCODE= 'STA'" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e.EVENTTYPE = 'NOM'" + Cst.CrLf;
                sqlSelect02 += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e.UNIT != 'EUR'" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e.STREAMNO = (" + Cst.CrLf;
                sqlSelect02 += SQLCst.SELECT + "max(STREAMNO)" + Cst.CrLf;
                sqlSelect02 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eStream " + Cst.CrLf;
                sqlSelect02 += SQLCst.WHERE + "eStream.IDT = @IDT" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "eStream.EVENTTYPE = 'NOM')" + Cst.CrLf;
                DataSet ds02 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect02.ToString(), parameters02.GetArrayDbParameter());
                DataTable dt02 = ds02.Tables[0];
                DataRow[] rows02 = dt02.Select();
                DataRow row02 = rows02[0];
                //
                count = Convert.ToInt16(row02["OUTOFTHESCOPE"]);
                if (count != 0)
                {
                    isInTheScope = false;
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Trade scartato (out of the scope): Swap con divisa del nozionale diversa da EURO.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
                Report.trade.header.isInTheScope = isInTheScope;
            }

            //swap with roller coaster notional is out-of-the-scope
            if (isInTheScope == true)
            {
                DataParameters parameters03 = new DataParameters();
                parameters03.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                StrBuilder sqlSelect03 = new StrBuilder();
                sqlSelect03 += SQLCst.SELECT + "count (*) as OUTOFTHESCOPE" + Cst.CrLf;
                sqlSelect03 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
                sqlSelect03 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "ec.EVENTCLASS = 'GRP'" + Cst.CrLf;
                sqlSelect03 += SQLCst.WHERE + " e.EVENTCODE = 'IRS' " + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "e.IDT = @IDT" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "exists (" + Cst.CrLf;
                sqlSelect03 += SQLCst.SELECT + "1" + Cst.CrLf;
                sqlSelect03 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e2 " + Cst.CrLf;
                sqlSelect03 += SQLCst.WHERE + "e2.IDT = e.IDT" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "e2.STREAMNO = e.STREAMNO" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "e2.EVENTCODE in ('INT', 'TER', 'TEI')" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "e2.EVENTTYPE = 'NOM'" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "e2.IDA_PAY != e.IDA_PAY )" + Cst.CrLf;
                DataSet ds03 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect03.ToString(), parameters03.GetArrayDbParameter());
                DataTable dt03 = ds03.Tables[0];
                DataRow[] rows03 = dt03.Select();
                DataRow row03 = rows03[0];
                //
                count = Convert.ToInt16(row03["OUTOFTHESCOPE"]);
                if (count != 0)
                {
                    // GS 20131210: temporary update (in use only for Bancaperta)
                    // waiting to implement the roller-coaster notional factorization algorithm
                    // Client ask to remove the 'out-of-the-scope' filter for the trades with roller coaster notional 
                    // No filter is applied for IRD roller coaster
                    // A record is drawn into export file for each roller coaster elementary trade
                    // back-office operators make manual changes on the missing or wrong data
                    isInTheScope = true;
                    //WarningMessage = "Trade scartato (out of the scope): Swap roller coaster.";
                    //Process.ProcessLogAddDetail(ProcessStateTools.StatusWarningEnum, WarningMessage);
                }
                Report.trade.header.isInTheScope = isInTheScope;
            }

            // Swap without closing events at the extraction period is out-of-the-scope
            if (isInTheScope == true)
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.Date), Report.trade.header.beginDate); // FI 20201006 [XXXXX] DbType.Date
                parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "count (*) as ISINTHESCOPE" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eMtm " + SQLCst.ON + "(eMtm.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "(ecMtm.IDE = eMtm.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecMtm.EVENTCLASS = 'CLN'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecMtm.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eMtM.EVENTCODE = 'CLO'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eMtM.EVENTTYPE = 'MTM'" + Cst.CrLf;
                DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
                DataTable dt = ds.Tables[0];
                DataRow[] rows = dt.Select();
                DataRow row = rows[0];
                count = Convert.ToInt16(row["ISINTHESCOPE"]);
                if (count == 0)
                {
                    isInTheScope = false;
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Trade scartato (out of the scope): Nessun evento di chiusura per il periodo di osservazione.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
                Report.trade.header.isInTheScope = isInTheScope;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void ProductType(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e1.EVENTTYPE as EVENTTYPE1, e2.EVENTTYPE EVENTTYPE2" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += " left outer join (select distinct IDT, EVENTCODE, EVENTTYPE from EVENT where STREAMNO = 1 and EVENTCODE = 'IRS') e1" + SQLCst.ON + "e1.IDT = t.IDT" + Cst.CrLf;
            sqlSelect += " left outer join (select distinct IDT, EVENTCODE, EVENTTYPE from EVENT where STREAMNO = 2 and EVENTCODE = 'IRS') e2" + SQLCst.ON + "e2.IDT = t.IDT" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    string eventType1 = Convert.ToString(dr["EVENTTYPE1"]);
                    string eventType2 = Convert.ToString(dr["EVENTTYPE2"]);
                    //
                    string ret = String.Empty;

                    if (eventType1 == "KNA" || eventType2 == "KNA")
                        ret = "SWAP-ZERO-COUPON";
                    if ((eventType1 == "FIX" && eventType2 == "FLO") || (eventType1 == "FLO" && eventType2 == "FIX"))
                        ret = "SWAP-FIXED-FLOATING";
                    if (eventType1 == "FLO" && eventType2 == "FLO")
                        ret = "SWAP-FLOATING-FLOATING";
                    if (eventType1 == "FIX" && eventType2 == "FIX")
                        ret = "SWAP-FIXED-FIXED";

                    Report.trade.dataDocument.business.swap.productType = ret;
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo prodotto non valorizzato. Verificare gli eventi del trade.";
                    
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.swap.productType = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void IsOvernight(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "count (*) as ISOVERNIGHT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.RATEINDEX + " ri " + SQLCst.ON + "(ar.IDRX = ri.IDRX)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ri.RATETYPE = 'OVERNIGHT'" + Cst.CrLf;
            //dataset
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            // if count = 0 isn't a overnight / if count = 1 is a overnight
            bool isOverNight = false;
            Int16 count = Convert.ToInt16(row["ISOVERNIGHT"]);
            if (count != 0)
                isOverNight = true;
            Report.trade.dataDocument.business.swap.isOvernight = isOverNight;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void IsAmortizing(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "count (*) as ISAMORTIZING" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'INT'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'NOM'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            Int16 count = Convert.ToInt16(row["ISAMORTIZING"]);
            bool isAmortizing = false;
            if (count > 0)
                isAmortizing = true;
            Report.trade.dataDocument.business.swap.isAmortizing = isAmortizing;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void NextResetDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "MIN (ec.DTEVENT) as NEXT_RESET_DATE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(e.IDE = ec.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'RES'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.eventclass = 'GRP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.DTEVENT > @ENDDATE" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["NEXT_RESET_DATE"]))
                        Report.trade.dataDocument.business.swap.nextResetDate = Convert.ToDateTime(dr["NEXT_RESET_DATE"]);
                    // case handled last calculation period: if next reset date is null returns termination date
                    else Report.trade.dataDocument.business.swap.nextResetDate = Report.trade.header.terminationDate;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void StreamRateType(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "IDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "eRec.EVENTTYPE as RECEIVED_RATE_TYPE, ePay.EVENTTYPE as PAID_RATE_TYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eRec " + SQLCst.ON + "(eRec.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eRec.EVENTCODE= 'IRS'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eRec.EVENTTYPE in ('FIX', 'FLO', 'KNA')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eRec.IDA_REC = @IDA" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " ePay " + SQLCst.ON + "(ePay.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ePay.EVENTCODE= 'IRS'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ePay.EVENTTYPE in ('FIX', 'FLO', 'KNA')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ePay.IDA_PAY = @IDA" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            //
            string receivedRateType = Convert.ToString(row["RECEIVED_RATE_TYPE"]);
            Report.trade.dataDocument.business.swap.receiverStream.streamRateType = receivedRateType;
            string paidRateType = Convert.ToString(row["PAID_RATE_TYPE"]);
            Report.trade.dataDocument.business.swap.payerStream.streamRateType = paidRateType;
        }

        /// <summary>
        /// 
        /// </summary>
        private void EnableStreamObjects()
        {
            string fixedRate = "FIX";
            string floatingRate = "FLO";
            string zeroCoupon = "KNA";

            string receivedRateType = Report.trade.dataDocument.business.swap.receiverStream.streamRateType;
            string paidRateType = Report.trade.dataDocument.business.swap.payerStream.streamRateType;

            if (receivedRateType == fixedRate)
            {
                Report.trade.dataDocument.business.swap.receiverStream.fixedRateSpecified = true;
            }

            if (receivedRateType == floatingRate)
            {
                Report.trade.dataDocument.business.swap.receiverStream.periodRateTypeSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.isInterpolateFloatRateSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.floatRateAssetIdentSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.spreadEndDateSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.spreadSpecified = true;
            }

            if (receivedRateType == zeroCoupon)
            {
                Report.trade.dataDocument.business.swap.receiverStream.fixedRateSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.elapsedDaysSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.idcSpecified = true;
                Report.trade.dataDocument.business.swap.receiverStream.accruedInterestSpecified = true;
            }

            if (paidRateType == fixedRate)
            {
                Report.trade.dataDocument.business.swap.payerStream.fixedRateSpecified = true;
            }

            if (paidRateType == floatingRate)
            {
                Report.trade.dataDocument.business.swap.payerStream.periodRateTypeSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.isInterpolateFloatRateSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.floatRateAssetIdentSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.spreadEndDateSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.spreadSpecified = true;
            }

            if (paidRateType == zeroCoupon)
            {
                Report.trade.dataDocument.business.swap.payerStream.fixedRateSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.elapsedDaysSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.idcSpecified = true;
                Report.trade.dataDocument.business.swap.payerStream.accruedInterestSpecified = true;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void StreamNumber(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "IDA", DbType.Int16), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "RECEIVED_RATE_TYPE", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamRateType);
            parameters.Add(new DataParameter(Cs, "PAID_RATE_TYPE", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamRateType);

            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "max (eRec.STREAMNO) as RECEIVER_STREAM, max (ePay.STREAMNO) as PAYER_STREAM" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eRec " + SQLCst.ON + "(eRec.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eRec.EVENTTYPE = 'INT'" + Cst.CrLf;
            //and eRec.IDE_EVENT = (select IDE from EVENT where IDT = @IDT and EVENTCODE= 'IRS' and EVENTTYPE = @RECEIVED_RATE_TYPE)
            sqlSelect += SQLCst.AND + "eRec.IDE_EVENT in " + "(" + SQLCst.SELECT + "IDE" + SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT + SQLCst.WHERE + "IDT = @IDT" + SQLCst.AND + "EVENTCODE= 'IRS'" + SQLCst.AND + "EVENTTYPE = @RECEIVED_RATE_TYPE" + ")" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "eRec.IDA_REC = @IDA" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " ePay " + SQLCst.ON + "(ePay.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ePay.EVENTTYPE = 'INT'" + Cst.CrLf;
            //and ePay.IDE_EVENT = (select IDE from EVENT where IDT = @IDT and EVENTCODE= 'IRS' and EVENTTYPE = @PAID_RATE_TYPE)
            sqlSelect += SQLCst.AND + "ePay.IDE_EVENT in " + "(" + SQLCst.SELECT + "IDE" + SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT + SQLCst.WHERE + "IDT = @IDT" + SQLCst.AND + "EVENTCODE= 'IRS'" + SQLCst.AND + "EVENTTYPE = @PAID_RATE_TYPE" + ")" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ePay.IDA_PAY = @IDA" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            //
            byte receiverStreamNo = Convert.ToByte(row["RECEIVER_STREAM"]);
            Report.trade.dataDocument.business.swap.receiverStream.streamNumber = receiverStreamNo;
            byte payerStreamNo = Convert.ToByte(row["PAYER_STREAM"]);
            Report.trade.dataDocument.business.swap.payerStream.streamNumber = payerStreamNo;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void ReceivedRateEndDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            parameters.Add(new DataParameter(Cs, "RECSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamNumber);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "min (e.DTENDUNADJ) as RECEIVED_RATE_ENDDATE, min (e.EVENTTYPE) as RECEIVED_CALPERIOD_EVENTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE  in ('FIX', 'FLO', 'KNA')" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) >= @ENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            DateTime receivedRateEndDate = Convert.ToDateTime(row["RECEIVED_RATE_ENDDATE"]);
            Report.trade.dataDocument.business.swap.receiverStream.endDate = receivedRateEndDate;
            string receivedCalcPeriodEventType = Convert.ToString(row["RECEIVED_CALPERIOD_EVENTYPE"]);
            Report.trade.dataDocument.business.swap.receiverStream.periodRateType = receivedCalcPeriodEventType;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void PaidRateEndDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            parameters.Add(new DataParameter(Cs, "PAYSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamNumber);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "min (e.DTENDUNADJ) as PAID_RATE_ENDDATE, min (e.EVENTTYPE) as PAID_CALPERIOD_EVENTYPE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE  in ('FIX', 'FLO', 'KNA')" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) >= @ENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            DateTime paidRateEndDate = Convert.ToDateTime(row["PAID_RATE_ENDDATE"]);
            Report.trade.dataDocument.business.swap.payerStream.endDate = paidRateEndDate;
            string paidCalcPeriodEventType = Convert.ToString(row["PAID_CALPERIOD_EVENTYPE"]);
            Report.trade.dataDocument.business.swap.payerStream.periodRateType = paidCalcPeriodEventType;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void IsInterpolateRecFloatRate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "RECSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamNumber);
            parameters.Add(new DataParameter(Cs, "RECRATEENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.receiverStream.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "case when count (ar.IDENTIFIER) > 1 then 'true' else 'false' end as IS_INTERPOLATE_REC_FLOAT_RATE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @RECRATEENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            //
            Report.trade.dataDocument.business.swap.receiverStream.isInterpolateFloatRate = Convert.ToBoolean(row["IS_INTERPOLATE_REC_FLOAT_RATE"]);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void IsInterpolatePayFloatRate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "PAYSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamNumber);
            parameters.Add(new DataParameter(Cs, "PAIDRATEENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.payerStream.endDate);
            //
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "case when count (ar.IDENTIFIER) > 1 then 'true' else 'false' end as IS_INTERPOLATE_PAY_FLOAT_RATE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @PAIDRATEENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            //
            Report.trade.dataDocument.business.swap.payerStream.isInterpolateFloatRate = Convert.ToBoolean(row["IS_INTERPOLATE_PAY_FLOAT_RATE"]);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void ReceivedFixedRate(Int32 pIdt)
        {
            string receivedStreamRateType = Convert.ToString(Report.trade.dataDocument.business.swap.receiverStream.streamRateType);
            string receivedPeriodRateType = Convert.ToString(Report.trade.dataDocument.business.swap.receiverStream.periodRateType);

            if (receivedStreamRateType == "FIX")
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "RECSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamNumber);
                parameters.Add(new DataParameter(Cs, "RECEIVEDRATEENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.receiverStream.endDate);
                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "ed.RATE * 100 as RECEIVED_FIXED_RATE " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FIX'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @RECEIVEDRATEENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        string receivedRateAssetCod;
                        // IRS with stub where calculation period is a floating rate
                        if (receivedPeriodRateType == "FLO")
                            receivedRateAssetCod = "I";
                        // IRS with fixed rate type received rate 
                        else
                            receivedRateAssetCod = "F";
                        // received rate asset code insert into report
                        Report.trade.dataDocument.business.swap.receiverStream.assetCode = receivedRateAssetCod;
                        Report.trade.dataDocument.business.swap.receiverStream.fixedRate = Convert.ToDecimal(dr["RECEIVED_FIXED_RATE"]);
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void PaidFixedRate(Int32 pIdt)
        {
            string paidStreamRateType = Convert.ToString(Report.trade.dataDocument.business.swap.payerStream.streamRateType);
            string paidPeriodRateType = Convert.ToString(Report.trade.dataDocument.business.swap.payerStream.periodRateType);

            if (paidStreamRateType == "FIX")
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "PAYSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamNumber);
                parameters.Add(new DataParameter(Cs, "PAIDRATEENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.payerStream.endDate);

                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "ed.RATE * 100 as PAID_FIXED_RATE " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FIX'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @PAIDRATEENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        string paidRateAssetCod;
                        // IRS with stub where calculation period is a floating rate
                        if (paidPeriodRateType == "FLO")
                            paidRateAssetCod = "I";
                        // IRS with fixed rate type received rate 
                        else
                            paidRateAssetCod = "F";
                        // received rate asset code insert into report
                        Report.trade.dataDocument.business.swap.payerStream.assetCode = paidRateAssetCod;
                        Report.trade.dataDocument.business.swap.payerStream.fixedRate = Convert.ToDecimal(dr["PAID_FIXED_RATE"]);
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void ReceivedFloatingRate(Int32 pIdt)
        {
            string receivedStreamRateType = Convert.ToString(Report.trade.dataDocument.business.swap.receiverStream.streamRateType);
            string receivedPeriodRateType = Convert.ToString(Report.trade.dataDocument.business.swap.receiverStream.periodRateType);
            bool isInterpolateRecFloatRate = Convert.ToBoolean(Report.trade.dataDocument.business.swap.receiverStream.isInterpolateFloatRate);
            //Parameters
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "RECSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamNumber);
            parameters.Add(new DataParameter(Cs, "RECEIVEDRATEENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.receiverStream.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            string receivedRateAssetCod;
            // IRS with floating rate period (standard)
            if (receivedStreamRateType == "FLO" && receivedPeriodRateType == "FLO")
            {
                // Not interpolate floating rate: it returns floating asset code (es.I0EURIB03M)
                if (isInterpolateRecFloatRate == false)
                {
                    sqlSelect += SQLCst.SELECT + "ar.IDENTIFIER as FLOATINGRATE, " + Cst.CrLf;
                    sqlSelect += "ar.EXTLLINK  as ASSETCODE" + Cst.CrLf;
                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FLO'" + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @RECEIVEDRATEENDDATE" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                    using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                    {
                        if (dr.Read())
                        {
                            Report.trade.dataDocument.business.swap.receiverStream.floatRateAssetIdent = Convert.ToString(dr["FLOATINGRATE"]);
                            Report.trade.dataDocument.business.swap.receiverStream.assetCode = Convert.ToString(dr["ASSETCODE"]);
                        }
                    }
                }
                // Is interpolate floating rate (IRS with stub): it returns asset code (I) + fixed rate (es. 2,745)
                if (isInterpolateRecFloatRate == true)
                {
                    sqlSelect += SQLCst.SELECT + "ed.RATE * 100 as FIXEDRATE " + Cst.CrLf;
                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FLO'" + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @RECEIVEDRATEENDDATE" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                    using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                    {
                        if (dr.Read())
                        {
                            receivedRateAssetCod = "I";
                            Report.trade.dataDocument.business.swap.receiverStream.assetCode = receivedRateAssetCod;
                            Report.trade.dataDocument.business.swap.receiverStream.fixedRate = Convert.ToDecimal(dr["FIXEDRATE"]);
                        }
                    }
                }
            }
            // IRS with fixed rate period (stub)
            if (receivedStreamRateType == "FLO" && receivedPeriodRateType == "FIX")
            {
                sqlSelect += SQLCst.SELECT + "ed.RATE * 100 as FIXEDRATE " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FIX'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @RECEIVEDRATEENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        receivedRateAssetCod = "I";
                        Report.trade.dataDocument.business.swap.receiverStream.assetCode = receivedRateAssetCod;
                        Report.trade.dataDocument.business.swap.receiverStream.fixedRate = Convert.ToDecimal(dr["FIXEDRATE"]);
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void PaidFloatingRate(Int32 pIdt)
        {
            string paidStreamRateType = Convert.ToString(Report.trade.dataDocument.business.swap.payerStream.streamRateType);
            string paidPeriodRateType = Convert.ToString(Report.trade.dataDocument.business.swap.payerStream.periodRateType);
            bool isInterpolatePayFloatRate = Convert.ToBoolean(Report.trade.dataDocument.business.swap.payerStream.isInterpolateFloatRate);
            string paidRateAssetCod;
            // Parameters
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "PAYSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamNumber);
            parameters.Add(new DataParameter(Cs, "PAIDRATEENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.payerStream.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            // IRS with floating rate period (standard)
            if (paidStreamRateType == "FLO" && paidPeriodRateType == "FLO")
            {
                // Not interpolate floating rate: it returns floating asset code (es.I0EURIB03M)
                if (isInterpolatePayFloatRate == false)
                {
                    sqlSelect += SQLCst.SELECT + "ar.IDENTIFIER as FLOATINGRATE, " + Cst.CrLf;
                    sqlSelect += "ar.EXTLLINK as ASSETCODE" + Cst.CrLf;
                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FLO'" + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @PAIDRATEENDDATE" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                    using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                    {
                        if (dr.Read())
                        {
                            Report.trade.dataDocument.business.swap.payerStream.floatRateAssetIdent = Convert.ToString(dr["FLOATINGRATE"]);
                            Report.trade.dataDocument.business.swap.payerStream.assetCode = Convert.ToString(dr["ASSETCODE"]);
                        }
                    }
                }

                // the stream is an interpolate floating rate
                if (isInterpolatePayFloatRate == true)
                {
                    sqlSelect += SQLCst.SELECT + "ed.RATE * 100 as FIXEDRATE " + Cst.CrLf;
                    sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FLO'" + Cst.CrLf;
                    sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                    sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @PAIDRATEENDDATE" + Cst.CrLf;
                    sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                    using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                    {
                        if (dr.Read())
                        {
                            paidRateAssetCod = "I";
                            Report.trade.dataDocument.business.swap.payerStream.assetCode = paidRateAssetCod;
                            Report.trade.dataDocument.business.swap.payerStream.fixedRate = Convert.ToDecimal(dr["FIXEDRATE"]);
                        }
                    }
                }
            }

            // IRS with fixed rate period (stub)
            if (paidStreamRateType == "FLO" && paidPeriodRateType == "FIX")
            {
                sqlSelect += SQLCst.SELECT + "ed.RATE * 100 as FIXEDRATE " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTTYPE  = 'FIX'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @PAIDRATEENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        paidRateAssetCod = "I";
                        Report.trade.dataDocument.business.swap.payerStream.assetCode = paidRateAssetCod;
                        Report.trade.dataDocument.business.swap.payerStream.fixedRate = Convert.ToDecimal(dr["FIXEDRATE"]);
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void ReceivedSpread(Int32 pIdt, string pTradeIdentifier)
        {
            string receivedStreamRateType = Convert.ToString(Report.trade.dataDocument.business.swap.receiverStream.streamRateType);

            if (receivedStreamRateType == "FLO")
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);
                parameters.Add(new DataParameter(Cs, "RECSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamNumber);

                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "min (e.DTENDUNADJ) as REC_SPREAD_ENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) >= @ENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                        Report.trade.dataDocument.business.swap.receiverStream.spreadEndDate = Convert.ToDateTime(dr["REC_SPREAD_ENDDATE"]);
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Spread assente nello stream del ricevente. Verificare gli eventi sul trade.";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                        Report.trade.dataDocument.business.swap.receiverStream.spreadEndDate = DateTime.MinValue;
                    }
                }

                parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "RECSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.receiverStream.streamNumber);
                parameters.Add(new DataParameter(Cs, "RECEIVEDSPREADENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.receiverStream.spreadEndDate);

                sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "ed.SPREAD * 100 as RECEIVED_SPREAD" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @RECSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @RECEIVEDSPREADENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        if (false == Convert.IsDBNull(dr["RECEIVED_SPREAD"]))
                            Report.trade.dataDocument.business.swap.receiverStream.spread = Convert.ToDecimal(dr["RECEIVED_SPREAD"]);
                    }
                    else
                    {
                        WarningMessage = "Spread assente nello stream del ricevente. Verificare gli eventi sul trade.";
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                        

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                        Report.trade.dataDocument.business.swap.receiverStream.spread = Decimal.Zero;
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void PaidSpread(Int32 pIdt, string pTradeIdentifier)
        {
            string paidStreamRateType = Convert.ToString(Report.trade.dataDocument.business.swap.payerStream.streamRateType);

            if (paidStreamRateType == "FLO")
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
                parameters.Add(new DataParameter(Cs, "PAYSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamNumber);

                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "min (e.DTENDUNADJ) as PAID_SPREAD_ENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) >= @ENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                        Report.trade.dataDocument.business.swap.payerStream.spreadEndDate = Convert.ToDateTime(dr["PAID_SPREAD_ENDDATE"]);
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Spread assente nello stream del pagante. Verificare gli eventi sul trade.";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                        Report.trade.dataDocument.business.swap.payerStream.spreadEndDate = DateTime.MinValue;
                    }
                }

                parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "PAYSTREAMNO", DbType.String), Report.trade.dataDocument.business.swap.payerStream.streamNumber);
                parameters.Add(new DataParameter(Cs, "PAIDSPREADENDDATE", DbType.Date), Report.trade.dataDocument.business.swap.payerStream.spreadEndDate);
                sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "ed.SPREAD * 100 as PAID_SPREAD" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "e.STREAMNO = @PAYSTREAMNO" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @PAIDSPREADENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        if (false == Convert.IsDBNull(dr["PAID_SPREAD"]))
                            Report.trade.dataDocument.business.swap.payerStream.spread = Convert.ToDecimal(dr["PAID_SPREAD"]);
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Spread assente nello stream del pagante. Verificare gli eventi sul trade.";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                        Report.trade.dataDocument.business.swap.payerStream.spread = Decimal.Zero;
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void CurrentNominalStepAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);
            //
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " eNos.VALORISATION as CURRENTNOMINALSTEPAMOUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eNos " + SQLCst.ON + "(eNos.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos.EVENTCODE = 'NOS' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos.DTENDADJ > @ENDDATE " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " eNos.STREAMNO = ( " + Cst.CrLf;
            sqlSelect += SQLCst.SELECT + " max(STREAMNO) " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eStream " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " eStream.IDT = eNos.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eStream.EVENTTYPE = 'NOM') " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos.DTENDADJ = (" + Cst.CrLf;
            sqlSelect += SQLCst.SELECT + " min (eNos2.DTENDADJ) " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eNos2 " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " eNos2.IDT = eNos.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos2.EVENTCODE = 'NOS' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos2.STREAMNO = eNos.STREAMNO " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos2.DTENDADJ > @ENDDATE ) " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                    Report.trade.dataDocument.business.swap.nominal.currentNominalStepAmount = Convert.ToDecimal(dr["CURRENTNOMINALSTEPAMOUNT"]);
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Nozionale corrente assente. Verificare gli eventi sul trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.swap.nominal.currentNominalStepAmount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void NotionalSchedule(Int32 pIdt, string pTradeIdentifier)
        {
            DateTime endDate = Report.trade.header.endDate;
            bool isOpen = Report.trade.header.isOpen;
            bool isOpenAndClosed = Report.trade.header.isOpenAndClosed;

            DataSet notionalScheduleDs = RetrieveNotionalSchedule(Cs, pIdt, endDate, isOpen, isOpenAndClosed);
            DataTable notionalScheduleDt = notionalScheduleDs.Tables[0];
            DataRow[] rows = notionalScheduleDt.Select();

            Report.trade.dataDocument.business.swap.nominal.notionalSchedule = new RegulatoryReportTradeDataDocumentBusinessSwapNominalNotionalSchedule[rows.Length];
            // Counter
            int i = 0;
            foreach (DataRow row in rows)
            {
                RegulatoryReportTradeDataDocumentBusinessSwapNominalNotionalSchedule step = new RegulatoryReportTradeDataDocumentBusinessSwapNominalNotionalSchedule
                {
                    stepEndDate = Convert.ToDateTime(row["NOTIONAL_STEP_END_DATE"]),
                    idc = Convert.ToString(row["NOTIONALVALUE_IDC"]),
                    uicCurrencyCode = Convert.ToString(row["NOTIONALVALUE_UIC"]),
                    amount = Convert.ToDecimal(row["NOTIONALVALUE_AMOUNT"])
                };
                if (step.idc != DomesticCurrency)
                {
                    string pIdc = step.idc;
                    decimal pIdcAmount = step.amount;
                    DateTime pFixingDate = Report.trade.header.endDate;
                    CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                    //              
                    if (info != null)
                    {
                        step.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessSwapNominalNotionalScheduleCounterValueAmount
                        {
                            idc1 = info.Idc1,
                            idc2 = info.Idc2,
                            quoteBasis = info.QuoteBasis,
                            fixingDate = info.FixingDate,
                            value = info.CounterValue,
                            fxAsset = GetFxAssetIdentifier(info.IdAsset),
                            fxQuotation = info.Quotation
                        };
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
                step.id = Convert.ToString("notionalSchedule") + Convert.ToString(i);
                Report.trade.dataDocument.business.swap.nominal.notionalSchedule[i] = step;
                i++;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private void RemainingDurationRatio()
        {
            DateTime endDate = Report.trade.header.endDate;
            Decimal remainingDurationRatio = Decimal.Zero; // defaul value for date difference <= 365 days

            for (int index = 0; index < Report.trade.dataDocument.business.swap.nominal.notionalSchedule.Length; index++)
            {
                DateTime stepEndDate = Report.trade.dataDocument.business.swap.nominal.notionalSchedule[index].stepEndDate;
                UInt16 dateDifference = Convert.ToUInt16(stepEndDate.Subtract(endDate).Days);

                if ((dateDifference <= 1825) && (dateDifference > 365))
                    remainingDurationRatio = 0.005M;
                if (dateDifference > 1825)
                    remainingDurationRatio = 0.015M;

                Report.trade.dataDocument.business.swap.nominal.notionalSchedule[index].remainingDurationDay = dateDifference;
                Report.trade.dataDocument.business.swap.nominal.notionalSchedule[index].remainingDurationRatio = remainingDurationRatio;

            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void ZeroCouponStreamInformation(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " t.EXTLLINK as ZEROCOUPONRATE, e.STREAMNO as STREAMNO, e.IDA_PAY as IDAPAY, e.IDA_REC as IDAREC, ec.DTEVENT as PERIODSTARTDATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'IRS' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'KNA' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS = 'GRP' " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    DateTime periodStartDate = Convert.ToDateTime(dr["PERIODSTARTDATE"]);
                    ushort elapsedDays = Convert.ToUInt16(EndDate.Subtract(periodStartDate).Days);
                    decimal currentNotional = Report.trade.dataDocument.business.swap.nominal.currentNominalStepAmount;

                    if (false == Convert.IsDBNull(dr["ZEROCOUPONRATE"]))
                    {
                        string rateAssetCod = "F";

                        string zeroCouponRateString = Convert.ToString(dr["ZEROCOUPONRATE"]);
                        decimal zeroCouponRate = Decimal.Parse(zeroCouponRateString, CultureInfo.InvariantCulture);

                        double aValue = Convert.ToDouble((zeroCouponRate / 100) + 1);
                        int daysInYear = GetDaysInYear(EndDate.Year);
                        double bValue = Convert.ToDouble(elapsedDays / daysInYear);
                        decimal result = currentNotional * Convert.ToDecimal(Math.Pow(aValue, bValue) - 1);
                        //
                        if (Report.trade.dataDocument.business.swap.receiverStream.streamRateType == "KNA")
                        {
                            Report.trade.dataDocument.business.swap.receiverStream.streamNumber = Convert.ToByte(dr["STREAMNO"]);
                            Report.trade.dataDocument.business.swap.receiverStream.elapsedDays = elapsedDays;
                            Report.trade.dataDocument.business.swap.receiverStream.fixedRate = zeroCouponRate;
                            Report.trade.dataDocument.business.swap.receiverStream.assetCode = rateAssetCod;
                            Report.trade.dataDocument.business.swap.receiverStream.accruedInterest = result;
                        }

                        if (Report.trade.dataDocument.business.swap.payerStream.streamRateType == "KNA")
                        {
                            Report.trade.dataDocument.business.swap.payerStream.streamNumber = Convert.ToByte(dr["STREAMNO"]);
                            Report.trade.dataDocument.business.swap.payerStream.elapsedDays = elapsedDays;
                            Report.trade.dataDocument.business.swap.payerStream.fixedRate = zeroCouponRate;
                            Report.trade.dataDocument.business.swap.payerStream.assetCode = rateAssetCod;
                            Report.trade.dataDocument.business.swap.payerStream.accruedInterest = result;
                        }
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Tasso zero coupon non presente. valorizzare il campo richiesto sul trade.";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void Upfront(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.IDA_PAY as IDAPAY, e.IDA_REC as IDAREC, ec.DTEVENT as SETTLEMENTDATE, e.UNIT as IDC, e.VALORISATION as AMOUNT " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(e.IDE = ec.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'ADP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'UPF' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS = 'STL' " + Cst.CrLf;
           
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["SETTLEMENTDATE"]))
                    {
                        Report.trade.dataDocument.business.swap.InstantiateUpFront();
                        Report.trade.dataDocument.business.swap.upfront.idaPay = Convert.ToUInt16(dr["IDAPAY"]);
                        Report.trade.dataDocument.business.swap.upfront.idaRec = Convert.ToUInt16(dr["IDAREC"]);
                        Report.trade.dataDocument.business.swap.upfront.settlementDate = Convert.ToDateTime(dr["SETTLEMENTDATE"]);
                        Report.trade.dataDocument.business.swap.upfront.idc = Convert.ToString(dr["IDC"]);
                        Report.trade.dataDocument.business.swap.upfront.amount = Convert.ToDecimal(dr["AMOUNT"]);

                        if (Report.trade.dataDocument.business.swap.upfront.idc != DomesticCurrency)
                        {
                            string pIdc = Report.trade.dataDocument.business.swap.upfront.idc;
                            decimal pIdcAmount = Report.trade.dataDocument.business.swap.upfront.amount;
                            DateTime pFixingDate = Report.trade.header.endDate;
                            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);

                            if (info != null)
                            {
                                Report.trade.dataDocument.business.swap.upfront.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessSwapUpfrontCounterValueAmount
                                {
                                    idc1 = info.Idc1,
                                    idc2 = info.Idc2,
                                    quoteBasis = info.QuoteBasis,
                                    fixingDate = info.FixingDate,
                                    value = info.CounterValue,
                                    fxAsset = GetFxAssetIdentifier(info.IdAsset),
                                    fxQuotation = info.Quotation
                                };
                            }
                            else
                            {
                                // FI 20200623 [XXXXX] SetErrorWarning
                                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                                
                                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected override void LinearDepreciationClosingDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "max (ec.DTEVENT) as CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'UPF' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'LDP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT <= @ENDDATE " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                // here we istantiate the classes for linear depreciation
                Report.trade.dataDocument.business.closingEvents.InstantiateLinearDepreciation();

                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CLOSINGDATE"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = Convert.ToDateTime(dr["CLOSINGDATE"]);
                    }
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Chiusura ammortamento lineare upfront non disponibile. Eseguire il trattamento.";
                    
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = DateTime.MinValue;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationReceived(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'UPF' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationPaid(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'UPF' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationNetted()
        {
            decimal received = Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount;
            decimal paid = Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount;
            decimal netted = (received) - (paid);
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationRemaining()
        {

            UInt16 mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
            decimal upfront = Report.trade.dataDocument.business.swap.upfront.amount;
            UInt16 upfrontIdaPay = Report.trade.dataDocument.business.swap.upfront.idaPay;
            UInt16 upfrontIdaRec = Report.trade.dataDocument.business.swap.upfront.idaRec;
            //
            decimal nettedLinearDepreciation = Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount;
            decimal LinearDepreciationRemainingAmount = Decimal.Zero;
            // il temporaryRemainingAmount  sempre negativo 
            decimal temporaryRemainingAmount = nettedLinearDepreciation - upfront;
            // quando l'upfront  pagato dal mainactor il remaining  positivo perch  un risconto attivo                
            if (upfrontIdaPay == mainActorIda)
                LinearDepreciationRemainingAmount = Decimal.Negate(temporaryRemainingAmount);
            // quando l'upfront  ricevuto dal mainactor il remaining  negativo perch  un risconto passivo 
            if (upfrontIdaRec == mainActorIda)
                LinearDepreciationRemainingAmount = temporaryRemainingAmount;
            //
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount = LinearDepreciationRemainingAmount;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void IntrinsicValue()
        {
            int n = Report.trade.dataDocument.business.swap.nominal.notionalSchedule.Length;
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule[n];
            //
            bool isAmortizing = Report.trade.dataDocument.business.swap.isAmortizing;
            decimal currentNominalStepAmount = Report.trade.dataDocument.business.swap.nominal.currentNominalStepAmount;
            //
            decimal mtmCleanPrice = Decimal.Zero;
            decimal accruedInterest = Decimal.Zero;
            decimal linearDepreciationRemaining = Decimal.Zero;

            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                mtmCleanPrice = Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount;

            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.accruedInterest)
                accruedInterest = Report.trade.dataDocument.business.closingEvents.accruedInterest.nettedAmount;

            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.linearDepreciation)
                linearDepreciationRemaining = Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount;

            // calc MTM dirtyPrice (use by IAS intrinsic value)
            decimal mtmDirtyPrice = mtmCleanPrice + accruedInterest + linearDepreciationRemaining;

            // create a intrinsic value for each notional schedule (for each elementary trade)
            for (int i = 0; i < Report.trade.dataDocument.business.swap.nominal.notionalSchedule.Length; i++)
            {
                decimal notionalAmount = Report.trade.dataDocument.business.swap.nominal.notionalSchedule[i].amount;
                DateTime nominalStepDate = Report.trade.dataDocument.business.swap.nominal.notionalSchedule[i].stepEndDate;
                //
                RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule vi = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule();
                if (isAmortizing == true)
                {
                    vi.amount = notionalAmount * (mtmCleanPrice / currentNominalStepAmount);
                    vi.amountIAS = notionalAmount * (mtmDirtyPrice / currentNominalStepAmount);
                }
                else if (isAmortizing == false)
                {
                    vi.amount = mtmCleanPrice;
                    vi.amountIAS = mtmDirtyPrice;
                }
                // add nominal step date from nominal schedule
                vi.stepDate = nominalStepDate;
                //
                Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[i] = vi;
                vi.id = Convert.ToString("intrinsicValue") + Convert.ToString(i);
            }
        }

        /// <summary>
        /// Call all methods to feed report business section for swap 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pDerivate"></param>
        /// <param name="pDerivativeBeginDate"></param>
        /// <param name="pActorRepositoryStyle"></param>
        public override void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle)
        {
            this.MainBusinessInfo(pIdt);
            //
            string tradeIdentifier = Report.trade.header.identifier;
            this.IsInTheScope(pIdt);
            this.CheckAccountingCategories(pIdt);
            //
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            //
            if (isInTheScope == true)
            {
                this.Repository(pIdt);
                this.AgreementExists(out bool agreementExists);
                if (agreementExists)
                {
                    Report.trade.dataDocument.repository.InstantiateMasterAgreement();
                    Report.trade.dataDocument.repository.masterAgreement.isAgreement = true;
                    this.MasterAgreement();
                }

                this.Ndg(pActorRepositoryStyle, tradeIdentifier);
                this.NdgFactorization(pActorRepositoryStyle, tradeIdentifier);
                this.UicCountryCode(tradeIdentifier);
                this.MifidClientCategorisation(tradeIdentifier);
                this.IasDerivativeClassification(tradeIdentifier);
                this.IasHedgedDerivativeClassification(pIdt);
                Report.trade.dataDocument.business.InstantiateSwap();
                this.CheckStructuredProducts();
                this.StructuredProduct();
                this.ProductType(pIdt, tradeIdentifier);
                this.NextResetDate(pIdt);
                this.IsOvernight(pIdt);
                this.IsAmortizing(pIdt);
                this.StreamRateType(pIdt);
                this.EnableStreamObjects();
                this.StreamNumber(pIdt);
                this.ReceivedRateEndDate(pIdt);
                this.PaidRateEndDate(pIdt);
                this.IsInterpolateRecFloatRate(pIdt);
                this.IsInterpolatePayFloatRate(pIdt);
                this.ReceivedFixedRate(pIdt);
                this.PaidFixedRate(pIdt);
                this.ReceivedFloatingRate(pIdt);
                this.PaidFloatingRate(pIdt);
                this.ReceivedSpread(pIdt, tradeIdentifier);
                this.PaidSpread(pIdt, tradeIdentifier);
                this.CurrentNominalStepAmount(pIdt, tradeIdentifier);
                this.NotionalSchedule(pIdt, tradeIdentifier);
                this.RemainingDurationRatio();
                if (Report.trade.dataDocument.business.swap.productType == "SWAP-ZERO-COUPON" || InstrumentIdentifier == "ZeroCouponSwap")
                    this.ZeroCouponStreamInformation(pIdt, tradeIdentifier);
                this.Upfront(pIdt, tradeIdentifier);
                //
                if (pDerivate == true && pDerivativeBeginDate != DateTime.MinValue)
                {

                    string product = Report.trade.header.productIdentifier;

                    this.ExchangedCleanCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ExchangedGrossCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ForwardCleanCashFlows(pIdt, tradeIdentifier, product);
                    this.ForwardGrossCashFlows(pIdt, tradeIdentifier, product);
                }
                // valorize closing events only if the trade is open: 
                // if the trade is open and closed this section will be ignored
                if (pIsOpen == true)
                {
                    this.ClosingMTMDate(pIdt, out DateTime closingDate);

                    // if the closing MTM exists valorize the other events
                    if (closingDate != DateTime.MinValue)
                    {
                        Report.trade.dataDocument.business.InstantiateClosingEvents();
                        Report.trade.dataDocument.business.closingEvents.closingDate = closingDate;
                        Report.trade.dataDocument.business.closingEvents.InstantiateMarkToMarket();
                        this.MTM(pIdt);
                        this.MTMNetted();
                        //
                        Report.trade.dataDocument.business.closingEvents.InstantiateAccruedInterest();
                        this.AccruedInterest(pIdt, tradeIdentifier);
                        this.AccruedInterestNetted();
                        //
                        if (null != Report.trade.dataDocument.business.swap.upfront)
                        {
                            if (Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING" || Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING+")
                            {
                                // if exists a closing date we instantiale the classes linear depreciation and linear depreciation remaining into LinearDepreciationClosingDate() void. 
                                this.LinearDepreciationClosingDate(pIdt);

                                if (Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate != DateTime.MinValue)
                                {
                                    this.LinearDepreciationReceived(pIdt);
                                    this.LinearDepreciationPaid(pIdt);
                                    this.LinearDepreciationNetted();
                                    this.LinearDepreciationRemaining();
                                }
                            }
                        }
                        Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
                        this.IntrinsicValue();
                    }
                    // trade is discard (out of the scope) if closingDate is missing
                    else
                    {
                        Report.trade.header.isInTheScope = false;
                }
            }
        }
    }
    }

    /// <summary>
    /// Feed report business section for cap  
    /// </summary>
    public class RRBusinessCap : RRBusiness
    {
        public RRBusinessCap(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
            : base(pCs, pDomesticCurrency, pProcess, pReport, pBeginDate, pEndDate, pOpenAndClosedBeginDate, pDerivativeBeginDate, pInstrumentIdentifier, pActorRepositoryStyle)
        {
        }

        /// <summary>
        /// Discard out-of-the-scope trades for:
        /// capFloor with not EUR notional amount currency
        /// capFloor with roller coaster notional
        /// capFloor without closing events at the extraction period
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void IsInTheScope(Int32 pIdt)
        {
            // capFloor with not EUR notional amount currency is out-of-the-scope
            DataParameters parameters01 = new DataParameters();
            parameters01.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect01 = new StrBuilder();
            sqlSelect01 += SQLCst.SELECT + "count (*) as OUTOFTHESCOPE" + Cst.CrLf;
            sqlSelect01 += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect01 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "e.EVENTCODE= 'STA'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "e.EVENTTYPE = 'NOM'" + Cst.CrLf;
            sqlSelect01 += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "e.UNIT != 'EUR'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "e.STREAMNO = (" + Cst.CrLf;
            sqlSelect01 += SQLCst.SELECT + "max(STREAMNO)" + Cst.CrLf;
            sqlSelect01 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eStream " + Cst.CrLf;
            sqlSelect01 += SQLCst.WHERE + "eStream.IDT = @IDT" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eStream.EVENTTYPE = 'NOM')" + Cst.CrLf;
            DataSet ds01 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect01.ToString(), parameters01.GetArrayDbParameter());
            DataTable dt01 = ds01.Tables[0];
            DataRow[] rows01 = dt01.Select();
            DataRow row01 = rows01[0];
            bool isInTheScope = true;
            Int16 count = Convert.ToInt16(row01["OUTOFTHESCOPE"]);
            if (count != 0)
            {
                isInTheScope = false;
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Trade scartato (out of the scope): divisa del nozionale diversa da EURO.";

                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
            Report.trade.header.isInTheScope = isInTheScope;

            // capFloor with roller coaster notional is out-of-the-scope 
            if (isInTheScope == true)
            {
                DataParameters parameters02 = new DataParameters();
                parameters02.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                StrBuilder sqlSelect02 = new StrBuilder();
                sqlSelect02 += SQLCst.SELECT + "count (*) as OUTOFTHESCOPE" + Cst.CrLf;
                sqlSelect02 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
                sqlSelect02 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "ec.EVENTCLASS = 'GRP'" + Cst.CrLf;
                sqlSelect02 += SQLCst.WHERE + " e.EVENTCODE = 'CFL' " + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e.IDT = @IDT" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "exists (" + Cst.CrLf;
                sqlSelect02 += SQLCst.SELECT + "1" + Cst.CrLf;
                sqlSelect02 += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e2 " + Cst.CrLf;
                sqlSelect02 += SQLCst.WHERE + "e2.IDT = e.IDT" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.STREAMNO = e.STREAMNO" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.EVENTCODE in ('INT', 'TER', 'TEI')" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.EVENTTYPE = 'NOM'" + Cst.CrLf;
                sqlSelect02 += SQLCst.AND + "e2.IDA_PAY != e.IDA_PAY )" + Cst.CrLf;
                DataSet ds02 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect02.ToString(), parameters02.GetArrayDbParameter());
                DataTable dt02 = ds02.Tables[0];
                DataRow[] rows02 = dt02.Select();
                DataRow row02 = rows02[0];
                //
                count = Convert.ToInt16(row02["OUTOFTHESCOPE"]);
                if (count != 0)
                {
                    // GS 20131210: temporary update (in use only for Bancaperta) 
                    // waiting to implement the roller-coaster notional factorization algorithm
                    // Client ask to remove the 'out-of-the-scope' filter for the trades with roller coaster notional 
                    // No filter is applied for IRD roller coaster
                    // A record is drawn into export file for each roller coaster elementary trade
                    // back-office operators make manual changes on the missing or wrong data
                    isInTheScope = true;
                    //WarningMessage = "Trade scartato (out of the scope): nozionale di tipo roller coaster.";
                    //Process.ProcessLogAddDetail(ProcessStateTools.StatusWarningEnum, WarningMessage);
                }
                Report.trade.header.isInTheScope = isInTheScope;
            }

            // capFloor without closing events at the extraction period is out-of-the-scope
            if (isInTheScope == true)
            {
                DataParameters parameters03 = new DataParameters();
                parameters03.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters03.Add(new DataParameter(Cs, "BEGINDATE", DbType.DateTime), Report.trade.header.beginDate);
                parameters03.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
                StrBuilder sqlSelect03 = new StrBuilder();
                sqlSelect03 += SQLCst.SELECT + "count (*) as ISINTHESCOPE" + Cst.CrLf;
                sqlSelect03 += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect03 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eMtm " + SQLCst.ON + "(eMtm.IDT = t.IDT)" + Cst.CrLf;
                sqlSelect03 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "(ecMtm.IDE = eMtm.IDE)" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "ecMtm.EVENTCLASS = 'CLN'" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "ecMtm.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
                sqlSelect03 += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "eMtM.EVENTCODE = 'CLO'" + Cst.CrLf;
                sqlSelect03 += SQLCst.AND + "eMtM.EVENTTYPE = 'MTM'" + Cst.CrLf;
                DataSet ds03 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect03.ToString(), parameters03.GetArrayDbParameter());
                DataTable dt03 = ds03.Tables[0];
                DataRow[] rows03 = dt03.Select();
                DataRow row03 = rows03[0];
                count = Convert.ToInt16(row03["ISINTHESCOPE"]);
                if (count == 0)
                {
                    isInTheScope = false;
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Trade scartato (out of the scope): Nessun evento di chiusura per il periodo di osservazione.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
                Report.trade.header.isInTheScope = isInTheScope;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void ProductType(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "EVENTTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.EVENTCODE = 'CFL'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    string eventType = Convert.ToString(dr["EVENTTYPE"]);
                    if (eventType == "CAP")
                        Report.trade.dataDocument.business.capFloor.productType = "CAP";
                    if (eventType == "FLR")
                        Report.trade.dataDocument.business.capFloor.productType = "FLOOR";
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo prodotto non valorizzato. Verificare gli eventi del trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.capFloor.productType = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void IsOvernight(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "count (*) as ISOVERNIGHT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.RATEINDEX + " ri " + SQLCst.ON + "(ar.IDRX = ri.IDRX)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ri.RATETYPE = 'OVERNIGHT'" + Cst.CrLf;
            //dataset
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            //Come controllo prima di estrarre la riga verifica che ce ne sia una sola: se + di una allora eccezione
            DataRow row = rows[0];
            // if count = 0 isn't a overnight / if count = 1 is a overnight
            bool isOverNight = false;
            Int16 count = Convert.ToInt16(row["ISOVERNIGHT"]);
            if (count != 0)
                isOverNight = true;
            Report.trade.dataDocument.business.capFloor.isOvernight = isOverNight;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void IsAmortizing(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "count (*) as ISAMORTIZING" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'INT'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'NOM'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            Int16 count = Convert.ToInt16(row["ISAMORTIZING"]);
            bool isAmortizing = false;
            if (count > 0)
                isAmortizing = true;
            Report.trade.dataDocument.business.capFloor.isAmortizing = isAmortizing;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void NextResetDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.DateTime), Report.trade.header.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "MIN (ec.DTEVENT) as NEXT_RESET_DATE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(e.IDE = ec.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'RES'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.eventclass = 'GRP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.DTEVENT > @ENDDATE" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            if (false == Convert.IsDBNull(row["NEXT_RESET_DATE"]))
                Report.trade.dataDocument.business.capFloor.nextResetDate = Convert.ToDateTime(row["NEXT_RESET_DATE"]);
            // case handled last calculation period: if next reset date is null returns termination date
            else Report.trade.dataDocument.business.capFloor.nextResetDate = Report.trade.header.terminationDate;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void CurrentNominalStepAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);
            //
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " eNos.VALORISATION as CURRENTNOMINALSTEPAMOUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eNos " + SQLCst.ON + "(eNos.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos.EVENTCODE = 'NOS' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos.DTENDADJ > @ENDDATE " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " eNos.STREAMNO = ( " + Cst.CrLf;
            sqlSelect += SQLCst.SELECT + " max(STREAMNO) " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eStream " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " eStream.IDT = eNos.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eStream.EVENTTYPE = 'NOM') " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos.DTENDADJ = (" + Cst.CrLf;
            sqlSelect += SQLCst.SELECT + " min (eNos2.DTENDADJ) " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eNos2 " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " eNos2.IDT = eNos.IDT " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos2.EVENTCODE = 'NOS' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " eNos2.DTENDADJ > @ENDDATE ) " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                    Report.trade.dataDocument.business.capFloor.nominal.currentNominalStepAmount = Convert.ToDecimal(dr["CURRENTNOMINALSTEPAMOUNT"]);
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Nozionale corrente non valorizzato. Verificare gli eventi del trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.capFloor.nominal.currentNominalStepAmount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void NotionalSchedule(Int32 pIdt, string pTradeIdentifier)
        {
            DateTime endDate = Report.trade.header.endDate;
            bool isOpen = Report.trade.header.isOpen;
            bool isOpenAndClosed = Report.trade.header.isOpenAndClosed;

            DataSet notionalScheduleDs = RetrieveNotionalSchedule(Cs, pIdt, endDate, isOpen, isOpenAndClosed);
            DataTable notionalScheduleDt = notionalScheduleDs.Tables[0];
            DataRow[] rows = notionalScheduleDt.Select();

            Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule = new RegulatoryReportTradeDataDocumentBusinessCapFloorNominalNotionalSchedule[rows.Length];

            int i = 0;
            foreach (DataRow row in rows)
            {
                RegulatoryReportTradeDataDocumentBusinessCapFloorNominalNotionalSchedule step = new RegulatoryReportTradeDataDocumentBusinessCapFloorNominalNotionalSchedule
                {
                    stepEndDate = Convert.ToDateTime(row["NOTIONAL_STEP_END_DATE"]),
                    idc = Convert.ToString(row["NOTIONALVALUE_IDC"]),
                    uicCurrencyCode = Convert.ToString(row["NOTIONALVALUE_UIC"]),
                    amount = Convert.ToDecimal(row["NOTIONALVALUE_AMOUNT"])
                };

                if (step.idc != DomesticCurrency)
                {
                    string pIdc = step.idc;
                    decimal pIdcAmount = step.amount;
                    DateTime pFixingDate = Report.trade.header.endDate;
                    CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                    //
                    if (info != null)
                    {
                        step.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessCapFloorNominalNotionalScheduleCounterValueAmount
                        {
                            idc1 = info.Idc1,
                            idc2 = info.Idc2,
                            quoteBasis = info.QuoteBasis,
                            fixingDate = info.FixingDate,
                            value = info.CounterValue,
                            fxAsset = GetFxAssetIdentifier(info.IdAsset),
                            fxQuotation = info.Quotation
                        };
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
                step.id = Convert.ToString("notionalSchedule") + Convert.ToString(i);
                Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[i] = step;
                i++;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private void RemainingDurationRatio()
        {
            DateTime endDate = Report.trade.header.endDate;
            Decimal remainingDurationRatio = Decimal.Zero; // defaul value for date difference <= 365 days

            for (int index = 0; index < Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length; index++)
            {
                DateTime stepEndDate = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[index].stepEndDate;
                UInt16 dateDifference = Convert.ToUInt16(stepEndDate.Subtract(endDate).Days);

                if ((dateDifference <= 1825) && (dateDifference > 365))
                    remainingDurationRatio = 0.005M;
                if (dateDifference > 1825)
                    remainingDurationRatio = 0.015M;

                Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[index].remainingDurationDay = dateDifference;
                Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[index].remainingDurationRatio = remainingDurationRatio;

            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        private void CapFloorStreamEndDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "min (e.DTENDUNADJ) as CAPFLOORSTREAM_ENDDATE,  min(e.IDA_PAY) as IDAPAY, min(IDA_REC) as IDAREC" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE  =  'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) >= @ENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            //
            Report.trade.dataDocument.business.capFloor.capFloorStream.endDate = Convert.ToDateTime(row["CAPFLOORSTREAM_ENDDATE"]);
            // IDA PAY
            Report.trade.dataDocument.business.capFloor.capFloorStream.payerIda = Convert.ToUInt16(row["IDAPAY"]);
            if (Report.trade.dataDocument.repository.mainActor.ida == Report.trade.dataDocument.business.capFloor.capFloorStream.payerIda)
                Report.trade.dataDocument.business.capFloor.capFloorStream.payerIdentifier = Report.trade.dataDocument.repository.mainActor.identifier;
            else
                Report.trade.dataDocument.business.capFloor.capFloorStream.payerIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
            // IDA REC
            Report.trade.dataDocument.business.capFloor.capFloorStream.receiverIda = Convert.ToUInt16(row["IDAREC"]);
            if (Report.trade.dataDocument.repository.mainActor.ida == Report.trade.dataDocument.business.capFloor.capFloorStream.receiverIda)
                Report.trade.dataDocument.business.capFloor.capFloorStream.receiverIdentifier = Report.trade.dataDocument.repository.mainActor.identifier;
            else
                Report.trade.dataDocument.business.capFloor.capFloorStream.receiverIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void Strike(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "CAPFLOORSTREAMENDDATE", DbType.Date), Report.trade.dataDocument.business.capFloor.capFloorStream.endDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "(ed.STRIKEPRICE * 100) as STRIKEPRICE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ( e.EVENTTYPE  in ('CAS','FLS')" + SQLCst.OR + "e.EVENTTYPE  in ('CAB','FLB') )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @CAPFLOORSTREAMENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["STRIKEPRICE"]))
                        Report.trade.dataDocument.business.capFloor.capFloorStream.spread = Convert.ToDecimal(dr["STRIKEPRICE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                    
                    WarningMessage = "Strike non valorizzato. Verificare il trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.capFloor.capFloorStream.strike = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void FloatingRate(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CAPFLOORSTREAMENDDATE", DbType.DateTime), Report.trade.dataDocument.business.capFloor.capFloorStream.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ar.IDENTIFIER as FLOATRATE_ASSETIDENTIFIER, ar.EXTLLINK  as FLOATRATE_ASSETCODE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "(ea.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "(ar.IDASSET = ea.IDASSET)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @CAPFLOORSTREAMENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["FLOATRATE_ASSETIDENTIFIER"]))
                        Report.trade.dataDocument.business.capFloor.capFloorStream.floatRateAssetIdent = Convert.ToString(dr["FLOATRATE_ASSETIDENTIFIER"]);
                    if (false == Convert.IsDBNull(dr["FLOATRATE_ASSETCODE"]))
                        Report.trade.dataDocument.business.capFloor.capFloorStream.assetCode = Convert.ToString(dr["FLOATRATE_ASSETCODE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Floating rate non valorizzato. Verificare gli eventi del trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.capFloor.capFloorStream.floatRateAssetIdent = String.Empty;
                    Report.trade.dataDocument.business.capFloor.capFloorStream.assetCode = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void Spread(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CAPFLOORSTREAMENDDATE", DbType.DateTime), Report.trade.dataDocument.business.capFloor.capFloorStream.endDate);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.DTENDUNADJ as SPREAD_ENDDATE, ed.SPREAD * 100 as SPREAD" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'PER'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'FLO'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.DTENDUNADJ) = @CAPFLOORSTREAMENDDATE" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["SPREAD_ENDDATE"]))
                        Report.trade.dataDocument.business.capFloor.capFloorStream.spreadEndDate = Convert.ToDateTime(dr["SPREAD_ENDDATE"]);
                    if (false == Convert.IsDBNull(dr["SPREAD"]))
                        Report.trade.dataDocument.business.capFloor.capFloorStream.spread = Convert.ToDecimal(dr["SPREAD"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void Premium(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ec.DTEVENT as PAYMENTDATE, e.IDA_PAY as IDAPAY, e.IDA_REC as IDAREC, e.UNIT as IDC, extl.VALUE as UIC, e.VALORISATION as AMOUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'LPP'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'PRM'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS = 'STL'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            Report.trade.dataDocument.business.capFloor.premium = new RegulatoryReportTradeDataDocumentBusinessCapFloorPremium[rows.Length];
            int index = 0;
            foreach (DataRow row in rows)
            {
                RegulatoryReportTradeDataDocumentBusinessCapFloorPremium premium = new RegulatoryReportTradeDataDocumentBusinessCapFloorPremium
                {
                    paymentDate = Convert.ToDateTime(row["PAYMENTDATE"]),
                    payerIda = Convert.ToUInt16(row["IDAPAY"]),
                    receiverIda = Convert.ToUInt16(row["IDAREC"]),
                    idc = Convert.ToString(row["IDC"]),
                    uicCurrencyCode = Convert.ToString(row["UIC"]),
                    amount = Convert.ToDecimal(row["AMOUNT"])
                };
                uint mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
                string mainActorIdentifier = Report.trade.dataDocument.repository.mainActor.identifier;
                uint counterpartyIda = Report.trade.dataDocument.repository.counterparty.ida;
                string counterpartyIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
                // PayerIdentifier
                if (mainActorIda == premium.payerIda)
                    premium.payerIdentifier = mainActorIdentifier;
                else
                    premium.payerIdentifier = counterpartyIdentifier;
                // ReceiverIdenfier
                if (mainActorIda == premium.receiverIda)
                    premium.receiverIdentifier = mainActorIdentifier;
                else
                    premium.receiverIdentifier = counterpartyIdentifier;
                // MainActor Buyer Seller
                if (premium.payerIda == mainActorIda)
                    premium.mainActorPayerReceiver = "PAY";
                else if (premium.receiverIda == mainActorIda)
                    premium.mainActorPayerReceiver = "REC";
                // countervalue section
                if (premium.idc != DomesticCurrency)
                {
                    string pIdc = premium.idc;
                    decimal pIdcAmount = premium.amount;
                    DateTime pFixingDate = Report.trade.header.endDate;
                    CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                    //
                    if (info != null)
                    {
                        premium.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessCapFloorPremiumCounterValueAmount
                        {
                            idc1 = info.Idc1,
                            idc2 = info.Idc2,
                            quoteBasis = info.QuoteBasis,
                            fixingDate = info.FixingDate,
                            value = info.CounterValue,
                            fxAsset = GetFxAssetIdentifier(info.IdAsset),
                            fxQuotation = info.Quotation
                        };
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";
                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
                premium.id = "premium" + Convert.ToString(index);
                Report.trade.dataDocument.business.capFloor.premium[index] = premium;
                index++;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected override void LinearDepreciationClosingDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "max (ec.DTEVENT) as CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'LDP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT <= @ENDDATE " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                // here we istantiate the classes for linear depreciation
                Report.trade.dataDocument.business.closingEvents.InstantiateLinearDepreciation();

                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CLOSINGDATE"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = Convert.ToDateTime(dr["CLOSINGDATE"]);
                    }
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Chiusura per l'ammortamento lineare del premio non disponibile. Eseguire il trattamento.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = DateTime.MinValue;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationReceived(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationPaid(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationNetted()
        {
            decimal received = Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount;
            decimal paid = Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount;
            decimal netted = (received) - (paid);
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationRemaining()
        {
            UInt16 mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
            decimal totalPremium = Decimal.Zero;
            UInt16 premiumIdaPay = Report.trade.dataDocument.business.capFloor.premium[0].payerIda;
            UInt16 premiumIdaRec = Report.trade.dataDocument.business.capFloor.premium[0].receiverIda;
            decimal nettedLinearDepreciation = Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount;
            decimal LinearDepreciationRemainingAmount = Decimal.Zero;
            //
            for (int i = 0; i < Report.trade.dataDocument.business.capFloor.premium.Length; i++)
            {
                totalPremium += Report.trade.dataDocument.business.capFloor.premium[i].amount;
            }
            // il temporaryRemainingAmount  sempre negativo
            decimal temporaryRemainingAmount = nettedLinearDepreciation - totalPremium;
            // quando il premio  pagato dal mainactor il remaining  positivo perch  un risconto attivo                
            if (premiumIdaPay == mainActorIda)
                LinearDepreciationRemainingAmount = Decimal.Negate(temporaryRemainingAmount);
            // quando il premio  ricevuto dal mainactor il remaining  negativo perch  un risconto passivo 
            if (premiumIdaRec == mainActorIda)
                LinearDepreciationRemainingAmount = temporaryRemainingAmount;
            //
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount = LinearDepreciationRemainingAmount;

        }

        /// <summary>
        /// 
        /// </summary>
        protected override void IntrinsicValue()
        {
            int n = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length;
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule[n];
            //
            bool isAmortizing = Report.trade.dataDocument.business.capFloor.isAmortizing;
            decimal currentNominalStepAmount = Report.trade.dataDocument.business.capFloor.nominal.currentNominalStepAmount;
            //
            decimal mtmCleanPrice = Decimal.Zero;
            decimal accruedInterest = Decimal.Zero;
            decimal linearDepreciationRemaining = Decimal.Zero;
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                mtmCleanPrice = Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount;
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.accruedInterest)
                accruedInterest = Report.trade.dataDocument.business.closingEvents.accruedInterest.nettedAmount;
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.linearDepreciation)
                linearDepreciationRemaining = Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount;
            // calc MTM dirtyPrice (use by IAS intrinsic value)
            decimal mtmDirtyPrice = (mtmCleanPrice) + (accruedInterest) + (linearDepreciationRemaining);
            // create a intrinsic value for each notional schedule (for each elementary trade)
            for (int i = 0; i < Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length; i++)
            {
                decimal notionalAmount = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[i].amount;
                DateTime nominalStepDate = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[i].stepEndDate;
                //
                RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule vi = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule();
                if (isAmortizing == true)
                {
                    vi.amount = notionalAmount * (mtmCleanPrice / currentNominalStepAmount);
                    vi.amountIAS = notionalAmount * (mtmDirtyPrice / currentNominalStepAmount);
                }
                else if (isAmortizing == false)
                {
                    vi.amount = mtmCleanPrice;
                    vi.amountIAS = mtmDirtyPrice;
                }
                // add nominal step date from nominal schedule
                vi.stepDate = nominalStepDate;
                //
                Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[i] = vi;
                vi.id = Convert.ToString("intrinsicValue") + Convert.ToString(i);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <returns></returns>
        private int CountCapLetsFloorLetsSteps(Int32 pIdt)
        {
            int totalCount = 0;

            for (int notionalScheduleIndex = 0; notionalScheduleIndex < Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length; notionalScheduleIndex++)
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
                parameters.Add(new DataParameter(Cs, "NOTIONALSTEPENDDATE", DbType.Date), Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[notionalScheduleIndex].stepEndDate); // FI 20201006 [XXXXX] DbType.Date
                //
                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "count(*) as INTERESTPERIOD" + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eInt " + SQLCst.ON + "( eInt.IDT = t.IDT )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eInt.DTENDUNADJ between @ENDDATE and @NOTIONALSTEPENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecInt " + SQLCst.ON + "(eInt.IDE = ecInt.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecInt.EVENTCLASS = 'REC'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eFlo " + SQLCst.ON + "( eFlo.IDE_EVENT = eInt.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eFlo.IDT = t.IDT" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eFlo.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eFlo.EVENTTYPE  = 'FLO'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eRes " + SQLCst.ON + "( eRes.IDE_EVENT = eFlo.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eRes.IDT = @IDT" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eRes.EVENTCODE = 'RES'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eRes.EVENTTYPE = 'FLO'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecRes " + SQLCst.ON + "( ecRes.IDE = eRes.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecRes.EVENTCLASS = 'FXG'" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
                DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
                DataTable dt = ds.Tables[0];
                DataRow[] rows = dt.Select();
                DataRow row = rows[0];
                int interestPeriodCount = Convert.ToUInt16(row["INTERESTPERIOD"]);
                totalCount += interestPeriodCount;
            }
            return totalCount;
        }

        /// <summary>
        /// Unique Code Derivate:
        /// {Spheres Trade Identifier} + 
        /// "_" 
        /// + { ultimi 4 caratteri della stringa presente nel Front Trade Id} 
        /// + "_"
        /// + {Primo carattere del prodotto (es.  c ) } 
        /// + {numero progressivo (lungh.3) del trade elementare derivante da scomposizione del nozionale (es.  001 ) }
        /// alimenta il campo SOTTOCODICE_CONTO_0659
        /// </summary>
        /// <param name="pNotionalScheduleIndex"></param>
        /// <returns></returns>
        private string Calc_UniqueCodeDerivate(int pNotionalScheduleIndex)
        {
            char pad = '0';
            string index = Convert.ToString(pNotionalScheduleIndex + 1);
            string tradeIdentifier = Report.trade.header.identifier;
            string substringProductIdentifier = Report.trade.header.productIdentifier.Substring(0, 1);
            string frontId = Report.trade.header.frontId.PadLeft(4, pad);
            // =============================================================================
            // GS 20151021: ticket 21429 - ERRORE PUMA2 - campo SOTTOCODICE_CONTO_659
            // temporary solution: il frammento di stringa contenente il Front Trade Id  troncato a lunghezza 4 
            // questa soluzione risolve il problema legato al frammento di stringa che contiene il Front Trade Id SIDORO (con lunghezza 12). 
            // Sino ad oggi il Front Id utilizzata  quello rilasciato da Kondor (lunghezza 4)
            // =============================================================================
            // GS 20160201: ticket 21183 CT 41
            // Modificata la regola attuale 
            // before: estratti i primi 4 caratteri del "Front Trade Id SIDORO"  
            // after : estratti gli ultimi 4 caratteri del "Front Trade Id SIDORO"  
            // =============================================================================
            int count = 4;
            string sbstrFrontId = frontId.Substring(frontId.Length - count, count);

            string uniqueCodeDerivate = tradeIdentifier.PadLeft(5, pad) + "_" + sbstrFrontId.PadLeft(4, pad) + "_" + substringProductIdentifier + index.PadLeft(3, pad);
            return uniqueCodeDerivate;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void CapLetsFloorLets(Int32 pIdt, string pTradeIdentifier)
        {
            Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsCapLetsFloorLetsSchedule[CountCapLetsFloorLetsSteps(pIdt)];
            // step index (number of steps into the CapLets/FloorLets object)
            int stepIndex = 0;
            // try into notional schedules 
            for (int notionalScheduleIndex = 0; notionalScheduleIndex < Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length; notionalScheduleIndex++)
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
                parameters.Add(new DataParameter(Cs, "NOTIONALSTEPENDDATE", DbType.Date), Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[notionalScheduleIndex].stepEndDate); // FI 20201006 [XXXXX] DbType.Date
                parameters.Add(new DataParameter(Cs, "BEGINDATE", DbType.Date), Report.trade.header.beginDate); // FI 20201006 [XXXXX] DbType.Date
                parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);// FI 20201006 [XXXXX] DbType.Date
                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "eInt.DTSTARTUNADJ as STEP_BEGIN_DATE, eInt.DTENDUNADJ as STEP_END_DATE, " + Cst.CrLf;
                sqlSelect += " ar.IDASSET as IDASSET, ar.IDENTIFIER as IDENTIFIER, ar.PERIODMLTP as PERIODMLTP, ar.PERIOD as PERIOD, " + Cst.CrLf;
                sqlSelect += " eventMtm.VALORISATION as NETTED_MTM, ecRes.DTEVENT as EVENTCLASS_RES_DTEVENT, eventMtm.IDE as EVENTMTM_IDE  " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eInt " + SQLCst.ON + "( eInt.IDT = t.IDT )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eInt.EVENTCODE in ('INT', 'TER')" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eInt.EVENTTYPE = 'INT'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eInt.DTENDUNADJ between @ENDDATE and @NOTIONALSTEPENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecInt " + SQLCst.ON + "(eInt.IDE = ecInt.IDE)" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecInt.EVENTCLASS = 'REC'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eFlo " + SQLCst.ON + "( eFlo.IDE_EVENT = eInt.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eFlo.IDT = t.IDT" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eFlo.EVENTCODE = 'PER'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eFlo.EVENTTYPE  = 'FLO'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTASSET + " ea " + SQLCst.ON + "( ea.IDE = eFlo.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.ASSET_RATEINDEX + " ar " + SQLCst.ON + "( ar.IDASSET = ea.IDASSET )" + Cst.CrLf;
                sqlSelect += " left outer join ( " + Cst.CrLf;
                sqlSelect += SQLCst.SELECT_DISTINCT + " eMtM.IDT, ecMtm.DTEVENT, eMtm.IDE, eMtm.VALORISATION " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " eMtm " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "( ecMtm.IDE = eMtm.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecMtm.EVENTCLASS = 'CLN'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecMtm.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "eMtM.EVENTCODE = 'CLO'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eMtM.EVENTTYPE = 'MTM' ) as eventMtm " + SQLCst.ON + "eventMtm.IDT = @IDT " + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eRes " + SQLCst.ON + "( eRes.IDE_EVENT = eFlo.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eRes.IDT = @IDT" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eRes.EVENTCODE = 'RES'" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "eRes.EVENTTYPE = 'FLO'" + Cst.CrLf;
                sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecRes " + SQLCst.ON + "( ecRes.IDE = eRes.IDE )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ecRes.EVENTCLASS = 'FXG'" + Cst.CrLf;
                sqlSelect += SQLCst.LEFTJOIN_DBO + Cst.OTCml_TBL.EVENTPRICING2 + " ep2 " + SQLCst.ON + "( ep2.DTFIXING = ecRes.DTEVENT )" + Cst.CrLf;
                sqlSelect += SQLCst.AND + " ep2.IDE = eventMtm.IDE " + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
                sqlSelect += SQLCst.ORDERBY + "eInt.DTSTARTUNADJ, eInt.DTENDUNADJ" + Cst.CrLf;
                //dataset
                DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
                DataTable dt = ds.Tables[0];
                DataRow[] rows = dt.Select();
                ushort sequenceNumber = 1;
                foreach (DataRow row in rows)
                {
                    RegulatoryReportTradeDataDocumentBusinessClosingEventsCapLetsFloorLetsSchedule schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsCapLetsFloorLetsSchedule
                    {
                        stepBeginDate = Convert.ToDateTime(row["STEP_BEGIN_DATE"]),
                        stepEndDate = Convert.ToDateTime(row["STEP_END_DATE"]),
                        resDateEvent = Convert.ToDateTime(row["EVENTCLASS_RES_DTEVENT"])
                    };
                    if (false == Convert.IsDBNull(row["NETTED_MTM"]))
                        schedule.positiveMTM = Convert.ToDecimal(row["NETTED_MTM"]);
                    if (false == Convert.IsDBNull(row["EVENTMTM_IDE"]))
                        schedule.mtmEventId = Convert.ToUInt64(row["EVENTMTM_IDE"]);
                    // ******************************************
                    // from notional schedule begin section
                    // *******************************************
                    schedule.notionalStepEndDate = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[notionalScheduleIndex].stepEndDate;
                    schedule.idc = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[notionalScheduleIndex].idc;
                    schedule.uicCurrencyCode = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[notionalScheduleIndex].uicCurrencyCode;
                    schedule.notionalAmount = Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[notionalScheduleIndex].amount;
                    // countervalue section
                    if (schedule.idc != DomesticCurrency)
                    {
                        string pIdc = schedule.idc;
                        decimal pIdcAmount = schedule.notionalAmount;
                        DateTime pFixingDate = Report.trade.header.endDate;
                        CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                        //
                        if (info != null)
                        {
                            schedule.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessClosingEventsCapLetsFloorLetsScheduleCounterValueAmount
                            {
                                idc1 = info.Idc1,
                                idc2 = info.Idc2,
                                quoteBasis = info.QuoteBasis,
                                fixingDate = info.FixingDate,
                                value = info.CounterValue,
                                fxAsset = GetFxAssetIdentifier(info.IdAsset),
                                fxQuotation = info.Quotation
                            };
                        }
                        else
                        {
                            // FI 20200623 [XXXXX] SetErrorWarning
                            Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                            WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                            
                            Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                        }
                        // ******************************************
                        // from notional schedule end section
                        // *******************************************
                    }
                    // sequenceNumber (alimenta il campo SOTTOCODICE_CONTO_0659)
                    schedule.uniqueCodeRelationship = Calc_UniqueCodeDerivate(notionalScheduleIndex);
                    schedule.sequenceNumber = sequenceNumber;
                    sequenceNumber++;
                    // if product type is Cap returns capLet else floorlet
                    string stepIdName = String.Empty;
                    if (Report.trade.dataDocument.business.capFloor.productType == "CAP")
                        stepIdName = "capLet";
                    else
                        stepIdName = "floorLet";
                    //
                    schedule.id = stepIdName + Convert.ToString(stepIndex);
                    Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[stepIndex] = schedule;
                    stepIndex++;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void CapLetsFloorLetsGreeks(string pTradeIdentifier)
        {
            for (int capLetsFloorLetIndex = 0; capLetsFloorLetIndex < Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule.Length; capLetsFloorLetIndex++)
            {
                DataParameters parameters = new DataParameters();
                parameters.Add(new DataParameter(Cs, "EVENTMTM_IDE", DbType.Int32), Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].mtmEventId);
                parameters.Add(new DataParameter(Cs, "EVENTCLASS_RES_DTEVENT", DbType.Date), Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].resDateEvent); // FI 20201006 [XXXXX] DbType.Date
                StrBuilder sqlSelect = new StrBuilder();
                sqlSelect += SQLCst.SELECT + "ep2.FRAVALUE as FRAVALUE, ep2.DELTA as DELTA, ep2.VEGA as VEGA, ep2.GAMMA as GAMMA, ep2.VOLATILITY as VOLATILITY " + Cst.CrLf;
                sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENTPRICING2.ToString() + " ep2 " + Cst.CrLf;
                sqlSelect += SQLCst.WHERE + "ep2.DTFIXING = @EVENTCLASS_RES_DTEVENT " + Cst.CrLf;
                sqlSelect += SQLCst.AND + "ep2.IDE = @EVENTMTM_IDE" + Cst.CrLf;

                using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
                {
                    if (dr.Read())
                    {
                        if (false == Convert.IsDBNull(dr["DELTA"]))
                            Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].delta = Convert.ToDecimal(dr["DELTA"]);
                        if (false == Convert.IsDBNull(dr["GAMMA"]))
                            Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].gamma = Convert.ToDecimal(dr["GAMMA"]);
                        if (false == Convert.IsDBNull(dr["VEGA"]))
                            Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].vega = Convert.ToDecimal(dr["VEGA"]);
                        if (false == Convert.IsDBNull(dr["VOLATILITY"]))
                            Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].implicitVolatility = Convert.ToDecimal(dr["VOLATILITY"]);
                        if (false == Convert.IsDBNull(dr["FRAVALUE"]))
                            Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].fraValue = Convert.ToDecimal(dr["FRAVALUE"]);
                    }
                    else
                    {
                        // GS 20120308 No warning messages are writed into Log process
                        // A great numbers of rows occurs when MTM closing events are missing  
                        // Move this control to a higher level
                        //WarningMessage = "Greche sui caplets/Floorlet assenti. Eseguire il trattamento MTM sul trade.";
                        //Process.ProcessLogAddDetail(ProcessStateTools.StatusWarningEnum, WarningMessage);

                        Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].delta = Decimal.MinusOne;
                        Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].gamma = Decimal.MinusOne;
                        Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].vega = Decimal.MinusOne;
                        Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].implicitVolatility = Decimal.MinusOne;
                        Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[capLetsFloorLetIndex].fraValue = Decimal.MinusOne;
                    }
                }
            }
        }


        /// <summary>
        /// Call all methods to feed report business section for capFloor
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pDerivate"></param>
        /// <param name="pDerivativeBeginDate"></param>
        /// <param name="pActorRepositoryStyle"></param>
        public override void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle)
        {
            this.MainBusinessInfo(pIdt);
            //
            string tradeIdentifier = Report.trade.header.identifier;
            this.IsInTheScope(pIdt);
            this.CheckAccountingCategories(pIdt);
            //
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            //
            //bool isInTheScope = true;
            //
            if (isInTheScope == true)
            {
                this.Repository(pIdt);
                this.Ndg(pActorRepositoryStyle, tradeIdentifier);
                this.NdgFactorization(pActorRepositoryStyle, tradeIdentifier);

                this.AgreementExists(out bool agreementExists);
                if (agreementExists == true)
                {
                    Report.trade.dataDocument.repository.InstantiateMasterAgreement();
                    Report.trade.dataDocument.repository.masterAgreement.isAgreement = true;
                    this.MasterAgreement();
                }

                this.UicCountryCode(tradeIdentifier);
                this.MifidClientCategorisation(tradeIdentifier);
                this.IasDerivativeClassification(tradeIdentifier);
                this.IasHedgedDerivativeClassification(pIdt);
                // istantiate capfloor business element
                Report.trade.dataDocument.business.InstantiateCapFloor();
                //
                this.CheckStructuredProducts();
                this.StructuredProduct();
                this.ProductType(pIdt, tradeIdentifier);
                this.NextResetDate(pIdt);
                this.IsOvernight(pIdt);
                this.IsAmortizing(pIdt);
                this.CurrentNominalStepAmount(pIdt, tradeIdentifier);
                this.NotionalSchedule(pIdt, tradeIdentifier);
                this.RemainingDurationRatio();
                this.CapFloorStreamEndDate(pIdt);
                this.Strike(pIdt, tradeIdentifier);
                this.FloatingRate(pIdt, tradeIdentifier);
                this.Spread(pIdt);
                this.Premium(pIdt, tradeIdentifier);
                if (pDerivate == true && pDerivativeBeginDate != DateTime.MinValue)
                {
                    string product = Report.trade.header.productIdentifier;

                    this.ExchangedCleanCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ExchangedGrossCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ForwardCleanCashFlows(pIdt, tradeIdentifier, product);
                    this.ForwardGrossCashFlows(pIdt, tradeIdentifier, product);
                }
                // valorize closing events only if the trade is open: if the trade is open and closed this section will be ignored
                if (pIsOpen == true)
                {
                    this.ClosingMTMDate(pIdt, out DateTime closingDate);

                    // if the closing MTM exists valorize the other events
                    if (closingDate != DateTime.MinValue)
                    {
                        Report.trade.dataDocument.business.InstantiateClosingEvents();
                        Report.trade.dataDocument.business.closingEvents.closingDate = closingDate;
                        Report.trade.dataDocument.business.closingEvents.InstantiateMarkToMarket();
                        this.MTM(pIdt);
                        this.MTMNetted();
                        //
                        Report.trade.dataDocument.business.closingEvents.InstantiateAccruedInterest();
                        this.AccruedInterest(pIdt, tradeIdentifier);
                        this.AccruedInterestNetted();
                        //
                        if (null != Report.trade.dataDocument.business.capFloor.premium)
                        {
                            if (Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING" || Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING+")
                            {
                                // if exists a closing date we instantiale the classes linear depreciation and linear depreciation remaining into LinearDepreciationClosingDate() void. 
                                this.LinearDepreciationClosingDate(pIdt);
                                //
                                if (Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate != DateTime.MinValue)
                                {
                                    this.LinearDepreciationReceived(pIdt);
                                    this.LinearDepreciationPaid(pIdt);
                                    this.LinearDepreciationNetted();
                                    this.LinearDepreciationRemaining();
                                }
                            }
                        }
                        Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
                        this.IntrinsicValue();
                        Report.trade.dataDocument.business.closingEvents.InstantiateGreeks();
                        this.Greek(pIdt);
                        Report.trade.dataDocument.business.closingEvents.InstantiateCapLetsFloorLets();
                        this.CapLetsFloorLets(pIdt, tradeIdentifier);
                        this.CapLetsFloorLetsGreeks(tradeIdentifier);
                    }
                    // trade is discard (out of the scope) if closingDate is missing
                    else
                    {
                        Report.trade.header.isInTheScope = false;
                }
            }
        }
    }
    }

    /// <summary>
    /// Feed report business section for RRBusinessBondOption
    /// </summary>
    public class RRBusinessBondOption : RRBusiness
    {
        public RRBusinessBondOption(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
            : base(pCs, pDomesticCurrency, pProcess, pReport, pBeginDate, pEndDate, pOpenAndClosedBeginDate, pDerivativeBeginDate, pInstrumentIdentifier, pActorRepositoryStyle)
        {
        }


        /// <summary>
        /// in this version all BondOptions are in the scope
        /// To do: add out of the scope rules
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void IsInTheScope(Int32 pIdt)
        {
            bool isInTheScope = true;
            Report.trade.header.isInTheScope = isInTheScope;
        }

        /// <summary>
        /// Option Type (Call or Put)
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        private void OptionType(Int32 pIdt)
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);

            string sqlSelect = @"select ts.OPTIONTYPE
            from TRADE tr
            inner join dbo.TRADESTREAM ts on (ts.IDT = tr.IDT)
            where (tr.IDT = @IDT)" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            if (false == Convert.IsDBNull(row["OPTIONTYPE"]))
                Report.trade.dataDocument.business.bondOption.optionType = Convert.ToString(row["OPTIONTYPE"]);
        }

        /// <summary>
        /// Exercise style (European / American / Bermuda)
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        private void Exercise(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);

            string sqlSelect = @"select ec.DTEVENT, 
            case when e.EVENTCODE in ('AAO','ABO','ADO','AEO','ASW','BOA') then 'American'
            case when e.EVENTCODE in ('BAO','BBO','BEO','BSW','BOB')       then 'Bermuda'
            case when e.EVENTCODE in ('EAO','EBO','EDO','EEO','ESW','BOE') then 'European'
            else null end  as EXESTYLE
            from dbo.TRADE tr
            inner join dbo.TRADESTREAM ts  on (ts.IDT = tr.IDT)
            inner join dbo.EVENT e on (e.IDT = ts.IDT) and (e.INSTRUMENTNO = ts.INSTRUMENTNO) and  (e.STREAMNO = ts.STREAMNO)
            inner join dbo.EVENTCLASS ec on (ec.IDE = e.IDE) and (ec.EVENTCLASS = 'GRP')
            inner join dbo.EVENT evparent on (evparent.IDE = e.IDE_EVENT) and (evparent.EVENTCODE = 'PRD')
            where (tr.IDT = @IDT)" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["DTEVENT"]))
                Report.trade.dataDocument.business.bondOption.exercise.expirationDate = Convert.ToDateTime(row["DTEVENT"]);

            if (false == Convert.IsDBNull(row["EXESTYLE"]))
                Report.trade.dataDocument.business.bondOption.exerciseStyle = Convert.ToString(row["EXESTYLE"]);
        }

        /// <summary>
        /// remainingDurationDay
        /// remainingDurationRatio
        /// percentuali applicate in base alla durata residua delle operazioni (Contratti su Tassi e Titoli di Debito):
        /// Fino a 1 anno = 0.0%
        /// Oltre 1 anno e fino a 5 anni = 0.5%
        /// Oltre 5 anni = 1.5%
        /// </summary>
        private void RemainingDurationRatio()
        {
            DateTime endDate = Report.trade.header.endDate;
            Decimal remainingDurationRatio = Decimal.Zero; // defaul value for date difference <= 365 days

            DateTime terminationDate = Report.trade.header.terminationDate;
            UInt16 dateDifference = Convert.ToUInt16(terminationDate.Subtract(endDate).Days);

            if ((dateDifference <= 1825) && (dateDifference > 365))
                remainingDurationRatio = 0.005M;
            if (dateDifference > 1825)
                remainingDurationRatio = 0.015M;

            Report.trade.dataDocument.business.bondOption.remainingDurationDay = dateDifference;
            Report.trade.dataDocument.business.bondOption.remainingDurationRatio = remainingDurationRatio;
        }

        /// <summary>
        /// Nominal value and currency
        /// this method feeds optionEntitlement and notionalAmount node
        /// </summary>
        /// <param name="pIdt"></param>
        private void OptionEntitlement(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.VALORISATION as VALUE, e.UNIT as UNIT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " (e.EVENTCODE='STA') " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ( " + "(e.EVENTTYPE='NOM')" + SQLCst.OR + "(e.EVENTTYPE='BCU')" + " ) " + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            if (false == Convert.IsDBNull(row["VALUE"]))
            {
                Report.trade.dataDocument.business.bondOption.optionEntitlement = Convert.ToDecimal(row["VALUE"]);
                Report.trade.dataDocument.business.bondOption.notionalAmount.amount = Convert.ToDecimal(row["VALUE"]);
            }
            if (false == Convert.IsDBNull(row["UNIT"]))
            {
                Report.trade.dataDocument.business.bondOption.entitlementCurrency = Convert.ToString(row["UNIT"]);
                Report.trade.dataDocument.business.bondOption.notionalAmount.idc = Convert.ToString(row["UNIT"]);
            }
        }

        /// <summary>
        /// NumberOfOptions
        /// this method feeds the numebr of options
        /// </summary>
        /// <param name="pIdt"></param>
        private void NumberOfOptions(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.VALORISATION as VALUE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " (e.EVENTCODE='STA') " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "(e.EVENTTYPE='QTY')" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];
            if (false == Convert.IsDBNull(row["VALUE"]))
                Report.trade.dataDocument.business.bondOption.numberOfOptions = Convert.ToDecimal(row["VALUE"]);
        }


        /// <summary>
        /// Option Settlement
        /// Settlement Type= Physical(PHY) or Cash (CSH)
        /// Settlement Date
        /// </summary>
        /// <param name="pIdt"></param>
        private void OptionSettlement(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ec.EVENTCLASS as EVENTCLASS, ec.DTEVENT as DTEVENT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " (e.EVENTCODE='EXD') " + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["EVENTCLASS"]))
            {
                string eventClass = Convert.ToString(row["EVENTCLASS"]);
                string physical = "Physical";
                string cash = "Cash";


                switch (eventClass)
                {
                    case "PHY":
                        Report.trade.dataDocument.business.bondOption.settlementType = physical;
                        break;
                    case "CSH":
                        Report.trade.dataDocument.business.bondOption.settlementType = cash;
                        break;
                    default:
                        Report.trade.dataDocument.business.bondOption.settlementType = physical;
                        break;
                }
            }

            if (false == Convert.IsDBNull(row["DTEVENT"]))
                Report.trade.dataDocument.business.bondOption.settlementDate = Convert.ToDateTime(row["DTEVENT"]);
        }

        /// <summary>
        /// Premium 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void Premium(Int32 pIdt)
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.DTSTARTADJ as PAYMENTDATE, e.IDA_PAY as IDAPAY, e.IDA_REC as IDAREC, e.UNIT as IDC, extl.VALUE as UIC, e.VALORISATION as AMOUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'LPP'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'PRM'" + Cst.CrLf;

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["PAYMENTDATE"]))
            {
                Report.trade.dataDocument.business.bondOption.premium.paymentDate = Convert.ToDateTime(row["PAYMENTDATE"]);
                Report.trade.dataDocument.business.bondOption.premium.payerIda = Convert.ToUInt16(row["IDAPAY"]);
                Report.trade.dataDocument.business.bondOption.premium.receiverIda = Convert.ToUInt16(row["IDAREC"]);
                Report.trade.dataDocument.business.bondOption.premium.idc = Convert.ToString(row["IDC"]);
                Report.trade.dataDocument.business.bondOption.premium.uicCurrencyCode = Convert.ToString(row["UIC"]);
                Report.trade.dataDocument.business.bondOption.premium.amount = Convert.ToDecimal(row["AMOUNT"]);
                uint mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
                string mainActorIdentifier = Report.trade.dataDocument.repository.mainActor.identifier;
                string counterpartyIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
                // PayerIdentifier
                if (mainActorIda == Report.trade.dataDocument.business.bondOption.premium.payerIda)
                    Report.trade.dataDocument.business.bondOption.premium.payerIdentifier = mainActorIdentifier;
                else
                    Report.trade.dataDocument.business.bondOption.premium.payerIdentifier = counterpartyIdentifier;
                // ReceiverIdenfier
                if (mainActorIda == Report.trade.dataDocument.business.bondOption.premium.receiverIda)
                    Report.trade.dataDocument.business.bondOption.premium.receiverIdentifier = mainActorIdentifier;
                else
                    Report.trade.dataDocument.business.bondOption.premium.receiverIdentifier = counterpartyIdentifier;
                // MainActor Buyer Seller
                if (Report.trade.dataDocument.business.bondOption.premium.payerIda == mainActorIda)
                    Report.trade.dataDocument.business.bondOption.premium.mainActorPayerReceiver = "PAY";
                else if (Report.trade.dataDocument.business.bondOption.premium.receiverIda == mainActorIda)
                    Report.trade.dataDocument.business.bondOption.premium.mainActorPayerReceiver = "REC";
                // countervalue section
                if (Report.trade.dataDocument.business.bondOption.premium.idc != DomesticCurrency)
                {
                    string pIdc = Report.trade.dataDocument.business.bondOption.premium.idc;
                    decimal pIdcAmount = Report.trade.dataDocument.business.bondOption.premium.amount;
                    string tradeIdentifier = Report.trade.header.identifier;
                    DateTime pFixingDate = Report.trade.header.endDate;
                    CounterValueInfo info = ReadQuote_FXRate(pIdt, tradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                    //
                    if (info != null)
                    {
                        Report.trade.dataDocument.business.bondOption.premium.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessBondOptionPremiumCounterValueAmount
                        {
                            idc1 = info.Idc1,
                            idc2 = info.Idc2,
                            quoteBasis = info.QuoteBasis,
                            fixingDate = info.FixingDate,
                            value = info.CounterValue,
                            fxAsset = GetFxAssetIdentifier(info.IdAsset),
                            fxQuotation = info.Quotation
                        };
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
            }
        }

        /// <summary>
        /// Notional Amount
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void NotionalAmount(Int32 pIdt)
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();

            sqlSelect += SQLCst.SELECT + " e_nom.VALORISATION  as E_NOM_VALORISATION, e_nom.UNIT as E_NOM_UNIT, extl.VALUE as EXT_UIC" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e_nom " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e_nom.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e_nom.IDT = @IDT " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " (e_nom.EVENTCODE = 'STA')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ( ( e_nom.EVENTTYPE = 'NOM' ) " + SQLCst.OR + " ( e_nom.EVENTTYPE='BCU' )) " + Cst.CrLf;

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["E_NOM_UNIT"]))
                Report.trade.dataDocument.business.bondOption.notionalAmount.idc = Convert.ToString(row["E_NOM_UNIT"]); ;
            if (false == Convert.IsDBNull(row["EXT_UIC"]))
                Report.trade.dataDocument.business.bondOption.notionalAmount.uicCurrencyCode = Convert.ToString(row["EXT_UIC"]); ;
            if (false == Convert.IsDBNull(row["E_NOM_VALORISATION"]))
                Report.trade.dataDocument.business.bondOption.notionalAmount.amount = Convert.ToDecimal(row["E_NOM_VALORISATION"]); ;
            //

            // countervalue section
            if (Report.trade.dataDocument.business.bondOption.notionalAmount.idc != DomesticCurrency)
            {
                string pIdc = Report.trade.dataDocument.business.bondOption.notionalAmount.idc;
                decimal pAmount = Report.trade.dataDocument.business.bondOption.notionalAmount.amount;
                string tradeIdentifier = Report.trade.header.identifier;
                DateTime pFixingDate = Report.trade.header.endDate;
                CounterValueInfo info = ReadQuote_FXRate(pIdt, tradeIdentifier, pFixingDate, pIdc, pAmount);
                //
                if (info != null)
                {
                    Report.trade.dataDocument.business.bondOption.notionalAmount.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessBondOptionNotionalAmountCounterValueAmount
                    {
                        idc1 = info.Idc1,
                        idc2 = info.Idc2,
                        quoteBasis = info.QuoteBasis,
                        fixingDate = info.FixingDate,
                        value = info.CounterValue,
                        fxAsset = GetFxAssetIdentifier(info.IdAsset),
                        fxQuotation = info.Quotation
                    };
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }
        }


        /// <summary>
        /// Bond
        /// Feed underlying data from VW_ASSET
        /// available in the next Spheres version (v5) 
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        private void BondUnderlying(Int32 pIdt)
        {

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);

            string sqlSelect = @"select asset.IDENTIFIER, asset.DISPLAYNAME, asset.ISINCODE, asset.ID
            from dbo.TRADE tr
            inner join dbo.VW_ASSET asset on (asset.IDASSET = tr.IDASSET) and (asset.ASSETCATEGORY = tr.ASSETCATEGORY)
            where (tr.IDT = @IDT)" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["IDENTIFIER"]))
                Report.trade.dataDocument.business.bondOption.bond.securityId = Convert.ToString(row["IDENTIFIER"]);
            if (false == Convert.IsDBNull(row["DISPLAYNAME"]))
                Report.trade.dataDocument.business.bondOption.bond.securityName = Convert.ToString(row["DISPLAYNAME"]);
            if (false == Convert.IsDBNull(row["ISINCODE"]))
                Report.trade.dataDocument.business.bondOption.bond.ISIN = Convert.ToString(row["ISINCODE"]);
            if (false == Convert.IsDBNull(row["IDC"]))
                Report.trade.dataDocument.business.bondOption.bond.issuerCurrency = Convert.ToString(row["IDC"]);
        }

        /// <summary>
        /// Underlying
        /// Feed underlying data from VW_TRADE_ASSET
        /// available in actual Spheres version (v4.6)
        /// </summary>
        /// <param name="pIdt"></param>
        // EG 20200226 Refactoring suite   TRADEINSTRUMENT (INSTRUMENTNO=1) dans TRADE
        private void Underlying(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);

            string sqlSelect = @"select tasset.IDENTIFIER, tasset.DISPLAYNAME, tasset.ISINCODE, tasset.IDC_ISSUE, tasset.IDCOUNTRY_ISSUE, tasset.CFICODE, tasset.COUPONTYPE, 
            tasset.PARVALUE, tasset.IDC_PARVALUE, tasset.MATURITYDATE, m.IDENTIFIER as MARKET_IDENTIFIER, aIssue.IDENTIFIER as ISSUER_IDENTIFIER,
            trx.TRADEXML.value('declare default element namespace ""http://www.fpml.org/2007/FpML-4-4"";declare namespace efs=""http://www.efs.org/2007/EFSmL-3-0"";
            (efs:EfsML/trade/efs:debtSecurity/efs:security/instrumentId[@instrumentIdScheme=""http://www.euro-finance-systems.fr/spheres-enum/FIX/SecurityIDSource?V=100&amp;EV=Proprietary""])[1]', 'UT_IDENTIFIER') as IDPROPRIETARY
            from dbo.TRADE tr
            inner join dbo.VW_TRADE_ASSET tasset on (tasset.IDT = tr.IDASSET)
            inner join dbo.TRADEXML trx on (trx.IDT = tasset.IDT)
            left outer join dbo.ACTOR aIssue on (aIssue.IDA = tasset.IDA_ISSUER)
            left outer join dbo.MARKET m IReadOnlyCollection (m.IDM = tasset.IDM)
            where (tr.IDT = @IDT)" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["ISINCODE"]))
                Report.trade.dataDocument.business.bondOption.bond.ISIN = Convert.ToString(row["ISINCODE"]);
            if (false == Convert.IsDBNull(row["IDPROPRIETARY"]))
                Report.trade.dataDocument.business.bondOption.bond.proprietaryId = Convert.ToString(row["IDPROPRIETARY"]);
            if (false == Convert.IsDBNull(row["CFICODE"]))
                Report.trade.dataDocument.business.bondOption.bond.CFICode = Convert.ToString(row["CFICODE"]);
            if (false == Convert.IsDBNull(row["IDENTIFIER"]))
                Report.trade.dataDocument.business.bondOption.bond.securityId = Convert.ToString(row["IDENTIFIER"]);
            if (false == Convert.IsDBNull(row["DISPLAYNAME"]))
                Report.trade.dataDocument.business.bondOption.bond.securityName = Convert.ToString(row["DISPLAYNAME"]);
            if (false == Convert.IsDBNull(row["MARKET_IDENTIFIER"]))
                Report.trade.dataDocument.business.bondOption.bond.exchange = Convert.ToString(row["MARKET_IDENTIFIER"]);
            if (false == Convert.IsDBNull(row["ISSUER_IDENTIFIER"]))
                Report.trade.dataDocument.business.bondOption.bond.issuerPartyReference = Convert.ToString(row["ISSUER_IDENTIFIER"]);
            if (false == Convert.IsDBNull(row["IDCOUNTRY_ISSUE"]))
                Report.trade.dataDocument.business.bondOption.bond.issuerCountry = Convert.ToString(row["IDCOUNTRY_ISSUE"]);
            if (false == Convert.IsDBNull(row["IDC_ISSUE"]))
                Report.trade.dataDocument.business.bondOption.bond.issuerCurrency = Convert.ToString(row["IDC_ISSUE"]);
            if (false == Convert.IsDBNull(row["COUPONTYPE"]))
                Report.trade.dataDocument.business.bondOption.bond.couponType = Convert.ToString(row["COUPONTYPE"]);
            if (false == Convert.IsDBNull(row["PARVALUE"]))
                Report.trade.dataDocument.business.bondOption.bond.parValue = Convert.ToDecimal(row["PARVALUE"]);
            if (false == Convert.IsDBNull(row["IDC_PARVALUE"]))
                Report.trade.dataDocument.business.bondOption.bond.parValueCurrency = Convert.ToString(row["IDC_PARVALUE"]);
            if (false == Convert.IsDBNull(row["MATURITYDATE"]))
                Report.trade.dataDocument.business.bondOption.bond.maturity = Convert.ToDateTime(row["MATURITYDATE"]);
        }


        /// <summary>
        /// Get Closing Price from MTM events
        /// Option Theorical Price
        /// </summary>
        /// <param name="pIdt"></param>
        private void ClosingPrice(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CLOSINGMTMDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.closingDate); // FI 20201006 [XXXXX] DbType.Date

            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ed.CLOSINGPRICE as CLOSINGPRICE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "( ed.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.EVENTTYPE = 'MTM'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGMTMDATE " + Cst.CrLf;

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            DataRow row = rows[0];

            if (false == Convert.IsDBNull(row["CLOSINGPRICE"]))
                Report.trade.dataDocument.business.closingEvents.markToMarket.closingPrice = Convert.ToDecimal(row["CLOSINGPRICE"]);
        }


        /// <summary>
        /// Feed the last premium linear depreciation closing date 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected override void LinearDepreciationClosingDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "max (ec.DTEVENT) as CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'LDP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT <= @ENDDATE " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                // here we istantiate the classes for linear depreciation
                Report.trade.dataDocument.business.closingEvents.InstantiateLinearDepreciation();

                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CLOSINGDATE"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = Convert.ToDateTime(dr["CLOSINGDATE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Chiusura per l'ammortamento lineare del premio non disponibile. Eseguire il trattamento.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = DateTime.MinValue;
                }
            }
        }

        /// <summary>
        /// Detect linear depreciation of premium received by the mainactor 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationReceived(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// Detect the linear depreciation of premium paid by the mainactor 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationPaid(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// returns the netting of LinearDepreciation (received - paid)
        /// </summary>
        protected override void LinearDepreciationNetted()
        {
            decimal received = Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount;
            decimal paid = Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount;
            decimal netted = (received) - (paid);
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationRemaining()
        {
            UInt16 mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
            UInt16 premiumIdaPay = Report.trade.dataDocument.business.bondOption.premium.payerIda;
            UInt16 premiumIdaRec = Report.trade.dataDocument.business.bondOption.premium.receiverIda;
            decimal nettedLinearDepreciation = Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount;
            decimal LinearDepreciationRemainingAmount = Decimal.Zero;
            //
            decimal totalPremium = Report.trade.dataDocument.business.bondOption.premium.amount;
            // temporaryRemainingAmount  sempre negativo
            decimal temporaryRemainingAmount = nettedLinearDepreciation - totalPremium;
            // quando il premio  pagato dal mainactor il remaining  positivo perch  un risconto attivo                
            if (premiumIdaPay == mainActorIda)
                LinearDepreciationRemainingAmount = Decimal.Negate(temporaryRemainingAmount);
            // quando il premio  ricevuto dal mainactor il remaining  negativo perch  un risconto passivo 
            if (premiumIdaRec == mainActorIda)
                LinearDepreciationRemainingAmount = temporaryRemainingAmount;
            //
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount = LinearDepreciationRemainingAmount;
        }

        /// <summary>
        /// returns intrinsic value
        /// mtmCleanPrice = (MTM)
        /// mtmDirtyPrice = (mtmCleanPrice) + (linearDepreciationRemaining)
        /// Intrinsic value = mtmCleanPrice
        /// IAS Intrinsic value = mtmDirtyPrice
        /// </summary>
        protected override void IntrinsicValue()
        {
            Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule[1];
            int i = 0;
            decimal mtmCleanPrice = Decimal.Zero;
            decimal linearDepreciationRemaining = Decimal.Zero;
            DateTime closingDate = Report.trade.dataDocument.business.closingEvents.closingDate;

            RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule vi = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule();
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                mtmCleanPrice = Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount;
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.linearDepreciation)
                linearDepreciationRemaining = Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount;
            // calc MTM dirtyPrice (use by IAS intrinsic value)
            decimal mtmDirtyPrice = (mtmCleanPrice) + (linearDepreciationRemaining);
            vi.stepDate = closingDate;
            vi.amount = mtmCleanPrice;
            vi.amountIAS = mtmDirtyPrice;

            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[i] = vi;
            vi.id = Convert.ToString("intrinsicValue") + Convert.ToString(i);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        protected override void BondUnderlyingQuotation(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "CLOSINGMTMDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.closingDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ed.NOTIONALAMOUNT as NOTIONALAMOUNT, ep.UNDERLYINGACCRUEDINTERESTRATE as UNDERLYINGACCRUEDINTERESTRATE, ep.UNDERLYINGPRICE as UNDERLYINGPRICE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "( e.IDT = t.IDT )" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT  = @CLOSINGMTMDATE " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "( ed.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTPRICING + " ep " + SQLCst.ON + "( ep.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["UNDERLYINGPRICE"]))
                        Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.underlyingPrice = Convert.ToDecimal(dr["UNDERLYINGPRICE"]);
                    if (false == Convert.IsDBNull(dr["NOTIONALAMOUNT"]))
                        Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.optionNotionalAmount = Convert.ToDecimal(dr["NOTIONALAMOUNT"]);
                    if (false == Convert.IsDBNull(dr["UNDERLYINGACCRUEDINTERESTRATE"]))
                        Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.accruedInterestRate = Convert.ToDecimal(dr["UNDERLYINGACCRUEDINTERESTRATE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Quotazioni del sottostante non valorizzate. Eseguire o verificare il trattamento MTM sul trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.underlyingPrice = Decimal.Zero;
                    Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.optionNotionalAmount = Decimal.Zero;
                    Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.accruedInterestRate = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// Call all methods to feed report business section for bond option
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pDerivate"></param>
        /// <param name="pDerivativeBeginDate"></param>
        /// <param name="pActorRepositoryStyle"></param>
        public override void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle)
        {

            this.MainBusinessInfo(pIdt);
            //
            string tradeIdentifier = Report.trade.header.identifier;
            this.IsInTheScope(pIdt);
            this.CheckAccountingCategories(pIdt);
            //
            //bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            //
            this.Repository(pIdt);

            this.AgreementExists(out bool agreementExists);
            if (agreementExists == true)
            {
                Report.trade.dataDocument.repository.InstantiateMasterAgreement();
                Report.trade.dataDocument.repository.masterAgreement.isAgreement = true;
                this.MasterAgreement();
            }

            this.Ndg(pActorRepositoryStyle, tradeIdentifier);
            this.NdgFactorization(pActorRepositoryStyle, tradeIdentifier);
            this.UicCountryCode(tradeIdentifier);
            this.MifidClientCategorisation(tradeIdentifier);
            this.IasDerivativeClassification(tradeIdentifier);
            this.IasHedgedDerivativeClassification(pIdt);
            // istantiate bond option business element
            Report.trade.dataDocument.business.InstantiateBondOption();
            // set bond product type
            Report.trade.dataDocument.business.bondOption.productType = Report.trade.header.instrumentIdentifier;
            //
            this.CheckStructuredProducts();
            this.StructuredProduct();
            // Call or Put
            this.OptionType(pIdt);
            this.Exercise(pIdt);
            // Feed remainingDurationDay and remainingDurationRatio
            this.RemainingDurationRatio();
            // Feed nominal currency and value for OptionEntitlement and notionalAmount section 
            this.OptionEntitlement(pIdt);
            this.NumberOfOptions(pIdt);
            // Feed settlementType and settlementDate
            this.OptionSettlement(pIdt);
            // not available in 4.6 Spheres version
            //<xs:element name="strike" type="xs:decimal" />
            this.Premium(pIdt);
            this.NotionalAmount(pIdt);
            // not available in this version
            //this.ExerciseStyle();
            // feed underlying section (available in the actual Spheres version (v4.6)
            this.Underlying(pIdt);
            // feed underlying section (available in the next Spheres version (v5.0)
            //this.BondUnderlying(pIdt);

            // valorize closing events only if the trade is open: if the trade is open and closed this section will be ignored
            if (pIsOpen == true)
            {
                this.ClosingMTMDate(pIdt, out DateTime closingDate);

                // if the closing MTM exists valorize the other events
                if (closingDate != DateTime.MinValue)
                {
                    Report.trade.dataDocument.business.InstantiateClosingEvents();
                    Report.trade.dataDocument.business.closingEvents.closingDate = closingDate;

                    Report.trade.dataDocument.business.closingEvents.InstantiateMarkToMarket();
                    this.MTM(pIdt);
                    this.MTMNetted();

                    this.ClosingPrice(pIdt);
                    //
                    if (null != Report.trade.dataDocument.business.bondOption.premium)
                    {
                        if (Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING" || Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING+")
                        {
                            // if exists a closing date we instantiale the classes linear depreciation and linear depreciation remaining into LinearDepreciationClosingDate() void. 
                            this.LinearDepreciationClosingDate(pIdt);
                            //
                            if (Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate != DateTime.MinValue)
                            {
                                this.LinearDepreciationReceived(pIdt);
                                this.LinearDepreciationPaid(pIdt);
                                this.LinearDepreciationNetted();
                                this.LinearDepreciationRemaining();
                            }
                        }
                    }
                    Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
                    this.IntrinsicValue();
                    Report.trade.dataDocument.business.closingEvents.InstantiateGreeks();
                    this.Greek(pIdt);
                    Report.trade.dataDocument.business.closingEvents.InstantiateBondUnderlyingQuotation();
                    this.BondUnderlyingQuotation(pIdt);
                }
                // trade is discard (out of the scope) if closingDate is missing
                else
                {
                    Report.trade.header.isInTheScope = false;
            }
            }

            if (pDerivate == true && pDerivativeBeginDate != DateTime.MinValue)
            {
                string product = Report.trade.header.productIdentifier;

                this.ExchangedCleanCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                this.ExchangedGrossCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                this.ForwardCleanCashFlows(pIdt, tradeIdentifier, product);
                this.ForwardGrossCashFlows(pIdt, tradeIdentifier, product);
            }

        }
    }

    /// <summary>
    /// Feed report business section for FxSimpleOption
    /// </summary>
    public class RRBusinessFxSimpleOption : RRBusiness
    {
        public RRBusinessFxSimpleOption(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
            : base(pCs, pDomesticCurrency, pProcess, pReport, pBeginDate, pEndDate, pOpenAndClosedBeginDate, pDerivativeBeginDate, pInstrumentIdentifier, pActorRepositoryStyle)
        {
        }

        /// <summary>
        /// Discard out-of-the-scope trades for:
        /// Options without closing events at the extraction period
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void IsInTheScope(Int32 pIdt)
        {
            // Options without closing events at the extraction period is out-of-the-scope
            DataParameters parameters01 = new DataParameters();
            parameters01.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters01.Add(new DataParameter(Cs, "BEGINDATE", DbType.Date), Report.trade.header.beginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters01.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect01 = new StrBuilder();
            sqlSelect01 += SQLCst.SELECT + "count (*) as ISINTHESCOPE" + Cst.CrLf;
            sqlSelect01 += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect01 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eMtm " + SQLCst.ON + "(eMtm.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect01 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "(ecMtm.IDE = eMtm.IDE)" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "ecMtm.EVENTCLASS = 'CLN'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "ecMtm.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
            sqlSelect01 += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eMtM.EVENTCODE = 'CLO'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eMtM.EVENTTYPE = 'MTM'" + Cst.CrLf;
            DataSet ds01 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect01.ToString(), parameters01.GetArrayDbParameter());
            DataTable dt01 = ds01.Tables[0];
            DataRow[] rows01 = dt01.Select();
            DataRow row01 = rows01[0];
            bool isInTheScope = true;
            Int16 count = Convert.ToInt16(row01["ISINTHESCOPE"]);
            if (count == 0)
            {
                isInTheScope = false;
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Trade scartato (out of the scope): Nessun evento di chiusura per il periodo di osservazione.";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
            Report.trade.header.isInTheScope = isInTheScope;
        }

        /// <summary>
        /// returns the type of option (Call or Put)
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void OptionType(Int32 pIdT)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdT);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " ts.OPTIONTYPE as OPTIONTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADESTREAM.ToString() + " ts " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ts.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["OPTIONTYPE"]))
                        Report.trade.dataDocument.business.fxSimpleOption.optionType = Convert.ToString(dr["OPTIONTYPE"]);
                }
                else
                {
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo opzione non valorizzato. Verificare il trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage, 0));

                    Report.trade.dataDocument.business.fxSimpleOption.optionType = String.Empty;
                }
            }
        }

        /// <summary>
        /// returns the type of exercise (AME - BRM - EUR)
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void ExerciseStyle(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.EVENTTYPE as EXERCISESTYLE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'EXD'" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["EXERCISESTYLE"]))
                        Report.trade.dataDocument.business.fxSimpleOption.exerciseStyle = Convert.ToString(dr["EXERCISESTYLE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Stile esercizio non valorizzato. Verificare il trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxSimpleOption.exerciseStyle = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void SettlementType(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " distinct ec.EVENTCLASS as SETTLEMENTTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENTCLASS.ToString() + " ec " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDE = ec.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'EXD'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS in ('PHY','CSH')" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["SETTLEMENTTYPE"]))
                        Report.trade.dataDocument.business.fxSimpleOption.settlementType = Convert.ToString(dr["SETTLEMENTTYPE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo di regolamento non valorizzato. Verificare il trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxSimpleOption.settlementType = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void CallCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BOOKIDB", DbType.Int32), Report.trade.dataDocument.repository.mainActor.bookIdb);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.VALORISATION as CALL_AMOUNT, e.UNIT as CALL_IDC, extl.VALUE as CALL_UIC" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADESTREAM + " ts " + SQLCst.ON + "(ts.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.BOOK + " b " + SQLCst.ON + "(b.IDB = @BOOKIDB)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'CCU'" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CALL_IDC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.idc = Convert.ToString(dr["CALL_IDC"]);
                    if (false == Convert.IsDBNull(dr["CALL_UIC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["CALL_UIC"]);
                    if (false == Convert.IsDBNull(dr["CALL_AMOUNT"]))
                        Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.amount = Convert.ToDecimal(dr["CALL_AMOUNT"]);
                    //
                    string pIdc = Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.idc;
                    if (pIdc != "EUR")
                    {
                        decimal pIdcAmount = Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.amount;
                        DateTime pFixingDate = Report.trade.header.endDate;
                        Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.value = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount).CounterValue;
                    }
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa Call non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void CallCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.amount;
            //
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (CallCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void PutCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BOOKIDB", DbType.Int32), Report.trade.dataDocument.repository.mainActor.bookIdb);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.VALORISATION as PUT_AMOUNT, e.UNIT as PUT_IDC, extl.VALUE as PUT_UIC" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADESTREAM + " ts " + SQLCst.ON + "(ts.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.BOOK + " b " + SQLCst.ON + "(b.IDB = @BOOKIDB)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'PCU'" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["PUT_IDC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.idc = Convert.ToString(dr["PUT_IDC"]);
                    if (false == Convert.IsDBNull(dr["PUT_UIC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["PUT_UIC"]);
                    if (false == Convert.IsDBNull(dr["PUT_AMOUNT"]))
                        Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.amount = Convert.ToDecimal(dr["PUT_AMOUNT"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa Put non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void PutCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.amount;
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (PutCurrencyCounterValueAmount)";

                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void PayCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.UNIT as PAY_IDC, e.VALORISATION as PAY_AMOUNT, extl.VALUE as PAY_UIC " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE in ('PCU', 'CCU')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.IDA_PAY =  @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.UNITTYPE = 'Currency'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["PAY_IDC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.idc = Convert.ToString(dr["PAY_IDC"]);
                    if (false == Convert.IsDBNull(dr["PAY_UIC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["PAY_UIC"]);
                    if (false == Convert.IsDBNull(dr["PAY_AMOUNT"]))
                        Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.amount = Convert.ToDecimal(dr["PAY_AMOUNT"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa pagata non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void RecCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.UNIT as REC_IDC, e.VALORISATION as REC_AMOUNT, extl.VALUE as REC_UIC " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE in ('PCU', 'CCU')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.IDA_REC =  @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.UNITTYPE = 'Currency'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["REC_IDC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.idc = Convert.ToString(dr["REC_IDC"]);
                    if (false == Convert.IsDBNull(dr["REC_UIC"]))
                        Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["REC_UIC"]);
                    if (false == Convert.IsDBNull(dr["REC_AMOUNT"]))
                        Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.amount = Convert.ToDecimal(dr["REC_AMOUNT"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa ricevuta non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void PayCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.amount;
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning    
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (PayCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void RecCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.amount;
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);
                
                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (RecCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdc"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>true if the currency is a commodity</returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private bool RetrieverIsCommodity(string pIdc, string pTradeIdentifier)
        {
            bool isCommodity = false;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDC", DbType.String), pIdc);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " VALUE as VALUE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " ex " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ex.TABLENAME = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.IDENTIFIER  = 'TIPOPRODSPECMERCI'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.ID = @IDC" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALUE"]))
                    {
                        if (Convert.ToString(dr["VALUE"]) != "0")
                            isCommodity = true;
                    }
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo prodotto specifico merci non valorizzato per la divisa " + pIdc + " .Impostare il valore in anagrafica.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }
            return isCommodity;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdc"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>returns 525 code for commodity extra info</returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private string RetrieverCode0525(string pIdc, string pTradeIdentifier)
        {
            string code0525 = String.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDC", DbType.String), pIdc);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " VALUE as VALUE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " ex " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ex.TABLENAME = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.IDENTIFIER  = 'TIPOPRODSPECMERCI'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.ID = @IDC" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALUE"]))
                        code0525 = Convert.ToString(dr["VALUE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Il campo Tipo prodotto specifico merci non valorizzato per la divisa " + pIdc + ". Aggiornare l'anagrafica della divisa";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }
            return code0525;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdc"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>returns 183 code for commodity extra info</returns>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        private string RetrieverCode0183(string pIdc, string pTradeIdentifier)
        {
            string code0183 = String.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDC", DbType.String), pIdc);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " VALUE as VALUE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " ex " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ex.TABLENAME = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.IDENTIFIER  = 'DIGITVALORESOTTOSTANTE'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.ID = @IDC" + Cst.CrLf;
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALUE"]))
                        code0183 = Convert.ToString(dr["VALUE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Digit valore sottostante non valorizzato per la divisa " + pIdc + ". Aggiornare l'anagrafica della divisa";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }
            return code0183;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void PayCommodityExtraInfo(Int32 pIdt, string pTradeIdentifier)
        {
            if (Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.isCommodity)
            {
                _ = Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.commodityExtraInfo.code_0183;
                _ = Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.commodityExtraInfo.code_0525;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        private void RecCommodityExtraInfo(Int32 pIdt, string pTradeIdentifier)
        {
            _ = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.idc;
            bool isCommodity = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.isCommodity;
            if (isCommodity == true)
            {
                _ = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.commodityExtraInfo.code_0183;
                _ = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.commodityExtraInfo.code_0525;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20190114 Add detail to ProcessLog Refactoring
        private void Premium(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ec.DTEVENT as PAYMENTDATE, e.IDA_PAY as IDAPAY, e.IDA_REC as IDAREC, e.UNIT as IDC, extl.VALUE as UIC, e.VALORISATION as AMOUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'LPP'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'PRM'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS = 'STL'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            Report.trade.dataDocument.business.fxSimpleOption.premium = new RegulatoryReportTradeDataDocumentBusinessFxSimpleOptionPremium[rows.Length];
            int index = 0;
            foreach (DataRow row in rows)
            {
                RegulatoryReportTradeDataDocumentBusinessFxSimpleOptionPremium premium = new RegulatoryReportTradeDataDocumentBusinessFxSimpleOptionPremium
                {
                    paymentDate = Convert.ToDateTime(row["PAYMENTDATE"]),
                    payerIda = Convert.ToUInt16(row["IDAPAY"]),
                    receiverIda = Convert.ToUInt16(row["IDAREC"]),
                    idc = Convert.ToString(row["IDC"]),
                    uicCurrencyCode = Convert.ToString(row["UIC"]),
                    amount = Convert.ToDecimal(row["AMOUNT"])
                };
                uint mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
                string mainActorIdentifier = Report.trade.dataDocument.repository.mainActor.identifier;
                uint counterpartyIda = Report.trade.dataDocument.repository.counterparty.ida;
                string counterpartyIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
                // PayerIdentifier
                if (mainActorIda == premium.payerIda)
                    premium.payerIdentifier = mainActorIdentifier;
                else
                    premium.payerIdentifier = counterpartyIdentifier;
                // ReceiverIdenfier
                if (mainActorIda == premium.receiverIda)
                    premium.receiverIdentifier = mainActorIdentifier;
                else
                    premium.receiverIdentifier = counterpartyIdentifier;
                // MainActor Buyer Seller
                if (premium.payerIda == mainActorIda)
                    premium.mainActorPayerReceiver = "PAY";
                else if (premium.receiverIda == mainActorIda)
                    premium.mainActorPayerReceiver = "REC";
                // countervalue section
                if (premium.idc != DomesticCurrency)
                {
                    string pIdc = premium.idc;
                    decimal pIdcAmount = premium.amount;
                    DateTime pFixingDate = Report.trade.header.endDate;
                    CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                    //
                    if (info != null)
                    {
                        premium.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessFxSimpleOptionPremiumCounterValueAmount
                        {
                            idc1 = info.Idc1,
                            idc2 = info.Idc2,
                            quoteBasis = info.QuoteBasis,
                            fixingDate = info.FixingDate,
                            value = info.CounterValue,
                            fxAsset = GetFxAssetIdentifier(info.IdAsset),
                            fxQuotation = info.Quotation
                        };
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";
                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
                premium.id = "premium" + Convert.ToString(index);
                Report.trade.dataDocument.business.fxSimpleOption.premium[index] = premium;
                index++;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        // EG 20190114 Add detail to ProcessLog Refactoring
        protected override void LinearDepreciationClosingDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "max (ec.DTEVENT) as CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'LDP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT <= @ENDDATE " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                // here we istantiate the classes for linear depreciation
                Report.trade.dataDocument.business.closingEvents.InstantiateLinearDepreciation();

                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CLOSINGDATE"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = Convert.ToDateTime(dr["CLOSINGDATE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Chiusura per l'ammortamento lineare del premio non disponibile. Eseguire il trattamento.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = DateTime.MinValue;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationReceived(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;
            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        // EG 20180426 Analyse du code Correction [CA2202]
        protected override void LinearDepreciationPaid(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationNetted()
        {
            decimal received = Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount;
            decimal paid = Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount;
            decimal netted = (received) - (paid);
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationRemaining()
        {

            UInt16 mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
            UInt16 premiumIdaPay = Report.trade.dataDocument.business.fxSimpleOption.premium[0].payerIda;
            UInt16 premiumIdaRec = Report.trade.dataDocument.business.fxSimpleOption.premium[0].receiverIda;
            decimal totalPremium = Decimal.Zero;
            decimal nettedLinearDepreciation = Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount;
            decimal LinearDepreciationRemainingAmount = Decimal.Zero;
            //
            for (int i = 0; i < Report.trade.dataDocument.business.fxSimpleOption.premium.Length; i++)
            {
                totalPremium += Report.trade.dataDocument.business.fxSimpleOption.premium[i].amount;
            }
            // temporaryRemainingAmount  sempre negativo
            decimal temporaryRemainingAmount = nettedLinearDepreciation - totalPremium;
            // quando il premio  pagato dal mainactor il remaining  positivo perch  un risconto attivo                
            if (premiumIdaPay == mainActorIda)
                LinearDepreciationRemainingAmount = Decimal.Negate(temporaryRemainingAmount);
            // quando il premio  ricevuto dal mainactor il remaining  negativo perch  un risconto passivo 
            if (premiumIdaRec == mainActorIda)
                LinearDepreciationRemainingAmount = temporaryRemainingAmount;
            //
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount = LinearDepreciationRemainingAmount;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void IntrinsicValue()
        {
            Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule[1];
            int i = 0;
            decimal mtmCleanPrice = Decimal.Zero;
            decimal linearDepreciationRemaining = Decimal.Zero;

            RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule vi = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule();
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                mtmCleanPrice = Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount;
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.linearDepreciation)
                linearDepreciationRemaining = Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount;
            // calc MTM dirtyPrice (use by IAS intrinsic value)
            decimal mtmDirtyPrice = (mtmCleanPrice) + (linearDepreciationRemaining);
            vi.amount = mtmCleanPrice;
            vi.amountIAS = mtmDirtyPrice;
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[i] = vi;
            vi.id = Convert.ToString("intrinsicValue") + Convert.ToString(i);
        }

        /// <summary>
        /// 
        /// </summary>
        private void RemainingDuration()
        {
            DateTime endDate = Report.trade.header.endDate;
            DateTime terminationDate = Report.trade.header.terminationDate;
            TimeSpan remainingDurationDay = terminationDate.Subtract(endDate);
            Report.trade.dataDocument.business.fxSimpleOption.remainingDurationDay = Convert.ToUInt16(remainingDurationDay.Days);

            decimal remainingDurationRatio = Decimal.Zero;
            if (remainingDurationDay.Days <= 365)
                remainingDurationRatio = 0.01M;
            if (remainingDurationDay.Days > 365 & (endDate.Subtract(terminationDate)).Days <= 1825)
                remainingDurationRatio = 0.05M;
            if (remainingDurationDay.Days > 1825)
                remainingDurationRatio = 0.075M;
            Report.trade.dataDocument.business.fxSimpleOption.remainingDurationRatio = remainingDurationRatio;
        }

        /// <summary>
        /// Call all methods to feed report business section for FxSimpleOption 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pDerivate"></param>
        /// <param name="pDerivativeBeginDate"></param>
        /// <param name="pActorRepositoryStyle"></param>
        public override void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle)
        {
            this.MainBusinessInfo(pIdt);
            //
            string tradeIdentifier = Report.trade.header.identifier;
            this.IsInTheScope(pIdt);
            this.CheckAccountingCategories(pIdt);
            //
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            //
            if (isInTheScope == true)
            {
                _ = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;
                _ = Report.trade.dataDocument.repository.mainActor.tradeLocalClass;
                this.Repository(pIdt);

                this.AgreementExists(out bool agreementExists);
                if (agreementExists == true)
                {
                    Report.trade.dataDocument.repository.InstantiateMasterAgreement();
                    Report.trade.dataDocument.repository.masterAgreement.isAgreement = true;
                    this.MasterAgreement();
                }

                this.Ndg(pActorRepositoryStyle, tradeIdentifier);
                this.NdgFactorization(pActorRepositoryStyle, tradeIdentifier);
                this.UicCountryCode(tradeIdentifier);
                this.MifidClientCategorisation(tradeIdentifier);
                this.IasDerivativeClassification(tradeIdentifier);
                this.IasHedgedDerivativeClassification(pIdt);
                // istantiate fxSimpleOption element
                Report.trade.dataDocument.business.InstantiateFxSimpleOption();
                //
                this.OptionType(pIdt);
                this.ExerciseStyle(pIdt, tradeIdentifier);
                this.SettlementType(pIdt, tradeIdentifier);
                this.RemainingDuration();
                // ///////////////////////
                // Call and Put Currency
                // ///////////////////////
                this.CallCurrencyAmount(pIdt, tradeIdentifier);
                this.PutCurrencyAmount(pIdt, tradeIdentifier);
                // Call Currency CounterValue
                string pCallIdc = Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.idc;
                if (pCallIdc != DomesticCurrency)
                {
                this.CallCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // Put Currency CounterValue
                string pPutIdc = Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.idc;
                if (pPutIdc != DomesticCurrency)
                {
                this.PutCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // ///////////////////////
                // Pay and Rec Currency
                // ///////////////////////
                this.PayCurrencyAmount(pIdt, tradeIdentifier);
                this.RecCurrencyAmount(pIdt, tradeIdentifier);
                // Pay Currency CounterValue
                string pPayIdc = Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.idc;
                if (pPayIdc != DomesticCurrency)
                {
                this.PayCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // Rec Currency CounterValue
                string pRecIdc = Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.idc;
                if (pRecIdc != DomesticCurrency)
                {
                this.RecCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // ///////////////////////
                // Pay and Rec Commodity
                // ///////////////////////
                this.PayCommodityExtraInfo(pIdt, tradeIdentifier);
                this.RecCommodityExtraInfo(pIdt, tradeIdentifier);

                if (pDerivate == true && pDerivativeBeginDate != DateTime.MinValue)
                {
                    string product = Report.trade.header.productIdentifier;

                    this.ExchangedCleanCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ExchangedGrossCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ForwardCleanCashFlows(pIdt, tradeIdentifier, product);
                    this.ForwardGrossCashFlows(pIdt, tradeIdentifier, product);
                }
                // valorize closing events only if the trade is open: if the trade is open and closed this section will be ignored
                if (pIsOpen == true)
                {
                    this.ClosingMTMDate(pIdt, out DateTime closingDate);

                    // if the closing MTM exists valorize the other events
                    if (closingDate != DateTime.MinValue)
                    {
                        Report.trade.dataDocument.business.InstantiateClosingEvents();
                        Report.trade.dataDocument.business.closingEvents.closingDate = closingDate;
                        Report.trade.dataDocument.business.closingEvents.InstantiateMarkToMarket();
                        this.MTM(pIdt);
                        this.MTMNetted();
                        //
                        if (null != Report.trade.dataDocument.business.fxSimpleOption.premium)
                        {
                            if (Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING" || Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING+")
                            {
                                // if exists a closing date we instantiale the classes linear depreciation and linear depreciation remaining into LinearDepreciationClosingDate() void. 
                                this.LinearDepreciationClosingDate(pIdt);
                                //
                                if (Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate != DateTime.MinValue)
                                {
                                    this.LinearDepreciationReceived(pIdt);
                                    this.LinearDepreciationPaid(pIdt);
                                    this.LinearDepreciationNetted();
                                    this.LinearDepreciationRemaining();
                                }
                            }
                        }
                        Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
                        this.IntrinsicValue();
                        Report.trade.dataDocument.business.closingEvents.InstantiateGreeks();
                        this.Greek(pIdt);
                    }
                    // trade is discard (out of the scope) if closingDate is missing
                    else
                    {
                        Report.trade.header.isInTheScope = false;
                }
            }
        }
    }
    }

    /// <summary>
    /// Feed report business section for FxBarrierOption
    /// incomplete section
    /// </summary>
    public class RRBusinessFxBarrierOption : RRBusiness
    {
        public RRBusinessFxBarrierOption(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
            : base(pCs, pDomesticCurrency, pProcess, pReport, pBeginDate, pEndDate, pOpenAndClosedBeginDate, pDerivativeBeginDate, pInstrumentIdentifier, pActorRepositoryStyle)
        {
        }

        /// <summary>
        /// Discard out-of-the-scope trades for:
        /// Options without closing events at the extraction period
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void IsInTheScope(Int32 pIdt)
        {
            // Options without closing events at the extraction period is out-of-the-scope
            DataParameters parameters01 = new DataParameters();
            parameters01.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters01.Add(new DataParameter(Cs, "BEGINDATE", DbType.Date), Report.trade.header.beginDate); // FI 20201006 [XXXXX] DbType.Date
            parameters01.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect01 = new StrBuilder();
            sqlSelect01 += SQLCst.SELECT + "count (*) as ISINTHESCOPE" + Cst.CrLf;
            sqlSelect01 += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect01 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " eMtm " + SQLCst.ON + "(eMtm.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect01 += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ecMtm " + SQLCst.ON + "(ecMtm.IDE = eMtm.IDE)" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "ecMtm.EVENTCLASS = 'CLN'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "ecMtm.DTEVENT between @BEGINDATE and @ENDDATE" + Cst.CrLf;
            sqlSelect01 += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eMtM.EVENTCODE = 'CLO'" + Cst.CrLf;
            sqlSelect01 += SQLCst.AND + "eMtM.EVENTTYPE = 'MTM'" + Cst.CrLf;
            DataSet ds01 = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect01.ToString(), parameters01.GetArrayDbParameter());
            DataTable dt01 = ds01.Tables[0];
            DataRow[] rows01 = dt01.Select();
            DataRow row01 = rows01[0];
            bool isInTheScope = true;
            Int16 count = Convert.ToInt16(row01["ISINTHESCOPE"]);
            if (count == 0)
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                isInTheScope = false;
                WarningMessage = "Trade scartato (out of the scope): Nessun evento di chiusura per il periodo di osservazione.";
                

                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
            Report.trade.header.isInTheScope = isInTheScope;
        }

        /// <summary>
        /// returns the type of option (Call or Put)
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void OptionType(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " ts.OPTIONTYPE as OPTIONTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADESTREAM.ToString() + " ts " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ts.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["OPTIONTYPE"]))
                        Report.trade.dataDocument.business.fxBarrierOption.optionType = Convert.ToString(dr["OPTIONTYPE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo opzione non valorizzato. Verificare il trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.optionType = String.Empty;
                }
            }
        }

        /// <summary>
        /// returns the type of exercise (AME - BRM - EUR)
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void ExerciseStyle(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.EVENTTYPE as EXERCISESTYLE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'EXD'" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["EXERCISESTYLE"]))
                        Report.trade.dataDocument.business.fxBarrierOption.exerciseStyle = Convert.ToString(dr["EXERCISESTYLE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Stile esercizio non valorizzato. Verificare il trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.exerciseStyle = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void SettlementType(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " distinct ec.EVENTCLASS as SETTLEMENTTYPE" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENTCLASS.ToString() + " ec " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDE = ec.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'EXD'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS in ('PHY','CSH')" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["SETTLEMENTTYPE"]))
                        Report.trade.dataDocument.business.fxBarrierOption.settlementType = Convert.ToString(dr["SETTLEMENTTYPE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo di regolamento non valorizzato. Verificare il trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.settlementType = String.Empty;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        private void RemainingDuration()
        {
            DateTime endDate = Report.trade.header.endDate;
            DateTime terminationDate = Report.trade.header.terminationDate;
            TimeSpan remainingDurationDay = terminationDate.Subtract(endDate);
            Report.trade.dataDocument.business.fxBarrierOption.remainingDurationDay = Convert.ToUInt16(remainingDurationDay.Days);

            decimal remainingDurationRatio = Decimal.Zero;
            if (remainingDurationDay.Days <= 365)
                remainingDurationRatio = 0.01M;
            if (remainingDurationDay.Days > 365 & (endDate.Subtract(terminationDate)).Days <= 1825)
                remainingDurationRatio = 0.05M;
            if (remainingDurationDay.Days > 1825)
                remainingDurationRatio = 0.075M;
            Report.trade.dataDocument.business.fxBarrierOption.remainingDurationRatio = remainingDurationRatio;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void CallCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BOOKIDB", DbType.Int32), Report.trade.dataDocument.repository.mainActor.bookIdb);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.VALORISATION as CALL_AMOUNT, e.UNIT as CALL_IDC, extl.VALUE as CALL_UIC" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADESTREAM + " ts " + SQLCst.ON + "(ts.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.BOOK + " b " + SQLCst.ON + "(b.IDB = @BOOKIDB)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'CCU'" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CALL_IDC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.idc = Convert.ToString(dr["CALL_IDC"]);
                    if (false == Convert.IsDBNull(dr["CALL_UIC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["CALL_UIC"]);
                    if (false == Convert.IsDBNull(dr["CALL_AMOUNT"]))
                        Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.amount = Convert.ToDecimal(dr["CALL_AMOUNT"]);
                    //
                    string pIdc = Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.idc;
                    if (pIdc != "EUR")
                    {
                        decimal pIdcAmount = Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.amount;
                        DateTime pFixingDate = Report.trade.header.endDate;
                        Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.value = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount).CounterValue;
                    }
                }
                else
                {
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa Call non sono state valorizzate. Verificare gli eventi del trade.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void CallCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.amount;
            //
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (CallCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void PutCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "BOOKIDB", DbType.Int32), Report.trade.dataDocument.repository.mainActor.bookIdb);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.VALORISATION as PUT_AMOUNT, e.UNIT as PUT_IDC, extl.VALUE as PUT_UIC" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.TRADESTREAM + " ts " + SQLCst.ON + "(ts.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.BOOK + " b " + SQLCst.ON + "(b.IDB = @BOOKIDB)" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'PCU'" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["PUT_IDC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.idc = Convert.ToString(dr["PUT_IDC"]);
                    if (false == Convert.IsDBNull(dr["PUT_UIC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["PUT_UIC"]);
                    if (false == Convert.IsDBNull(dr["PUT_AMOUNT"]))
                        Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.amount = Convert.ToDecimal(dr["PUT_AMOUNT"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa Put non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void PutCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.amount;
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (PutCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void PayCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.UNIT as PAY_IDC, e.VALORISATION as PAY_AMOUNT, extl.VALUE as PAY_UIC " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE in ('PCU', 'CCU')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.IDA_PAY =  @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.UNITTYPE = 'Currency'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["PAY_IDC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.idc = Convert.ToString(dr["PAY_IDC"]);
                    if (false == Convert.IsDBNull(dr["PAY_UIC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["PAY_UIC"]);
                    if (false == Convert.IsDBNull(dr["PAY_AMOUNT"]))
                        Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.amount = Convert.ToDecimal(dr["PAY_AMOUNT"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa pagata non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void RecCurrencyAmount(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " e.UNIT as REC_IDC, e.VALORISATION as REC_AMOUNT, extl.VALUE as REC_UIC " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'STA'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE in ('PCU', 'CCU')" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.IDA_REC =  @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.UNITTYPE = 'Currency'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.TABLENAME  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "extl.IDENTIFIER = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "t.IDT = @IDT" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["REC_IDC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.idc = Convert.ToString(dr["REC_IDC"]);
                    if (false == Convert.IsDBNull(dr["REC_UIC"]))
                        Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.uicCurrencyCode = Convert.ToString(dr["REC_UIC"]);
                    if (false == Convert.IsDBNull(dr["REC_AMOUNT"]))
                        Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.amount = Convert.ToDecimal(dr["REC_AMOUNT"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Le informazioni relative alla divisa ricevuta non sono state valorizzate. Verificare gli eventi del trade.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.idc = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.uicCurrencyCode = String.Empty;
                    Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.amount = Decimal.Zero;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void PayCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.amount;
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (PayCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void RecCurrencyCounterValueAmount(Int32 pIdt, string pTradeIdentifier)
        {
            string pIdc = Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.idc;
            decimal pIdcAmount = Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.amount;
            DateTime pFixingDate = Report.trade.header.endDate;
            CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
            //
            if (info != null)
            {
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.InstantiateCounterValueAmount();
                //
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.idc1 = info.Idc1;
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.idc2 = info.Idc2;
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.quoteBasis = info.QuoteBasis;
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.fixingDate = info.FixingDate;
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.value = info.CounterValue;
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.fxAsset = GetFxAssetIdentifier(info.IdAsset);
                Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.fxQuotation = info.Quotation;
            }
            else
            {
                // FI 20200623 [XXXXX] SetErrorWarning
                Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + " assente per l'asset [EUR./" + pIdc + "]. (RecCurrencyCounterValueAmount)";
                
                Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdc"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>true if the currency is a commodity</returns>
        private bool RetrieverIsCommodity(string pIdc, string pTradeIdentifier)
        {
            bool isCommodity = false;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDC", DbType.String), pIdc);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " VALUE as VALUE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " ex " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ex.TABLENAME = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.IDENTIFIER  = 'TIPOPRODSPECMERCI'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.ID = @IDC" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALUE"]))
                    {
                        if (Convert.ToString(dr["VALUE"]) != "0")
                            isCommodity = true;
                    }
                }
                else
                {

                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Tipo prodotto specifico merci non valorizzato per la divisa " + pIdc + " .Impostare il valore in anagrafica.";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }

            return isCommodity;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdc"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>returns 525 code for commodity extra info</returns>
        private string RetrieverCode0525(string pIdc, string pTradeIdentifier)
        {
            string code0525 = String.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDC", DbType.String), pIdc);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " VALUE as VALUE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " ex " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ex.TABLENAME = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.IDENTIFIER  = 'TIPOPRODSPECMERCI'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.ID = @IDC" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALUE"]))
                        code0525 = Convert.ToString(dr["VALUE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Il campo Tipo prodotto specifico merci non valorizzato per la divisa " + pIdc + ". Aggiornare l'anagrafica della divisa";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }

            return code0525;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdc"></param>
        /// <param name="pTradeIdentifier"></param>
        /// <returns>returns 183 code for commodity extra info</returns>
        private string RetrieverCode0183(string pIdc, string pTradeIdentifier)
        {
            string code0183 = String.Empty;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDC", DbType.String), pIdc);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + " VALUE as VALUE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EXTLIDS.ToString() + " ex " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "ex.TABLENAME = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.IDENTIFIER  = 'DIGITVALORESOTTOSTANTE'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ex.ID = @IDC" + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALUE"]))
                        code0183 = Convert.ToString(dr["VALUE"]);
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Digit valore sottostante non valorizzato per la divisa " + pIdc + ". Aggiornare l'anagrafica della divisa";
                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                }
            }

            return code0183;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void PayCommodityExtraInfo(Int32 pIdt, string pTradeIdentifier)
        {
            if (Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.isCommodity)
            {
                _ = Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.commodityExtraInfo.code_0183;
                _ = Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.commodityExtraInfo.code_0525;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void RecCommodityExtraInfo(Int32 pIdt, string pTradeIdentifier)
        {
            if (Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.isCommodity)
            {
                _ = Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.commodityExtraInfo.code_0183;
                _ = Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.commodityExtraInfo.code_0525;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        private void Premium(Int32 pIdt, string pTradeIdentifier)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "ec.DTEVENT as PAYMENTDATE, e.IDA_PAY as IDAPAY, e.IDA_REC as IDAREC, e.UNIT as IDC, extl.VALUE as UIC, e.VALORISATION as AMOUNT" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.TRADE.ToString() + " t " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENT + " e " + SQLCst.ON + "(e.IDT = t.IDT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'LPP'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTTYPE = 'PRM'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "(ec.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "ec.EVENTCLASS = 'STL'" + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EXTLIDS + " extl " + SQLCst.ON + "(extl.ID = e.UNIT)" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.TABLENAME)  = 'CURRENCY'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "upper (extl.IDENTIFIER) = 'CODE_UIC'" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "t.IDT = @IDT" + Cst.CrLf;
            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();
            Report.trade.dataDocument.business.fxBarrierOption.premium = new RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionPremium[rows.Length];
            int index = 0;
            foreach (DataRow row in rows)
            {
                RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionPremium premium = new RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionPremium
                {
                    paymentDate = Convert.ToDateTime(row["PAYMENTDATE"]),
                    payerIda = Convert.ToUInt16(row["IDAPAY"]),
                    receiverIda = Convert.ToUInt16(row["IDAREC"]),
                    idc = Convert.ToString(row["IDC"]),
                    uicCurrencyCode = Convert.ToString(row["UIC"]),
                    amount = Convert.ToDecimal(row["AMOUNT"])
                };
                uint mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
                string mainActorIdentifier = Report.trade.dataDocument.repository.mainActor.identifier;
                uint counterpartyIda = Report.trade.dataDocument.repository.counterparty.ida;
                string counterpartyIdentifier = Report.trade.dataDocument.repository.counterparty.identifier;
                // PayerIdentifier
                if (mainActorIda == premium.payerIda)
                    premium.payerIdentifier = mainActorIdentifier;
                else
                    premium.payerIdentifier = counterpartyIdentifier;
                // ReceiverIdenfier
                if (mainActorIda == premium.receiverIda)
                    premium.receiverIdentifier = mainActorIdentifier;
                else
                    premium.receiverIdentifier = counterpartyIdentifier;
                // MainActor Buyer Seller
                if (premium.payerIda == mainActorIda)
                    premium.mainActorPayerReceiver = "PAY";
                else if (premium.receiverIda == mainActorIda)
                    premium.mainActorPayerReceiver = "REC";
                // countervalue section
                if (premium.idc != DomesticCurrency)
                {
                    string pIdc = premium.idc;
                    decimal pIdcAmount = premium.amount;
                    DateTime pFixingDate = Report.trade.header.endDate;
                    CounterValueInfo info = ReadQuote_FXRate(pIdt, pTradeIdentifier, pFixingDate, pIdc, pIdcAmount);
                    //
                    if (info != null)
                    {
                        premium.counterValueAmount = new RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionPremiumCounterValueAmount
                        {
                            idc1 = info.Idc1,
                            idc2 = info.Idc2,
                            quoteBasis = info.QuoteBasis,
                            fixingDate = info.FixingDate,
                            value = info.CounterValue,
                            fxAsset = GetFxAssetIdentifier(info.IdAsset),
                            fxQuotation = info.Quotation
                        };
                    }
                    else
                    {
                        // FI 20200623 [XXXXX] SetErrorWarning
                        Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                        WarningMessage = "Impossibile effettuare la controvalorizzazione. Quotazione del " + pFixingDate + "assente per l'asset [EUR./" + pIdc + "].";
                        
                        Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));
                    }
                }
                premium.id = "premium" + Convert.ToString(index);
                Report.trade.dataDocument.business.fxBarrierOption.premium[index] = premium;
                index++;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        protected override void LinearDepreciationClosingDate(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "ENDDATE", DbType.Date), Report.trade.header.endDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "max (ec.DTEVENT) as CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'LDP' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT <= @ENDDATE " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                // here we istantiate the classes for linear depreciation
                Report.trade.dataDocument.business.closingEvents.InstantiateLinearDepreciation();

                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["CLOSINGDATE"]))
                    {
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = Convert.ToDateTime(dr["CLOSINGDATE"]);
                    }
                }
                else
                {
                    // FI 20200623 [XXXXX] SetErrorWarning
                    Process.ProcessState.SetErrorWarning(ProcessStateTools.StatusWarningEnum);

                    WarningMessage = "Chiusura per l'ammortamento lineare del premio non disponibile. Eseguire il trattamento.";

                    
                    Logger.Log(new LoggerData(LogLevelEnum.Warning, WarningMessage));

                    Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate = DateTime.MinValue;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        protected override void LinearDepreciationReceived(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate);// FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_REC = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount = Convert.ToDecimal(dr["VALORISATION"]);
        }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pTradeIdentifier"></param>
        protected override void LinearDepreciationPaid(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "MAINACTORIDA", DbType.Int32), Report.trade.dataDocument.repository.mainActor.ida);
            parameters.Add(new DataParameter(Cs, "CLOSINGDATE", DbType.Date), Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate); // FI 20201006 [XXXXX] DbType.Date
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "  e.VALORISATION as VALORISATION" + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTCLASS + " ec " + SQLCst.ON + "( ec.IDE = e.IDE )" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.EVENTCLASS = 'CLN' " + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + " e.IDA_PAY = @MAINACTORIDA" + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTCODE = 'CLO' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " e.EVENTTYPE = 'PRM' " + Cst.CrLf;
            sqlSelect += SQLCst.AND + " ec.DTEVENT = @CLOSINGDATE " + Cst.CrLf;
            sqlSelect += SQLCst.AND + "  e.IDT = @IDT " + Cst.CrLf;

            using (IDataReader dr = DataHelper.ExecuteReader(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter()))
            {
                if (dr.Read())
                {
                    if (false == Convert.IsDBNull(dr["VALORISATION"]))
                        Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount = Convert.ToDecimal(dr["VALORISATION"]);
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationNetted()
        {
            decimal received = Report.trade.dataDocument.business.closingEvents.linearDepreciation.receivedAmount;
            decimal paid = Report.trade.dataDocument.business.closingEvents.linearDepreciation.paidAmount;
            decimal netted = (received) - (paid);
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount = netted;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void LinearDepreciationRemaining()
        {

            UInt16 mainActorIda = Report.trade.dataDocument.repository.mainActor.ida;
            UInt16 premiumIdaPay = Report.trade.dataDocument.business.fxBarrierOption.premium[0].payerIda;
            UInt16 premiumIdaRec = Report.trade.dataDocument.business.fxBarrierOption.premium[0].receiverIda;
            decimal totalPremium = Decimal.Zero;
            decimal nettedLinearDepreciation = Report.trade.dataDocument.business.closingEvents.linearDepreciation.nettedAmount;
            decimal LinearDepreciationRemainingAmount = Decimal.Zero;
            //
            for (int i = 0; i < Report.trade.dataDocument.business.fxBarrierOption.premium.Length; i++)
            {
                totalPremium += Report.trade.dataDocument.business.fxBarrierOption.premium[i].amount;
            }
            // temporaryRemainingAmount  sempre negativo
            decimal temporaryRemainingAmount = nettedLinearDepreciation - totalPremium;
            // quando il premio  pagato dal mainactor il remaining  positivo perch  un risconto attivo                
            if (premiumIdaPay == mainActorIda)
                LinearDepreciationRemainingAmount = Decimal.Negate(temporaryRemainingAmount);
            // quando il premio  ricevuto dal mainactor il remaining  negativo perch  un risconto passivo 
            if (premiumIdaRec == mainActorIda)
                LinearDepreciationRemainingAmount = temporaryRemainingAmount;
            //
            Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount = LinearDepreciationRemainingAmount;
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void IntrinsicValue()
        {
            Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule[1];
            int i = 0;
            decimal mtmCleanPrice = Decimal.Zero;
            decimal linearDepreciationRemaining = Decimal.Zero;

            RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule vi = new RegulatoryReportTradeDataDocumentBusinessClosingEventsIntrinsicValuesSchedule();
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                mtmCleanPrice = Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount;
            // if the closing event exist valorize the variable else return 0
            if (null != Report.trade.dataDocument.business.closingEvents.linearDepreciation)
                linearDepreciationRemaining = Report.trade.dataDocument.business.closingEvents.linearDepreciation.linearDepreciationRemainingNettedAmount;
            // calc MTM dirtyPrice (use by IAS intrinsic value)
            decimal mtmDirtyPrice = (mtmCleanPrice) + (linearDepreciationRemaining);
            vi.amount = mtmCleanPrice;
            vi.amountIAS = mtmDirtyPrice;
            Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[i] = vi;
            vi.id = Convert.ToString("intrinsicValue") + Convert.ToString(i);
        }

        /// <summary>
        /// Retrieve Barrier Info for each barrier
        /// </summary>
        /// <param name="pIdt"></param>
        private void FxBarrier(Int32 pIdt)
        {
            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            StrBuilder sqlSelect = new StrBuilder();
            sqlSelect += SQLCst.SELECT + "e.EVENTCODE as EVENTCODE, e.EVENTTYPE as EVENTTYPE, e.IDSTTRIGGER as IDSTTRIGGER, e.VALORISATION as TRIGGERRATE, ed.DTFIXING as DTFIXING, " + Cst.CrLf;
            sqlSelect += "ed.IDC1 as IDC1, ed.IDC2 as IDC2, ed.BASIS as BASIS, ed.RATE as RATE, ed.SPOTRATE as SPOTRATE " + Cst.CrLf;
            sqlSelect += SQLCst.FROM_DBO + Cst.OTCml_TBL.EVENT.ToString() + " e " + Cst.CrLf;
            sqlSelect += SQLCst.INNERJOIN_DBO + Cst.OTCml_TBL.EVENTDET + " ed " + SQLCst.ON + "(ed.IDE = e.IDE)" + Cst.CrLf;
            sqlSelect += SQLCst.WHERE + "e.IDT = @IDT" + Cst.CrLf;
            sqlSelect += SQLCst.AND + "e.EVENTCODE = 'BAR'" + Cst.CrLf;

            DataSet ds = DataHelper.ExecuteDataset(Cs, CommandType.Text, sqlSelect.ToString(), parameters.GetArrayDbParameter());
            DataTable dt = ds.Tables[0];
            DataRow[] rows = dt.Select();

            Report.trade.dataDocument.business.fxBarrierOption.fxBarrier = new RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionFxBarrier[rows.Length];

            int index = 0;

            foreach (DataRow row in rows)
            {
                RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionFxBarrier fxBarrier = new RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionFxBarrier
                {
                    eventCode = Convert.ToString(row["EVENTCODE"]),
                    eventType = Convert.ToString(row["EVENTTYPE"]),
                    triggerStatus = Convert.ToString(row["IDSTTRIGGER"]),
                    triggerRate = Convert.ToDecimal(row["TRIGGERRATE"])
                };

                string barrierType = String.Empty;

                // BAR/UPI: Knock-In
                // BAR/UPO: Knock-Out
                // BAR/DWI: ReverseKnock-In
                // BAR/DWO: ReverseKnock-Out

                switch (fxBarrier.eventType)
                {
                    case "UPI":
                        barrierType = "KnockIn";
                        break;
                    case "UPO":
                        barrierType = "KnockOut";
                        break;
                    case "DWI":
                        barrierType = "ReverseKnockIn";
                        break;
                    case "DWO":
                        barrierType = "ReverseKnockOut";
                        break;
                }

                fxBarrier.type = barrierType;

                // istantiate QuotedCurrencyPair class
                fxBarrier.quotedCurrencyPair = new RegulatoryReportTradeDataDocumentBusinessFxBarrierOptionFxBarrierQuotedCurrencyPair
                {
                    // feed QuotedCurrencyPair fields
                    fixingDate = Convert.ToDateTime(row["DTFIXING"]),
                    currency1 = Convert.ToString(row["IDC1"]),
                    currency2 = Convert.ToString(row["IDC2"]),
                    quoteBasis = Convert.ToString(row["BASIS"]),
                    rate = Convert.ToDecimal(row["RATE"]),
                    spotRate = Convert.ToDecimal(row["SPOTRATE"])
                };

                fxBarrier.id = "fxBarrier" + Convert.ToString(index);
                Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[index] = fxBarrier;
                index++;
            }
        }

        /// <summary>
        /// Call all methods to feed report business section for FxBarrierOption 
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pDerivate"></param>
        /// <param name="pDerivativeBeginDate"></param>
        /// <param name="pActorRepositoryStyle"></param>
        public override void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle)
        {
            this.MainBusinessInfo(pIdt);
            //
            string tradeIdentifier = Report.trade.header.identifier;
            this.IsInTheScope(pIdt);
            this.CheckAccountingCategories(pIdt);
            //
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            //
            if (isInTheScope == true)
            {
                _ = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;
                _ = Report.trade.dataDocument.repository.mainActor.tradeLocalClass;
                this.Repository(pIdt);

                this.AgreementExists(out bool agreementExists);
                if (agreementExists == true)
                {
                    Report.trade.dataDocument.repository.InstantiateMasterAgreement();
                    Report.trade.dataDocument.repository.masterAgreement.isAgreement = true;
                    this.MasterAgreement();
                }

                this.Ndg(pActorRepositoryStyle, tradeIdentifier);
                this.NdgFactorization(pActorRepositoryStyle, tradeIdentifier);
                this.UicCountryCode(tradeIdentifier);
                this.MifidClientCategorisation(tradeIdentifier);
                this.IasDerivativeClassification(tradeIdentifier);
                this.IasHedgedDerivativeClassification(pIdt);
                // istantiate fxBarrierOption element
                Report.trade.dataDocument.business.InstantiateFxBarrierOption();
                //
                this.OptionType(pIdt, tradeIdentifier);
                this.ExerciseStyle(pIdt, tradeIdentifier);
                this.SettlementType(pIdt, tradeIdentifier);
                this.RemainingDuration();
                // ///////////////////////
                // Call and Put Currency
                // ///////////////////////
                this.CallCurrencyAmount(pIdt, tradeIdentifier);
                this.PutCurrencyAmount(pIdt, tradeIdentifier);
                // Call Currency CounterValue
                string pCallIdc = Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.idc;
                if (pCallIdc != DomesticCurrency)
                {
                    this.CallCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // Put Currency CounterValue
                string pPutIdc = Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.idc;
                if (pPutIdc != DomesticCurrency)
                {
                    this.PutCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // ///////////////////////
                // Pay and Rec Currency
                // ///////////////////////
                this.PayCurrencyAmount(pIdt, tradeIdentifier);
                this.RecCurrencyAmount(pIdt, tradeIdentifier);
                // Pay Currency CounterValue
                string pPayIdc = Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.idc;
                if (pPayIdc != DomesticCurrency)
                {
                    this.PayCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
                // Rec Currency CounterValue
                string pRecIdc = Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.idc;
                if (pRecIdc != DomesticCurrency)
                {
                    this.RecCurrencyCounterValueAmount(pIdt, tradeIdentifier);

                    if (Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount == null)
                    {
                        Report.trade.header.isInTheScope = false;
        }
    }
                // ///////////////////////
                // Pay and Rec Commodity
                // ///////////////////////
                this.PayCommodityExtraInfo(pIdt, tradeIdentifier);
                this.RecCommodityExtraInfo(pIdt, tradeIdentifier);

                // ///////////////////////
                // FxBarrier 
                // ///////////////////////
                this.FxBarrier(pIdt);

                // //////////
                if (pDerivate == true && pDerivativeBeginDate != DateTime.MinValue)
                {
                    string product = Report.trade.header.productIdentifier;

                    this.ExchangedCleanCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ExchangedGrossCashFlows(pIdt, tradeIdentifier, pDerivativeBeginDate, product);
                    this.ForwardCleanCashFlows(pIdt, tradeIdentifier, product);
                    this.ForwardGrossCashFlows(pIdt, tradeIdentifier, product);
                }
                // valorize closing events only if the trade is open: if the trade is open and closed this section will be ignored
                if (pIsOpen == true)
                {
                    this.ClosingMTMDate(pIdt, out DateTime closingDate);

                    //// if the closing MTM exists valorize the other events
                    if (closingDate != DateTime.MinValue)
                    {
                        Report.trade.dataDocument.business.InstantiateClosingEvents();
                        Report.trade.dataDocument.business.closingEvents.closingDate = closingDate;
                        Report.trade.dataDocument.business.closingEvents.InstantiateMarkToMarket();
                        this.MTM(pIdt);
                        this.MTMNetted();
                        //
                        if (null != Report.trade.dataDocument.business.fxBarrierOption.premium)
                        {
                            if (Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING" || Report.trade.dataDocument.repository.mainActor.tradeLocalClass == "TRADING+")
                            {
                                // if exists a closing date we instantiale the classes linear depreciation and linear depreciation remaining into LinearDepreciationClosingDate() void. 
                                this.LinearDepreciationClosingDate(pIdt);
                                //
                                if (Report.trade.dataDocument.business.closingEvents.linearDepreciation.closingDate != DateTime.MinValue)
                                {
                                    this.LinearDepreciationReceived(pIdt);
                                    this.LinearDepreciationPaid(pIdt);
                                    this.LinearDepreciationNetted();
                                    this.LinearDepreciationRemaining();
                                }
                            }
                        }
                        Report.trade.dataDocument.business.closingEvents.InstantiateIntrinsicValues();
                        this.IntrinsicValue();
                        Report.trade.dataDocument.business.closingEvents.InstantiateGreeks();
                        this.Greek(pIdt);
                    }
                    // trade is discard (out of the scope) if closingDate is missing
                    else
                    {
                        Report.trade.header.isInTheScope = false;
                    }
                }
            }
        }

    }

    /// <summary>
    /// Feed report business section for FxDigitalOption
    /// incomplete section
    /// </summary>
    public class RRBusinessFxDigitalOption : RRBusiness
    {
        public RRBusinessFxDigitalOption(string pCs, string pDomesticCurrency, ProcessBase pProcess, RegulatoryReport pReport, DateTime pBeginDate, DateTime pEndDate, DateTime pOpenAndClosedBeginDate, DateTime pDerivativeBeginDate, string pInstrumentIdentifier, string pActorRepositoryStyle)
            : base(pCs, pDomesticCurrency, pProcess, pReport, pBeginDate, pEndDate, pOpenAndClosedBeginDate, pDerivativeBeginDate, pInstrumentIdentifier, pActorRepositoryStyle)
        {
        }



        /// <summary>
        /// Call all methods to feed report business section for FxDigitalOption 
        /// REMARK: this method is empty
        /// </summary>
        /// <param name="pIdt"></param>
        /// <param name="pIsOpen"></param>
        /// <param name="pDerivate"></param>
        /// <param name="pDerivativeBeginDate"></param>
        /// <param name="pActorRepositoryStyle"></param>
        public override void FeedReportBusiness(Int32 pIdt, Boolean pIsOpen, Boolean pDerivate, DateTime pDerivativeBeginDate, string pActorRepositoryStyle)
        {
        }
    }

    /// <summary>
    /// Feed report section  
    /// </summary>
    public class RRPuma2
    {
        #region Members
        private string m_DomesticCurrency;
        protected RegulatoryReport m_Report;
        private RRFormaTecnica m_RRFormaTecnica;
        private RRGetBusinessInfos m_GetBusinessInfos;
        protected string m_NumberOfDecimalsAfterSeparator;
        #endregion
        #region Accessors
        public string DomesticCurrency
        {
            get { return this.m_DomesticCurrency; }
            set { this.m_DomesticCurrency = value; }
        }
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public RRFormaTecnica RRFormaTecnica
        {
            get { return this.m_RRFormaTecnica; }
            set { this.m_RRFormaTecnica = value; }
        }
        public RRGetBusinessInfos GetBusinessInfos
        {
            get { return this.m_GetBusinessInfos; }
            set { this.m_GetBusinessInfos = value; }
        }
        public string NumberOfDecimalsAfterSeparator
        {
            get { return this.m_NumberOfDecimalsAfterSeparator; }
        }
        #endregion
        #region constructor
        public RRPuma2(string pDomesticCurrency, RegulatoryReport pReport)
        {
            m_DomesticCurrency = pDomesticCurrency;
            Report = pReport;
            m_NumberOfDecimalsAfterSeparator = "0000"; // 4 decimal after the separator
        }
        #endregion constructor

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        virtual protected int CountFormaTecnica()
        {
            return int.MinValue;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="pSubSystem"></param>
        /// <param name="Log"></param>
        virtual public void FeedReportPuma2(string pSubSystem, RRLog Log)
        {
        }

        /// <summary>
        /// Count past cashflow from exchengedCashFlows business section  
        /// Only no resident counterparty is counted 
        /// </summary>
        /// <returns></returns>
        protected int CountExchangedCashFlows()
        {
            int count = 0;
            bool isCounterpartyResident = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;

            if (isCounterpartyResident == false)
            {
                if (null != Report.trade.dataDocument.business.exchangedCashFlows)
                {
                    if (null != Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows)
                    {
                        for (int exchangedCashFlowsIndex = 0; exchangedCashFlowsIndex < Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows.Length; exchangedCashFlowsIndex++)
                        {
                            count++;
                        }
                    }
                    return count;
                }
                return count;
            }
            return count;
        }

        /// <summary>
        /// Count future cashflow from forwardCashFlows business section
        /// From Puma2 documentation "Vanno dichiarati solo i derivati finanziari con contratti senza scambio di capitale"
        /// </summary>
        /// <returns></returns>
        protected int CountForwardCashFlows()
        {
            int count = 0;
            string localClass = Report.trade.dataDocument.repository.mainActor.tradeLocalClass;
            //
            if (localClass == "COPERTURA")
            {
                // returns count = 0 when gross cash flow tags is null 
                if (null != Report.trade.dataDocument.business.forwardCashFlows)
                {
                    if (null != Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows)
                    {
                        for (int forwardCashFlowsIndex = 0; forwardCashFlowsIndex < Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows.Length; forwardCashFlowsIndex++)
                        {
                            DateTime settlementDate = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[forwardCashFlowsIndex].settlementDate;
                            DateTime endOfExercise = Report.trade.header.endDate.AddMonths(12);
                            DateTime endDate = Report.trade.header.endDate;
                            /// Not all cash flow must be declared in Puma2: only the ones having a settlement date lower than one year
                            if (settlementDate > endDate & settlementDate <= endOfExercise)
                                count++;
                        }
                    }
                    return count;
                }
                return count;
            }
            return count;
        }

        /// <summary>
        /// return by one increased index
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        protected int IncrementFormaTecnicaIndex(int pIndex)
        {
            int incrementedIndex = pIndex + 1;
            return incrementedIndex;
        }

        /// <summary>
        /// returns next ForwardCashFlows index
        /// </summary>
        /// <param name="pForwardCashFlowsIndex"></param>
        /// <returns></returns>
        protected int GetNextForwardCashFlowsIndex(ref int pForwardCashFlowsIndex)
        {
            string localClass = Report.trade.dataDocument.repository.mainActor.tradeLocalClass;

            if (localClass == "COPERTURA")
            {
                if (null != Report.trade.dataDocument.business.forwardCashFlows)
                {
                    if (null != Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows)
                    {
                        for (; pForwardCashFlowsIndex < Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows.Length; pForwardCashFlowsIndex++)
                        {
                            DateTime settlementDate = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pForwardCashFlowsIndex].settlementDate;
                            DateTime endOfExercise = Report.trade.header.endDate.AddMonths(12);
                            DateTime endDate = Report.trade.header.endDate;
                            if (settlementDate > endDate & settlementDate <= endOfExercise)
                                return pForwardCashFlowsIndex;
                        }
                    }
                    return -1;
                }
                return -1;
            }
            return -1;
        }

        /// <summary>
        /// Returns gross cash flow from specific exchangedCashFlows index into business section
        /// </summary>
        /// <returns>Netting of past cash flow</returns>
        protected decimal GetExchangedNettedCashFlow(int pExchangedGrossCashFlowsIndex)
        {
            return Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pExchangedGrossCashFlowsIndex].amount;
        }

        /// <summary>
        ///  Returns gross cash flow from specific forwardCashFlows index into business section
        /// </summary>
        /// <returns>Netting of forward cash flow </returns>
        protected decimal GetForwardNettedCashFlow(int pForwardCashFlowsIndex)
        {
            return Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pForwardCashFlowsIndex].amount;
        }
    }

    /// <summary>
    /// Feed report section for swap
    /// </summary>
    public class RRPuma2Swap : RRPuma2
    {
        public RRPuma2Swap(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRFormaTecnica = new RRFormaTecnicaSwap(pDomesticCurrency, pReport);
            GetBusinessInfos = new RRGetBusinessInfosSwap(pReport);
        }

        /// <summary>
        /// Build report section for swap
        /// The first report node is a Banca d'Italia report (attribute name=bancaItalia)
        /// The second report node depends on subSystem (attribute name=elsag or oasi)
        /// /// </summary>
        /// <param name="pSubSystem">available values: SDBMatrix-Elsag / Seceti-Oasi</param>
        /// <param name="pLog"></param>
        public override void FeedReportPuma2(string pSubSystem, RRLog pLog)
        {
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            string subSystem = pSubSystem;
            //
            if (isInTheScope == true)
            {
                //
                Report.report = new RegulatoryReportReport[2];
                Report.log = new RegulatoryReportLog[2];
                //
                RegulatoryReportReport ReportBancaItalia = new RegulatoryReportReport();
                Report.report[0] = ReportBancaItalia;
                ReportBancaItalia.name = Convert.ToString("bancaItalia");
                this.BuildFormeTecnicheBancaItalia(ReportBancaItalia);
                pLog.FeedReportLog(Report, ReportBancaItalia);
                //
                if (subSystem == "SDBMatrix-Elsag")
                {
                    RegulatoryReportReport ReportElsag = new RegulatoryReportReport();
                    Report.report[1] = ReportElsag;
                    ReportElsag.name = Convert.ToString("elsag");
                    this.BuildFormeTecnicheElsag(ReportElsag);
                    pLog.FeedReportLog(Report, ReportElsag);
                }
                //
                if (subSystem == "Seceti-Oasi")
                {
                    RegulatoryReportReport ReportOasi = new RegulatoryReportReport();
                    Report.report[1] = ReportOasi;
                    ReportOasi.name = Convert.ToString("oasi");
                    this.BuildFormeTecnicheOasi(ReportOasi);
                    pLog.FeedReportLog(Report, ReportOasi);
                }
            }
        }

        /// <summary>
        /// Return 1 for a swap zero coupon
        /// </summary>
        /// <returns></returns>
        private int CountZeroCouponStream()
        {
            int count = 0;

            if (Report.trade.dataDocument.business.swap.productType == "SWAP-ZERO-COUPON")
                count = 1;
            return count;
        }

        /// <summary>
        /// Count all business nodes that contribute to build all "forme tecniche"
        /// Open trades: notionalSchedule, zero coupon streams, past cash flows and futures cash flows
        /// Open and losed trades: notionalSchedule and zero coupon streams
        /// </summary>
        /// <returns></returns>
        protected override int CountFormaTecnica()
        {
            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            //
            if (isOpen == true & isOpenAndClosed == false)
                return Report.trade.dataDocument.business.swap.nominal.notionalSchedule.Length + CountZeroCouponStream() + CountExchangedCashFlows() + CountForwardCashFlows();
            if (isOpen == false & isOpenAndClosed == true)
                return Report.trade.dataDocument.business.swap.nominal.notionalSchedule.Length + CountZeroCouponStream();
            else return 0;
        }

        /// <summary>
        /// Build Banca d'Italia report section on report
        /// Build the first report section (attribute name=bancaItalia)
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        private void BuildFormeTecnicheBancaItalia(RegulatoryReportReport pReportBancaItalia)
        {
            pReportBancaItalia.formaTecnica = new RegulatoryReportReportFormaTecnica[CountFormaTecnica()];

            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            bool isOpen = GetBusinessInfos.GetIsOpen();
            string productType = GetBusinessInfos.GetProductType();
            string receivedRateType = GetBusinessInfos.GetReceivedRateType();
            int formaTecnicaIndex = 0;
            while (formaTecnicaIndex < Report.trade.dataDocument.business.swap.nominal.notionalSchedule.Length)
            {
                //Open Trades
                if (isOpen == true)
                {
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                    if ((productType == "SWAP-FLOATING-FLOATING") | ((productType == "SWAP-FIXED-FLOATING") & (receivedRateType == "FIX")))
                        RRFormaTecnica.BuildFormaTecnica_0159301(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);

                    if ((productType == "SWAP-FIXED-FLOATING") & (receivedRateType == "FLO"))
                        RRFormaTecnica.BuildFormaTecnica_0159305(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);

                    if ((productType == "SWAP-ZERO-COUPON") && (receivedRateType == "KNA"))
                    {
                        RRFormaTecnica.BuildFormaTecnica_0159301(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                        RRFormaTecnica.BuildFormaTecnica_0159301(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex - 1);
                    }

                    if ((productType == "SWAP-ZERO-COUPON") && (receivedRateType == "FIX" || receivedRateType == "FLO"))
                    {
                        RRFormaTecnica.BuildFormaTecnica_0159305(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                        RRFormaTecnica.BuildFormaTecnica_0159305(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex - 1);
                    }

                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);

                }
                //Open and Closed Trades
                if (isOpenAndClosed == true)
                {
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                    if ((productType == "SWAP-FLOATING-FLOATING") | ((productType == "SWAP-FIXED-FLOATING") & (receivedRateType == "FIX")))
                        RRFormaTecnica.BuildFormaTecnica_0159388(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                    if ((productType == "SWAP-FIXED-FLOATING") & (receivedRateType == "FLO"))
                        RRFormaTecnica.BuildFormaTecnica_0159389(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);

                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }

            // if trade is open returns paid received cash flows FT (58195.02 e 58195.05)
            bool isCounterpartyResident = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;

            if (isOpen == true & isCounterpartyResident == false & CountExchangedCashFlows() != 0)
            {
                // only if grossCashFlows is not empty
                if (null != Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows)
                {
                    for (int exchangedCashFlowsIndex = 0; exchangedCashFlowsIndex < Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows.Length; exchangedCashFlowsIndex++)
                    {
                        decimal nettedCashFlow = Convert.ToDecimal(GetExchangedNettedCashFlow(exchangedCashFlowsIndex));
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                        if (nettedCashFlow > 0)
                            RRFormaTecnica.BuildFormaTecnica_5819502(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        if (nettedCashFlow <= 0)
                            RRFormaTecnica.BuildFormaTecnica_5819506(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                    }
                }
            }
            // if trade is open returns forward cash flows FT (03903.04  e 03903.06)
            if (isOpen == true & CountForwardCashFlows() != 0)
            {
                int forwardCashFlowsIndex = 0;
                int businessForwardCashFlowIndex =  GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                while (businessForwardCashFlowIndex >= 0)
                {
                    decimal nettedCashFlow = Convert.ToDecimal(GetForwardNettedCashFlow(forwardCashFlowsIndex));
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                    // declared in FT 03903.04 when cash flow are positive 
                    if (nettedCashFlow > 0)
                        RRFormaTecnica.BuildFormaTecnica_0390304(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);
                    // declared in FT 03903.06 when cash flows are negative 
                    if (nettedCashFlow <= 0)
                        RRFormaTecnica.BuildFormaTecnica_0390306(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);
                    businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }
        }

        /// <summary>
        /// Build Elsag report section on report according Elsag rules
        /// Build the second report section (attribute name=elsag)
        /// </summary>
        /// <param name="pReportElsag"></param>
        private void BuildFormeTecnicheElsag(RegulatoryReportReport pReportElsag)
        {
            int BkIFormaTecnicaCount = Report.report[0].formaTecnica.Length;

            pReportElsag.formaTecnica = new RegulatoryReportReportFormaTecnica[BkIFormaTecnicaCount];

            for (int formaTecnicaIndex = 0; formaTecnicaIndex < Report.report[0].formaTecnica.Length; formaTecnicaIndex++)
            {
                pReportElsag.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                string formaTecnicaName = Report.report[0].formaTecnica[formaTecnicaIndex].name;

                int outDataIndex = 0;
                switch (formaTecnicaName)
                {
                    case "01593.01":
                        RRFormaTecnica.BuildFormaTecnicaElsag_0159301(pReportElsag, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01593.05":
                        RRFormaTecnica.BuildFormaTecnicaElsag_0159305(pReportElsag, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01593.88":
                        //to do
                        break;
                    case "01593.89":
                        //to do
                        break;
                    case "58195.02":
                        //to do
                        break;
                    case "58195.06":
                        //to do
                        break;
                    case "03903.04":
                        //to do
                        break;
                    case "03903.06":
                        //to do
                        break;
                }
                // Add static values from DataLayout
                RRDataLayout.HandleStaticData(pReportElsag.formaTecnica[formaTecnicaIndex], outDataIndex);
            }
        }

        /// <summary>
        /// Build Oasi report section on report according Oasi rules
        /// Build the second report section (attribute name=oasi)
        /// </summary>
        /// <param name="pReportOasi"></param>
        private void BuildFormeTecnicheOasi(RegulatoryReportReport pReportOasi)
        {
            int BkIFormaTecnicaCount = Report.report[0].formaTecnica.Length;
            pReportOasi.formaTecnica = new RegulatoryReportReportFormaTecnica[BkIFormaTecnicaCount];
            for (int formaTecnicaIndex = 0; formaTecnicaIndex < BkIFormaTecnicaCount; formaTecnicaIndex++)
            {
                string formaTecnicaName = Report.report[0].formaTecnica[formaTecnicaIndex].name;
                pReportOasi.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                int outDataIndex = 0;
                switch (formaTecnicaName)
                {
                    // Build TIT70 FT
                    case "01593.01":
                    case "01593.05":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT70(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    // Build AIM84 FT
                    case "01593.88":
                    case "01593.89":
                        RRFormaTecnica.BuildFormaTecnicaOasi_AIM84(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    // Build PMD03 FT
                    case "58195.02":
                    case "58195.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_PMD03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    // Build DIF03 FT
                    case "03903.04":
                    case "03903.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_DIF03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                }
                RRDataLayout.HandleStaticData(pReportOasi.formaTecnica[formaTecnicaIndex], outDataIndex);
            }
        }
    }

    /// <summary>
    /// Feed report section for capFloor
    /// </summary>
    public class RRPuma2Cap : RRPuma2
    {
        public RRPuma2Cap(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRFormaTecnica = new RRFormaTecnicaCap(pDomesticCurrency, pReport);
            GetBusinessInfos = new RRGetBusinessInfosCap(pReport);
        }

        /// <summary>
        /// Count all business nodes that contribute to build all caplet "forme tecniche"
        /// </summary>
        /// <returns></returns>
        private int CountCapLetsFloorLets()
        {
            int count = 0;
            // returns count = 0 when capLetsFloorLets flow tags is null 
            if (null != Report.trade.dataDocument.business.closingEvents.capLetsFloorLets)
            {
                if (null != Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule)
                {
                    for (int capLetsFloorLetsIndex = 0; capLetsFloorLetsIndex < Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule.Length; capLetsFloorLetsIndex++)
                    {
                        count++;
                    }
                }
                return count;
            }
            return count;
        }

        /// <summary>
        /// Build report section for capFloor
        /// The first report node is a Banca d'Italia report (attribute name=bancaItalia)
        /// The second report node depends on subSystem (attribute name=elsag or oasi)
        /// </summary>
        /// <param name="pSubSystem"></param>
        /// <param name="pLog"></param>
        public override void FeedReportPuma2(string pSubSystem, RRLog pLog)
        {
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            string subSystem = pSubSystem;
            if (isInTheScope == true)
            {
                Report.report = new RegulatoryReportReport[2];
                Report.log = new RegulatoryReportLog[2];
                RegulatoryReportReport ReportBancaItalia = new RegulatoryReportReport();
                Report.report[0] = ReportBancaItalia;
                ReportBancaItalia.name = Convert.ToString("bancaItalia");
                this.BuildFormeTecnicheBancaItalia(ReportBancaItalia);
                pLog.FeedReportLog(Report, ReportBancaItalia);

                // to do: elsag section for capFloor
                //
                //if (subSystem == "SDBMatrix-Elsag")
                //{
                //    RegulatoryReportReport ReportElsag = new RegulatoryReportReport();
                //    Report.report[1] = ReportElsag;
                //    ReportElsag.name = Convert.ToString("elsag");
                //    this.BuildFormeTecnicheElsag(ReportElsag);
                //    pLog.FeedReportLog(Report, ReportElsag);
                //}

                if (subSystem == "Seceti-Oasi")
                {
                    RegulatoryReportReport ReportOasi = new RegulatoryReportReport();
                    Report.report[1] = ReportOasi;
                    ReportOasi.name = Convert.ToString("oasi");
                    this.BuildFormeTecnicheOasi(ReportOasi);
                    pLog.FeedReportLog(Report, ReportOasi);
                }
            }
        }

        /// <summary>
        /// Count all business nodes that contribute to build all "forme tecniche"
        /// Open trades: notionalSchedule, caplet or floorlet, past cash flows and futures cash flows
        /// Open and losed trades: notionalSchedule
        /// </summary>
        /// <returns></returns>
        protected override int CountFormaTecnica()
        {
            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            //                
            if (isOpen == true & isOpenAndClosed == false)
                return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length + CountExchangedCashFlows() + CountForwardCashFlows() + CountCapLetsFloorLets();
            if (isOpen == false & isOpenAndClosed == true)
                return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length;
            else return 0;
        }

        /// <summary>
        /// Build Banca d'Italia report section on report
        /// Build the first report section (attribute name=bancaItalia)
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        private void BuildFormeTecnicheBancaItalia(RegulatoryReportReport pReportBancaItalia)
        {
            pReportBancaItalia.formaTecnica = new RegulatoryReportReportFormaTecnica[CountFormaTecnica()];
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            bool isOpen = GetBusinessInfos.GetIsOpen();
            int formaTecnicaIndex = 0;

            while (formaTecnicaIndex < Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule.Length)
            {
                string productType = GetBusinessInfos.GetProductType();
                string mainActorBuyerSeller = GetBusinessInfos.GetMainActorBuyerSeller();
                // Open 
                if (isOpen == true)
                {
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                    if (((productType == "CAP") & (mainActorBuyerSeller == "Seller")) | ((productType == "FLOOR") & (mainActorBuyerSeller == "Buyer")))
                        RRFormaTecnica.BuildFormaTecnica_0159301(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                    if (((productType == "CAP") & (mainActorBuyerSeller == "Buyer")) | ((productType == "FLOOR") & (mainActorBuyerSeller == "Seller")))
                        RRFormaTecnica.BuildFormaTecnica_0159305(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);

                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
                // Open and Closed
                if (isOpenAndClosed == true)
                {
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                    if (((productType == "CAP") & (mainActorBuyerSeller == "Seller")) | ((productType == "FLOOR") & (mainActorBuyerSeller == "Buyer")))
                        RRFormaTecnica.BuildFormaTecnica_0159388(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                    if (((productType == "CAP") & (mainActorBuyerSeller == "Buyer")) | ((productType == "FLOOR") & (mainActorBuyerSeller == "Seller")))
                        RRFormaTecnica.BuildFormaTecnica_0159389(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }
            // if trade is open returns paid received cash flows FT (58195.02 e 58195.05)
            bool isCounterpartyResident = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;

            if (isOpen == true & isCounterpartyResident == false & CountExchangedCashFlows() != 0)
            {
                // only if grossCashFlows is not empty                    
                if (null != Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows)
                {

                    for (int exchangedCashFlowsIndex = 0; exchangedCashFlowsIndex < Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows.Length; exchangedCashFlowsIndex++)
                    {
                        Decimal nettedCashFlow = GetExchangedNettedCashFlow(exchangedCashFlowsIndex);
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                        if (nettedCashFlow > 0)
                            RRFormaTecnica.BuildFormaTecnica_5819502(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        if (nettedCashFlow <= 0)
                            RRFormaTecnica.BuildFormaTecnica_5819506(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);

                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                    }
                }
            }
            // if trade is open returns forward cash flows FT (03903.04  e 03903.06)
            if (isOpen == true & CountForwardCashFlows() != 0)
            {
                int forwardCashFlowsIndex = 0;
                int businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                while (businessForwardCashFlowIndex >= 0)
                {
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                    Decimal nettedCashFlow = GetForwardNettedCashFlow(forwardCashFlowsIndex);
                    if (nettedCashFlow > 0)
                        RRFormaTecnica.BuildFormaTecnica_0390304(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);
                    if (nettedCashFlow <= 0)
                        RRFormaTecnica.BuildFormaTecnica_0390306(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);
                    //
                    businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }
            // if trade is open returns caplet and floorlet (01593.98 e 01593.99)
            // 01593.98: Vendita Cap/Acquisto Floor
            // 01593.99: Acquisto Cap/Vendita Floor
            // only if capLetsFloorLets is not empty
            if (isOpen == true & null != Report.trade.dataDocument.business.closingEvents.capLetsFloorLets)
            {
                for (int capLetFloorLetIndex = 0; capLetFloorLetIndex < Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule.Length; capLetFloorLetIndex++)
                {
                    string mainActorBuyerSeller = GetBusinessInfos.GetMainActorBuyerSeller();
                    string productType = GetBusinessInfos.GetProductType();
                    //
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                    //
                    if ((productType == "CAP" & mainActorBuyerSeller == "Seller") | (productType == "FLOOR" & mainActorBuyerSeller == "Buyer"))
                        RRFormaTecnica.BuildFormaTecnica_0159398(pReportBancaItalia, formaTecnicaIndex, capLetFloorLetIndex);
                    if ((productType == "CAP" & mainActorBuyerSeller == "Buyer") | (productType == "FLOOR" & mainActorBuyerSeller == "Seller"))
                        RRFormaTecnica.BuildFormaTecnica_0159399(pReportBancaItalia, formaTecnicaIndex, capLetFloorLetIndex);
                    //
                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }
        }

        /// <summary>
        /// Build Oasi report section on report according oasi rules
        /// Build the second report section (attribute name=oasi) 
        /// </summary>
        /// <param name="pReportOasi"></param>
        private void BuildFormeTecnicheOasi(RegulatoryReportReport pReportOasi)
        {
            int BkIFormaTecnicaCount = Report.report[0].formaTecnica.Length;
            pReportOasi.formaTecnica = new RegulatoryReportReportFormaTecnica[BkIFormaTecnicaCount];
            for (int formaTecnicaIndex = 0; formaTecnicaIndex < BkIFormaTecnicaCount; formaTecnicaIndex++)
            {
                string formaTecnicaName = Report.report[0].formaTecnica[formaTecnicaIndex].name;
                pReportOasi.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                int outDataIndex = 0;
                switch (formaTecnicaName)
                {
                    case "01593.01":
                    case "01593.05":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT70(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01593.98":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT81(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01593.99":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT82(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01593.88":
                    case "01593.89":
                        RRFormaTecnica.BuildFormaTecnicaOasi_AIM84(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "58195.02":
                    case "58195.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_PMD03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "03903.04":
                    case "03903.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_DIF03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                }
                RRDataLayout.HandleStaticData(pReportOasi.formaTecnica[formaTecnicaIndex], outDataIndex);
            }
        }
    }


    /// <summary>
    /// Feed report section for BondOption
    /// </summary>
    public class RRPuma2BondOption : RRPuma2
    {
        public RRPuma2BondOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRFormaTecnica = new RRFormaTecnicaBondOption(pDomesticCurrency, pReport);
            GetBusinessInfos = new RRGetBusinessInfosBondOption(pReport);
        }

        /// <summary>
        /// Build report section for fxSimpleOption
        /// The first report node is a Banca d'Italia report (attribute name=bancaItalia)
        /// The second report node depends on subSystem (attribute name=elsag or oasi) 
        /// </summary>
        /// <param name="pSubSystem"></param>
        /// <param name="pLog"></param>
        public override void FeedReportPuma2(string pSubSystem, RRLog pLog)
        {
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            string subSystem = pSubSystem;
            //
            if (isInTheScope == true)
            {
                //
                Report.report = new RegulatoryReportReport[2];
                Report.log = new RegulatoryReportLog[2];
                //
                RegulatoryReportReport ReportBancaItalia = new RegulatoryReportReport();
                Report.report[0] = ReportBancaItalia;
                ReportBancaItalia.name = Convert.ToString("bancaItalia");
                this.BuildFormeTecnicheBancaItalia(ReportBancaItalia);
                pLog.FeedReportLog(Report, ReportBancaItalia);
                //
                if (subSystem == "Seceti-Oasi")
                {
                    RegulatoryReportReport ReportOasi = new RegulatoryReportReport();
                    Report.report[1] = ReportOasi;
                    ReportOasi.name = Convert.ToString("oasi");
                    this.BuildFormeTecnicheOasi(ReportOasi);
                    pLog.FeedReportLog(Report, ReportOasi);
                }
            }
        }

        /// <summary>
        /// Count all business nodes that contribute to build all "forme tecniche"
        /// Open trades: 1 FT for trade + past cash flows and futures cash flows
        /// Open and losed trades: 1 FT for trade
        /// </summary>
        /// <returns></returns>
        protected override int CountFormaTecnica()
        {

            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();

            if (isOpen == true & isOpenAndClosed == false)
                return 1 + CountExchangedCashFlows();
            if (isOpen == false & isOpenAndClosed == true)
                return 1;
            else return 0;
        }

        /// <summary>
        /// Build Banca d'Italia report section on report
        /// Build the first report section (attribute name=bancaItalia)
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        private void BuildFormeTecnicheBancaItalia(RegulatoryReportReport pReportBancaItalia)
        {
            pReportBancaItalia.formaTecnica = new RegulatoryReportReportFormaTecnica[CountFormaTecnica()];
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            bool isOpen = GetBusinessInfos.GetIsOpen();
            int formaTecnicaIndex = 0;

            string optionType = GetBusinessInfos.GetOptionType();
            string mainActorBuyerSeller = GetBusinessInfos.GetMainActorBuyerSeller();

            /// <summary>
            /// FT (1593.01 e 1593.05)
            /// Open declaration
            /// </summary> 
            if (isOpen == true)
            {
                pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                // 01593.01: Dichiarante vende Call o compra Put
                // 01593.05: Dichiarante compra Call o vende Put
                if (((optionType == "Call") & (mainActorBuyerSeller == "Seller")) | ((optionType == "Put") & (mainActorBuyerSeller == "Buyer")))
                    RRFormaTecnica.BuildFormaTecnica_0159301(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                if (((optionType == "Call") & (mainActorBuyerSeller == "Buyer")) | ((optionType == "Put") & (mainActorBuyerSeller == "Seller")))
                    RRFormaTecnica.BuildFormaTecnica_0159305(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);

                formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
            }

            /// <summary>
            /// FT (1593.88 e 1593.89)
            /// Open and closed declaration
            /// </summary> 
            if (isOpenAndClosed == true)
            {
                pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                // 01593.88: Dichiarante vende CALL o compra PUT
                // 01593.89: Dichiarante compra CALL o vende PUT
                if (((optionType == "Call") & (mainActorBuyerSeller == "Seller")) | ((optionType == "Put") & (mainActorBuyerSeller == "Buyer")))
                    RRFormaTecnica.BuildFormaTecnica_0159388(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                if (((optionType == "Call") & (mainActorBuyerSeller == "Buyer")) | ((optionType == "Put") & (mainActorBuyerSeller == "Seller")))
                    RRFormaTecnica.BuildFormaTecnica_0159389(pReportBancaItalia, formaTecnicaIndex, formaTecnicaIndex);
                formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
            }

            /// <summary>
            /// FT (58195.02 e 58195.05)
            /// exchanged cash flows 
            /// </summary>  
            bool isCounterpartyResident = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;

            if (isOpen == true & isCounterpartyResident == false & CountExchangedCashFlows() != 0)
            {
                // only if grossCashFlows is not empty                    
                if (null != Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows)
                {

                    for (int exchangedCashFlowsIndex = 0; exchangedCashFlowsIndex < Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows.Length; exchangedCashFlowsIndex++)
                    {
                        Decimal nettedCashFlow = GetExchangedNettedCashFlow(exchangedCashFlowsIndex);
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                        if (nettedCashFlow > 0)
                            RRFormaTecnica.BuildFormaTecnica_5819502(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        if (nettedCashFlow <= 0)
                            RRFormaTecnica.BuildFormaTecnica_5819506(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);

                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                    }
                }
            }
        }

        /// <summary>
        /// Build Oasi report section on report according oasi rules
        /// Build the second report section (attribute name=oasi) 
        /// </summary>
        /// <param name="pReportOasi"></param>
        private void BuildFormeTecnicheOasi(RegulatoryReportReport pReportOasi)
        {
            int BkIFormaTecnicaCount = Report.report[0].formaTecnica.Length;
            pReportOasi.formaTecnica = new RegulatoryReportReportFormaTecnica[BkIFormaTecnicaCount];
            for (int formaTecnicaIndex = 0; formaTecnicaIndex < BkIFormaTecnicaCount; formaTecnicaIndex++)
            {
                string formaTecnicaName = Report.report[0].formaTecnica[formaTecnicaIndex].name;
                pReportOasi.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                int outDataIndex = 0;
                switch (formaTecnicaName)
                {
                    /// TIT.70
                    case "01593.01":
                    case "01593.05":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT70(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    /// AIM.84
                    case "01593.88":
                    case "01593.89":
                        RRFormaTecnica.BuildFormaTecnicaOasi_AIM84(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    /// PMD.03 
                    case "58195.02":
                    case "58195.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_PMD03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                }
                RRDataLayout.HandleStaticData(pReportOasi.formaTecnica[formaTecnicaIndex], outDataIndex);
            }
        }
    }


    /// <summary>
    /// Feed report section for fxSimpleOption
    /// </summary>
    public class RRPuma2FxSimpleOption : RRPuma2
    {
        public RRPuma2FxSimpleOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRFormaTecnica = new RRFormaTecnicaFxSimpleOption(pDomesticCurrency, pReport);
            GetBusinessInfos = new RRGetBusinessInfosFxSimpleOption(pReport);
        }

        /// <summary>
        /// Build report section for fxSimpleOption
        /// The first report node is a Banca d'Italia report (attribute name=bancaItalia)
        /// The second report node depends on subSystem (attribute name=elsag or oasi) 
        /// </summary>
        /// <param name="pSubSystem"></param>
        /// <param name="pLog"></param>
        public override void FeedReportPuma2(string pSubSystem, RRLog pLog)
        {
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            string subSystem = pSubSystem;
            //
            if (isInTheScope == true)
            {
                //
                Report.report = new RegulatoryReportReport[2];
                Report.log = new RegulatoryReportLog[2];
                //
                RegulatoryReportReport ReportBancaItalia = new RegulatoryReportReport();
                Report.report[0] = ReportBancaItalia;
                ReportBancaItalia.name = Convert.ToString("bancaItalia");
                this.BuildFormeTecnicheBancaItalia(ReportBancaItalia);
                pLog.FeedReportLog(Report, ReportBancaItalia);
                //
                if (subSystem == "SDBMatrix-Elsag")
                {
                    RegulatoryReportReport ReportElsag = new RegulatoryReportReport();
                    Report.report[1] = ReportElsag;
                    ReportElsag.name = Convert.ToString("elsag");
                    this.BuildFormeTecnicheElsag(ReportElsag);
                    pLog.FeedReportLog(Report, ReportElsag);
                }
                //
                if (subSystem == "Seceti-Oasi")
                {
                    RegulatoryReportReport ReportOasi = new RegulatoryReportReport();
                    Report.report[1] = ReportOasi;
                    ReportOasi.name = Convert.ToString("oasi");
                    this.BuildFormeTecnicheOasi(ReportOasi);
                    pLog.FeedReportLog(Report, ReportOasi);
                }
            }
        }

        /// <summary>
        /// Count all business nodes that contribute to build all "forme tecniche"
        /// Open trades: 1 FT for trade + past cash flows and futures cash flows
        /// Open and losed trades: 1 FT for trade
        /// </summary>
        /// <returns></returns>
        protected override int CountFormaTecnica()
        {

            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();

            if (isOpen == true & isOpenAndClosed == false)
                return 1 + CountExchangedCashFlows() + CountForwardCashFlows();
            if (isOpen == false & isOpenAndClosed == true)
                return 1;
            else return 0;
        }

        /// <summary>
        /// Build Banca d'Italia report section on report
        /// Build the first report section (attribute name=bancaItalia) 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        private void BuildFormeTecnicheBancaItalia(RegulatoryReportReport pReportBancaItalia)
        {
            pReportBancaItalia.formaTecnica = new RegulatoryReportReportFormaTecnica[CountFormaTecnica()];
            int formaTecnicaIndex = 0;
            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            bool isCommodityPayCurrency = GetBusinessInfos.GetPayCurrencyIsCommodity();
            string idcPay = GetBusinessInfos.GetPayCurrencyIdc();
            bool isCommodityRecCurrency = GetBusinessInfos.GetRecCurrencyIsCommodity();
            string idcRec = GetBusinessInfos.GetRecCurrencyIdc();

            if (isOpen == true)
            {
                pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                if (isCommodityPayCurrency == false & isCommodityRecCurrency == false)
                {
                    if (idcPay != "EUR" & idcRec != "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159701(pReportBancaItalia, formaTecnicaIndex);
                    if (idcPay == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159705(pReportBancaItalia, formaTecnicaIndex);
                    if (idcRec == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159709(pReportBancaItalia, formaTecnicaIndex);
                }
                if (isCommodityRecCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159713(pReportBancaItalia, formaTecnicaIndex);
                if (isCommodityPayCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159717(pReportBancaItalia, formaTecnicaIndex);
                formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
            }
            if (isOpenAndClosed == true)
            {
                pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                if (isCommodityPayCurrency == false & isCommodityRecCurrency == false)
                {
                    if (idcPay != "EUR" & idcRec != "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159788(pReportBancaItalia, formaTecnicaIndex);
                    if (idcPay == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159788(pReportBancaItalia, formaTecnicaIndex);
                    if (idcRec == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159790(pReportBancaItalia, formaTecnicaIndex);
                }
                if (isCommodityRecCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159789(pReportBancaItalia, formaTecnicaIndex);
                if (isCommodityPayCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159791(pReportBancaItalia, formaTecnicaIndex);
                formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
            }
            // if trade is open returns paid received cash flows FT (58195.02 e 58195.05)
            bool isCounterpartyResident = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;

            if (isOpen == true & isCounterpartyResident == false & CountExchangedCashFlows() != 0)
            {
                // only if grossCashFlows is not empty
                if (null != Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows)
                {
                    for (int exchangedCashFlowsIndex = 0; exchangedCashFlowsIndex < Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows.Length; exchangedCashFlowsIndex++)
                    {
                        decimal nettedCashFlow = Convert.ToDecimal(GetExchangedNettedCashFlow(exchangedCashFlowsIndex));
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                        if (nettedCashFlow > 0)
                            RRFormaTecnica.BuildFormaTecnica_5819502(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        if (nettedCashFlow <= 0)
                            RRFormaTecnica.BuildFormaTecnica_5819506(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                    }
                }
            }
            // if trade is open returns forward cash flows FT (03903.04  e 03903.06)
            if (isOpen == true & CountForwardCashFlows() != 0)
            {
                int forwardCashFlowsIndex = 0;
                int businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                while (businessForwardCashFlowIndex >= 0)
                {
                    decimal nettedCashFlow = Convert.ToDecimal(GetForwardNettedCashFlow(forwardCashFlowsIndex));
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                    // declared in FT 03903.04 when cash flow are positive 
                    if (nettedCashFlow > 0)
                        RRFormaTecnica.BuildFormaTecnica_0390304(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);
                    // declared in FT 03903.06 when cash flows are negative 
                    if (nettedCashFlow <= 0)
                        RRFormaTecnica.BuildFormaTecnica_0390306(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);

                    businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }
        }

        /// <summary>
        /// Build Elsag report section on report according Elsag rules
        /// Build the second report section (attribute name=elsag)
        /// to do: empty method 
        /// </summary>
        /// <param name="pReportElsag"></param>
        private void BuildFormeTecnicheElsag(RegulatoryReportReport pReportElsag)
        {

        }

        /// <summary>
        /// Build Oasi report section on report according Oasi rules
        /// Build the second report section (attribute name=oasi)
        /// </summary>
        /// <param name="pReportOasi"></param>
        private void BuildFormeTecnicheOasi(RegulatoryReportReport pReportOasi)
        {
            int BkIFormaTecnicaCount = Report.report[0].formaTecnica.Length;
            pReportOasi.formaTecnica = new RegulatoryReportReportFormaTecnica[BkIFormaTecnicaCount];
            for (int formaTecnicaIndex = 0; formaTecnicaIndex < BkIFormaTecnicaCount; formaTecnicaIndex++)
            {
                string formaTecnicaName = Report.report[0].formaTecnica[formaTecnicaIndex].name;
                pReportOasi.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                int outDataIndex = 0;
                // Define the position of EUR. It can be rec (received) or pay (paid)
                // To handle differents valorisation between BKI FT (01597.05 and 01597.09) and Oasi FT (TIT77)*
                // * see below italian comment
                // **************************************************************************************************************
                // Le forme tecniche BKI vengono scomposte in 01597.05 per euro pagati e 01597.09 per euro ricevuti
                // Le TIT77 accorpano invece le due forme tecniche BKI e non fanno nessuna distinzione rispetto agli euro pagati o ricevuti
                // la TIT77 richiede la valorizzazione di campi che sono disponibili nelle forme tecniche BLI in posizioni differenti a seconda che si tratti di euro pagati o ricevuti
                // La FT 01597.05 valorizza i campi 684/685/785 e lascia a null i campi 683/684/783
                // La FT 01597.09 valorizza i campi 683/684/783 e lascia a null i campi 684/685/785
                // Questa variabile passata al metodo BuildFormaTecnicaOasi_TIT77 consente di valorizzare i campi corretti 
                // e lascia che la datalayout valorizzi correttamente i campi non richiesti con il valore di out-of-the-scope
                // ***************************************************************************************************************
                string domesticCurrencyPosition;

                switch (formaTecnicaName)
                {
                    case "01597.01":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT75(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01597.05":
                        // Eur to pay
                        domesticCurrencyPosition = "pay";
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT77(pReportOasi, domesticCurrencyPosition, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01597.09":
                        // Eur to rec
                        domesticCurrencyPosition = "rec";
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT77(pReportOasi, domesticCurrencyPosition, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01597.88":
                    case "01597.90":
                        RRFormaTecnica.BuildFormaTecnicaOasi_AIM90(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "58195.02":
                    case "58195.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_PMD03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "03903.04":
                    case "03903.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_DIF03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                }
                RRDataLayout.HandleStaticData(pReportOasi.formaTecnica[formaTecnicaIndex], outDataIndex);
            }
        }
    }

    /// <summary>
    /// Feed report section for FxBarrierOption
    /// empty class
    /// </summary>
    public class RRPuma2FxBarrierOption : RRPuma2
    {
        public RRPuma2FxBarrierOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRFormaTecnica = new RRFormaTecnicaFxBarrierOption(pDomesticCurrency, pReport);
            GetBusinessInfos = new RRGetBusinessInfosFxBarrierOption(pReport);
        }

        /// <summary>
        /// Build report section for fxSimpleOption
        /// The first report node is a Banca d'Italia report (attribute name=bancaItalia)
        /// The second report node depends on subSystem (attribute name=elsag or oasi) 
        /// </summary>
        /// <param name="pSubSystem"></param>
        /// <param name="pLog"></param>
        public override void FeedReportPuma2(string pSubSystem, RRLog pLog)
        {
            bool isInTheScope = Convert.ToBoolean(Report.trade.header.isInTheScope);
            string subSystem = pSubSystem;
            //
            if (isInTheScope == true)
            {
                //
                Report.report = new RegulatoryReportReport[2];
                Report.log = new RegulatoryReportLog[2];
                //
                RegulatoryReportReport ReportBancaItalia = new RegulatoryReportReport();
                Report.report[0] = ReportBancaItalia;
                ReportBancaItalia.name = Convert.ToString("bancaItalia");
                this.BuildFormeTecnicheBancaItalia(ReportBancaItalia);
                pLog.FeedReportLog(Report, ReportBancaItalia);
                //
                if (subSystem == "SDBMatrix-Elsag")
                {
                    RegulatoryReportReport ReportElsag = new RegulatoryReportReport();
                    Report.report[1] = ReportElsag;
                    ReportElsag.name = Convert.ToString("elsag");
                    this.BuildFormeTecnicheElsag(ReportElsag);
                    pLog.FeedReportLog(Report, ReportElsag);
                }
                //
                if (subSystem == "Seceti-Oasi")
                {
                    RegulatoryReportReport ReportOasi = new RegulatoryReportReport();
                    Report.report[1] = ReportOasi;
                    ReportOasi.name = Convert.ToString("oasi");
                    this.BuildFormeTecnicheOasi(ReportOasi);
                    pLog.FeedReportLog(Report, ReportOasi);
                }
            }
        }

        /// <summary>
        /// Count all business nodes that contribute to build all "forme tecniche"
        /// Open trades: 1 FT for trade + past cash flows and futures cash flows
        /// Open and losed trades: 1 FT for trade
        /// </summary>
        /// <returns></returns>
        protected override int CountFormaTecnica()
        {

            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();

            if (isOpen == true & isOpenAndClosed == false)
                return 1 + CountExchangedCashFlows() + CountForwardCashFlows();
            if (isOpen == false & isOpenAndClosed == true)
                return 1;
            else return 0;
        }

        /// <summary>
        /// Build Banca d'Italia report section on report
        /// Build the first report section (attribute name=bancaItalia) 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        private void BuildFormeTecnicheBancaItalia(RegulatoryReportReport pReportBancaItalia)
        {
            pReportBancaItalia.formaTecnica = new RegulatoryReportReportFormaTecnica[CountFormaTecnica()];
            int formaTecnicaIndex = 0;
            bool isOpen = GetBusinessInfos.GetIsOpen();
            bool isOpenAndClosed = GetBusinessInfos.GetIsOpenAndClosed();
            bool isCommodityPayCurrency = GetBusinessInfos.GetPayCurrencyIsCommodity();
            string idcPay = GetBusinessInfos.GetPayCurrencyIdc();
            bool isCommodityRecCurrency = GetBusinessInfos.GetRecCurrencyIsCommodity();
            string idcRec = GetBusinessInfos.GetRecCurrencyIdc();

            if (isOpen == true)
            {
                pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                if (isCommodityPayCurrency == false & isCommodityRecCurrency == false)
                {
                    if (idcPay != "EUR" & idcRec != "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159701(pReportBancaItalia, formaTecnicaIndex);
                    if (idcPay == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159705(pReportBancaItalia, formaTecnicaIndex);
                    if (idcRec == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159709(pReportBancaItalia, formaTecnicaIndex);
        }
                if (isCommodityRecCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159713(pReportBancaItalia, formaTecnicaIndex);
                if (isCommodityPayCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159717(pReportBancaItalia, formaTecnicaIndex);
                formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
            }
            if (isOpenAndClosed == true)
            {
                pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                if (isCommodityPayCurrency == false & isCommodityRecCurrency == false)
                {
                    if (idcPay != "EUR" & idcRec != "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159788(pReportBancaItalia, formaTecnicaIndex);
                    if (idcPay == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159788(pReportBancaItalia, formaTecnicaIndex);
                    if (idcRec == "EUR")
                        RRFormaTecnica.BuildFormaTecnica_0159790(pReportBancaItalia, formaTecnicaIndex);
                }
                if (isCommodityRecCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159789(pReportBancaItalia, formaTecnicaIndex);
                if (isCommodityPayCurrency == true)
                    RRFormaTecnica.BuildFormaTecnica_0159791(pReportBancaItalia, formaTecnicaIndex);
                formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
            }
            // if trade is open returns paid received cash flows FT (58195.02 e 58195.05)
            bool isCounterpartyResident = Report.trade.dataDocument.repository.counterparty.isCounterpartyResident;

            if (isOpen == true & isCounterpartyResident == false & CountExchangedCashFlows() != 0)
            {
                // only if grossCashFlows is not empty
                if (null != Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows)
                {
                    for (int exchangedCashFlowsIndex = 0; exchangedCashFlowsIndex < Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows.Length; exchangedCashFlowsIndex++)
                    {
                        decimal nettedCashFlow = Convert.ToDecimal(GetExchangedNettedCashFlow(exchangedCashFlowsIndex));
                        pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();

                        if (nettedCashFlow > 0)
                            RRFormaTecnica.BuildFormaTecnica_5819502(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        if (nettedCashFlow <= 0)
                            RRFormaTecnica.BuildFormaTecnica_5819506(pReportBancaItalia, formaTecnicaIndex, exchangedCashFlowsIndex);
                        formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                    }
                }
            }
            // if trade is open returns forward cash flows FT (03903.04  e 03903.06)
            if (isOpen == true & CountForwardCashFlows() != 0)
            {
                int forwardCashFlowsIndex = 0;
                int businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);

                while (businessForwardCashFlowIndex >= 0)
                {
                    decimal nettedCashFlow = Convert.ToDecimal(GetForwardNettedCashFlow(forwardCashFlowsIndex));
                    pReportBancaItalia.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                    // declared in FT 03903.04 when cash flow are positive 
                    if (nettedCashFlow > 0)
                        RRFormaTecnica.BuildFormaTecnica_0390304(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);
                    // declared in FT 03903.06 when cash flows are negative 
                    if (nettedCashFlow <= 0)
                        RRFormaTecnica.BuildFormaTecnica_0390306(pReportBancaItalia, formaTecnicaIndex, forwardCashFlowsIndex);

                    businessForwardCashFlowIndex = GetNextForwardCashFlowsIndex(ref forwardCashFlowsIndex);
                    formaTecnicaIndex = IncrementFormaTecnicaIndex(formaTecnicaIndex);
                }
            }
        }

        /// <summary>
        /// Build Elsag report section on report according Elsag rules
        /// Build the second report section (attribute name=elsag)
        /// to do: empty method 
        /// </summary>
        /// <param name="pReportElsag"></param>
        private void BuildFormeTecnicheElsag(RegulatoryReportReport pReportElsag)
        {

        }

        /// <summary>
        /// Build Oasi report section on report according Oasi rules
        /// Build the second report section (attribute name=oasi)
        /// </summary>
        /// <param name="pReportOasi"></param>
        private void BuildFormeTecnicheOasi(RegulatoryReportReport pReportOasi)
        {
            int BkIFormaTecnicaCount = Report.report[0].formaTecnica.Length;
            pReportOasi.formaTecnica = new RegulatoryReportReportFormaTecnica[BkIFormaTecnicaCount];
            for (int formaTecnicaIndex = 0; formaTecnicaIndex < BkIFormaTecnicaCount; formaTecnicaIndex++)
            {
                string formaTecnicaName = Report.report[0].formaTecnica[formaTecnicaIndex].name;
                pReportOasi.formaTecnica[formaTecnicaIndex] = new RegulatoryReportReportFormaTecnica();
                int outDataIndex = 0;
                // Define the position of EUR. It can be rec (received) or pay (paid)
                // To handle differents valorisation between BKI FT (01597.05 and 01597.09) and Oasi FT (TIT77)*
                // * see below italian comment
                // **************************************************************************************************************
                // Le forme tecniche BKI vengono scomposte in 01597.05 per euro pagati e 01597.09 per euro ricevuti
                // Le TIT77 accorpano invece le due forme tecniche BKI e non fanno nessuna distinzione rispetto agli euro pagati o ricevuti
                // la TIT77 richiede la valorizzazione di campi che sono disponibili nelle forme tecniche BLI in posizioni differenti a seconda che si tratti di euro pagati o ricevuti
                // La FT 01597.05 valorizza i campi 684/685/785 e lascia a null i campi 683/684/783
                // La FT 01597.09 valorizza i campi 683/684/783 e lascia a null i campi 684/685/785
                // Questa variabile passata al metodo BuildFormaTecnicaOasi_TIT77 consente di valorizzare i campi corretti 
                // e lascia che la datalayout valorizzi correttamente i campi non richiesti con il valore di out-of-the-scope
                // ***************************************************************************************************************
                string domesticCurrencyPosition;

                switch (formaTecnicaName)
                {
                    case "01597.01":
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT75(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01597.05":
                        // Eur to pay
                        domesticCurrencyPosition = "pay";
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT77(pReportOasi, domesticCurrencyPosition, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01597.09":
                        // Eur to rec
                        domesticCurrencyPosition = "rec";
                        RRFormaTecnica.BuildFormaTecnicaOasi_TIT77(pReportOasi, domesticCurrencyPosition, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "01597.88":
                    case "01597.90":
                        RRFormaTecnica.BuildFormaTecnicaOasi_AIM90(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "58195.02":
                    case "58195.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_PMD03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                    case "03903.04":
                    case "03903.06":
                        RRFormaTecnica.BuildFormaTecnicaOasi_DIF03(pReportOasi, formaTecnicaIndex, out outDataIndex);
                        break;
                }
                RRDataLayout.HandleStaticData(pReportOasi.formaTecnica[formaTecnicaIndex], outDataIndex);
            }
        }
    }

    /// <summary>
    /// Feed report section for FxDigitalOption
    /// </summary>
    public class RRPuma2FxDigitalOption : RRPuma2
    {
        public RRPuma2FxDigitalOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRFormaTecnica = new RRFormaTecnicaFxDigitalOption(pDomesticCurrency, pReport);
            GetBusinessInfos = new RRGetBusinessInfosFxDigitalOption(pReport);
        }

        /// <summary>
        /// empty method
        /// </summary>
        /// <param name="pSubSystem"></param>
        /// <param name="pLog"></param>
        public override void FeedReportPuma2(string pSubSystem, RRLog pLog)
        {
        }

        /// <summary>
        /// empty method
        /// </summary>
        /// <returns></returns>
        protected override int CountFormaTecnica()
        {
            return 0;
        }

        /// <summary>
        /// empty method
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        private void BuildFormeTecnicheBancaItalia(RegulatoryReportReport pReportBancaItalia)
        {
        }

        /// <summary>
        /// empty method
        /// </summary>
        /// <param name="pReportElsag"></param>
        private void BuildFormeTecnicheElsag(RegulatoryReportReport pReportElsag)
        {
        }

        /// <summary>
        /// empty method
        /// </summary>
        /// <param name="pReportOasi"></param>
        private void BuildFormeTecnicheOasi(RegulatoryReportReport pReportOasi)
        {
        }
    }

    /// <summary>
    /// Build common forme tecniche (all products)
    /// </summary>
    public class RRFormaTecnica
    {
        #region Members
        protected RegulatoryReport m_Report;
        private RRDataLayout m_DataLayout;
        private RRData m_RRData;
        // BKI static value
        protected int m_Data50;
        protected int m_Data15;
        private string m_DomesticCurrency;
        #endregion
        #region Accessors
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public RRDataLayout DataLayout
        {
            get { return this.m_DataLayout; }
            set { this.m_DataLayout = value; }
        }
        public RRData RRData
        {
            get { return this.m_RRData; }
            set { this.m_RRData = value; }
        }
        public int Data50
        {
            get { return this.m_Data50; }
        }
        public int Data15
        {
            get { return this.m_Data15; }
        }
        public string DomesticCurrency
        {
            get { return this.m_DomesticCurrency; }
            set { this.m_DomesticCurrency = value; }
        }
        #endregion
        #region Constructor
        public RRFormaTecnica(string pDomesticCurrency, RegulatoryReport pReport)
        {
            Report = pReport;
            m_Data50 = 50;
            m_Data15 = 15;
            m_DomesticCurrency = pDomesticCurrency;
        }
        #endregion

        virtual public void BuildFormaTecnica_0159301(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
        }
        virtual public void BuildFormaTecnica_0159305(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
        }
        virtual public void BuildFormaTecnica_0159701(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
        }
        virtual public void BuildFormaTecnica_0159705(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
        }
        virtual public void BuildFormaTecnica_0159709(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
        }
        virtual public void BuildFormaTecnica_0159398(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pCapLetFloorLetIndex)
        {
        }
        virtual public void BuildFormaTecnica_0159399(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pCapLetFloorLetIndex)
        {
        }
        virtual public void BuildFormaTecnicaElsag_0159301(RegulatoryReportReport pReportElsag, int pFormaTecnicaIndex, out int pDataIndex)
        {
            pDataIndex = 0;
        }
        virtual public void BuildFormaTecnicaElsag_0159305(RegulatoryReportReport pReportElsag, int pFormaTecnicaIndex, out int pDataIndex)
        {
            pDataIndex = 0;
        }
        virtual public void BuildFormaTecnicaOasi_TIT70(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {

            pDataIndex = 0;
        }
        virtual public void BuildFormaTecnicaOasi_TIT81(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            pDataIndex = 0;
        }
        virtual public void BuildFormaTecnicaOasi_TIT82(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            pDataIndex = 0;
        }

        virtual public void BuildFormaTecnicaOasi_TIT75(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            pDataIndex = 0;
        }

        virtual public void BuildFormaTecnicaOasi_TIT77(RegulatoryReportReport pReportOasi, string pDomesticCurrencyPosition, int pFormaTecnicaIndex, out int pDataIndex)
        {
            pDataIndex = 0;
        }

        /// <summary>
        /// BancaItalia: 01593.88
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        virtual public void BuildFormaTecnica_0159388(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.88";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007	CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00011	ATTIVITA ECONOMICA CONTROPARTE
            RRData.Calc_00011(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00011"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00370	TIPO CONTRATTO RISCHI MERCATO
            RRData.Calc_00370(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00370"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT. CONTR EURO
            RRData.Calc_00699(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00799	VALORE NOMINALE CONTRATTI IN DIVISA
            RRData.Calc_00799(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //RESIDENZA_DIVISA
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("ResidenzaDivisa"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 01593.89
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        virtual public void BuildFormaTecnica_0159389(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.89";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            //00003	DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007	CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00011	ATTIVITA ECONOMICA CONTROPARTE
            RRData.Calc_00011(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00011"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00370	TIPO CONTRATTO RISCHI MERCATO
            RRData.Calc_00370(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00370"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT. CONTR EURO
            RRData.Calc_00699(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00799	VALORE NOMINALE CONTRATTI IN DIVISA
            RRData.Calc_00799(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //RESIDENZA_DIVISA
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("ResidenzaDivisa"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 01597.13
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public void BuildFormaTecnica_0159713(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.13";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007 CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00183	 DIGIT VALORE SOTTOSTANTE AL CONTRATTO
            RRData.Calc_00183(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00183"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375 RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00525	 TIPO PRODOTTO SPECIFICO -  MERCI
            RRData.Calc_00525(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00525"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00609	 VALORE NOMINALE IN EURO 
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00610	 VALORE DI CONTRATTAZIONE IN EURO 
            RRData.Calc_00610(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00610"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00709	 VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00710	 VALORE DI CONTRATTAZIONE IN VALUTA
            RRData.Calc_00710(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00710"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00940 NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 01597.17
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public void BuildFormaTecnica_0159717(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.17";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007 CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00183	 DIGIT VALORE SOTTOSTANTE AL CONTRATTO
            RRData.Calc_00183(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00183"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375 RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00525	 TIPO PRODOTTO SPECIFICO -  MERCI
            RRData.Calc_00525(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00525"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00609	 VALORE NOMINALE IN EURO 
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00610	 VALORE DI CONTRATTAZIONE IN EURO 
            RRData.Calc_00610(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00610"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00709	 VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00710	 VALORE DI CONTRATTAZIONE IN VALUTA
            RRData.Calc_00710(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00710"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00940 NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01597.88 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public void BuildFormaTecnica_0159788(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.88";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01597.90
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public void BuildFormaTecnica_0159790(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.90";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01597.89
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public void BuildFormaTecnica_0159789(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.89";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01597.91 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public void BuildFormaTecnica_0159791(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.91";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 58195.02
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pPaidReceivedCashFlowsIndex"></param>
        virtual public void BuildFormaTecnica_5819502(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pExchangedCashFlowsIndex)
        {
            string formaTecnicaName = "58195.02";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //STATO DELLA CONTROPARTE (codice UIC del paese di residenza)
            RRData.Calc_00016(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00016"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CONTROVALORE IN EURO PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00699(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE NOMINALE PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00799(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SEGNO VALORE NOMINALE PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_CashFlow_Sign(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("CashFlow_Sign"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //RESIDENZA_DIVISA
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("ResidenzaDivisa"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 58195.06
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pPaidReceivedCashFlowsIndex"></param>
        virtual public void BuildFormaTecnica_5819506(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pExchangedCashFlowsIndex)
        {
            string formaTecnicaName = "58195.06";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //STATO DELLA CONTROPARTE (codice UIC del paese di residenza)
            RRData.Calc_00016(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00016"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CONTROVALORE IN EURO PREMI MARGINI E DIFFERENZIALI
            RRData.Calc_00699(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE NOMINALE PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00799(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SEGNO VALORE NOMINALE PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_CashFlow_Sign(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("CashFlow_Sign"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //RESIDENZA_DIVISA
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("ResidenzaDivisa"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:03903.04
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pForwardCashFlowsIndex"></param>
        public void BuildFormaTecnica_0390304(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pForwardCashFlowsIndex)
        {
            string formaTecnicaName = "03903.04";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00010(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013  SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE DEL CLIENTE
            RRData.Calc_00030(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIFFERENZIALI DA RICEVERE SU DERIVATI FINANZIARI
            RRData.Calc_07014(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("07014"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SEGNO DIFFERENZIALI
            RRData.Calc_CashFlow_Sign(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("CashFlow_Sign"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //RESIDENZA_DIVISA
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("ResidenzaDivisa"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 03903.06
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pForwardCashFlowsIndex"></param>
        public void BuildFormaTecnica_0390306(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pForwardCashFlowsIndex)
        {
            string formaTecnicaName = "03903.06";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00010(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013  SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE DEL CLIENTE
            RRData.Calc_00030(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIFFERENZIALI DA RICEVERE SU DERIVATI FINANZIARI
            RRData.Calc_07014(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("07014"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SEGNO DIFFERENZIALI
            RRData.Calc_CashFlow_Sign(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("CashFlow_Sign"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //RESIDENZA_DIVISA
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pForwardCashFlowsIndex, Convert.ToString("ResidenzaDivisa"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// Oasi:AIM.84
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        virtual public void BuildFormaTecnicaOasi_AIM84(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "AIM.84";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //LIVELLO_ULTERIORE_DETTAGLIO_0583 
            RRData.Calc_LivelloUlterioreDettaglio_0583(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0583"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_DIVISA_0003
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_DIVISA_0003"), Convert.ToString("ResidenzaDivisa"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIVISA_0009
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIVISA_0009"), Convert.ToString("00003"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOGRUPPO_0170
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOGRUPPO_0170"), Convert.ToString("00011"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_CONTRATTO_RISCHI_MERCATO_0262
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_CONTRATTO_RISCHI_MERCATO_0262"), Convert.ToString("00370"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //IMPORTO_0461
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("IMPORTO_0461"), Convert.ToString("00799"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:TIT.79 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pDomesticCurrencyPosition"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public void BuildFormaTecnicaOasi_TIT79(RegulatoryReportReport pReportOasi, string pDomesticCurrencyPosition, int pFormaTecnicaIndex, out int pDataIndex)
        {

            string formaTecnicaName = "TIT.79";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            string domesticCurrencyPosition = pDomesticCurrencyPosition;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_VALUTA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_VALUTA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RAPPORTI_OGGETTO_COPERTURA_0346
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_EURO_NEGOZIATI_0459
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_EURO_NEGOZIATI_0459"), Convert.ToString("00684"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            if (domesticCurrencyPosition == "pay")
            {

                //VALUTA_RICEVERE_0150
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), Convert.ToString("00154"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTE_RICEVERE_0717
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), Convert.ToString("00685"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_RICEVERE_0718
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), Convert.ToString("00785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            }
            //
            if (domesticCurrencyPosition == "rec")
            {
                //VALUTA_CONSEGNARE_0155
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), Convert.ToString("00163"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTE_CONSEGNARE_0719
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_CONSEGNARE_0719"), Convert.ToString("00683"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_CONSEGNARE_0720
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), Convert.ToString("00783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            }
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DERIVATO_SOTTOSTANTE 1360
            // GS 20110210 attesa regola valorizzazione o corrispondenza BKI
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_IAS_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_IAS_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAF_IAS_COPERTO_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAF_IAS_COPERTO_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEG_BILANCIO_1907
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEG_BILANCIO_1907"), Convert.ToString("06696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POS_BILANCIO_1908
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POS_BILANCIO_1908"), Convert.ToString("06697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_OPZIONE_2473
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_SOTTOSTANTE_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_SOTTOSTANTE_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VEGA_PER_OPZIONI_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VEGA_PER_OPZIONI_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GAMMA_PER_OPZIONI_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GAMMA_PER_OPZIONI_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:AIM.90 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public void BuildFormaTecnicaOasi_AIM90(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "AIM.90";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //LIVELLO_ULTERIORE_DETTAGLIO_0583 
            RRData.Calc_LivelloUlterioreDettaglio_0583(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0583"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_DIVISA_0003
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_DIVISA_0003"), Convert.ToString("ResidenzaDivisa"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIVISA_0009
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIVISA_0009"), Convert.ToString("00003"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOGRUPPO_0170
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOGRUPPO_0170"), Convert.ToString("00011"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //IMPORTO_0461
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("IMPORTO_0461"), Convert.ToString("00799"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:PMD.03 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        virtual public void BuildFormaTecnicaOasi_PMD03(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "PMD.03";
            int dataIndex = 0;
            //
            int MaxCountPDM03 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountPDM03];
            //
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //LIVELLO_ULTERIORE_DETTAGLIO_0583 
            RRData.Calc_LivelloUlterioreDettaglio_0583(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0583"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_DIVISA_0003
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_DIVISA_0003"), Convert.ToString("ResidenzaDivisa"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //STATO_0160
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("STATO_0160"), Convert.ToString("00016"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SALDO_CONTABILE_EURO_0300
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SALDO_CONTABILE_EURO_0300"), Convert.ToString("00699"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SALDO_CONTABILE_VALUTA_0301
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SALDO_CONTABILE_VALUTA_0301"), Convert.ToString("00799"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SEGNO
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SEGNO"), Convert.ToString("CashFlow_Sign"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:DIF.03 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public void BuildFormaTecnicaOasi_DIF03(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "DIF.03";
            int dataIndex = 0;
            //
            int MaxCountDIF03 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountDIF03];
            //
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659 
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //LIVELLO_ULTERIORE_DETTAGLIO_0646 
            RRData.Calc_LivelloUlterioreDettaglio_0646(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0646"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_DIVISA_0003
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_DIVISA_0003"), Convert.ToString("ResidenzaDivisa"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIVISA_0009
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIVISA_0009"), Convert.ToString("00003"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //IMPORTO_0461
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("IMPORTO_0461"), Convert.ToString("07014"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SEGNO_IMPORTO_0461
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SEGNO_IMPORTO_0461"), Convert.ToString("CashFlow_Sign"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }
    }

    /// <summary>
    /// Build forme tecniche for swap
    /// </summary>
    public class RRFormaTecnicaSwap : RRFormaTecnica
    {
        public RRFormaTecnicaSwap(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRData = new RRDataSwap(pDomesticCurrency, pReport);
        }

        /// <summary>
        /// BancaItalia:01593.01
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159301(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.01";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // INDICATORE DURATA 
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO TASSO (FISSO O INDICIZZATO)
            RRData.Calc_00113(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00113"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TASSO RISCHIO MERCATO
            RRData.Calc_00117(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00117"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TASSO FISSO 
            RRData.Calc_00130(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00130"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO CONTRATTO RISCHI MERCATO
            RRData.Calc_00370(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00370"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
            RRData.Calc_00378(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00378"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // ESPOSIZIONE FUTURA
            RRData.Calc_00667(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO NEGATIVO 
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            RRData.Calc_05277(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01593.05 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159305(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.05";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // INDICATORE DURATA 
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO TASSO (FISSO O INDICIZZATO)
            RRData.Calc_00113(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00113"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TASSO RISCHIO MERCATO
            RRData.Calc_00117(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00117"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TASSO FISSO 
            RRData.Calc_00130(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00130"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO CONTRATTO RISCHI MERCATO
            RRData.Calc_00370(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00370"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
            RRData.Calc_00378(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00378"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // ESPOSIZIONE FUTURA
            RRData.Calc_00667(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO NEGATIVO 
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            RRData.Calc_05277(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// Elsag:01593.01
        /// </summary>
        /// <param name="pReportElsag"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaElsag_0159301(RegulatoryReportReport pReportElsag, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "01593.01";
            //
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportElsag.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportElsag.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportElsag.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //ISTITUTO
            RRData.Calc_Istituto(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ISTITUTO"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NDG
            RRData.Calc_Ndg(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NDG"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERPROV
            RRData.Calc_Servprov(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERPROV"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO
            RRData.Calc_Servizio(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //FILIALE
            RRData.Calc_Filiale(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FILIALE"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMRAPP
            RRData.Calc_Numrapp(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMRAPP"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATACOMP
            RRData.Calc_Datacomp(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATACOMP"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE
            RRData.Calc_Voce(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++); ;
            //SVOCE
            RRData.Calc_Svoce(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SVOCE"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // VAL00003: DIGIT DIVISA
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00003"), Convert.ToString("00003"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CATSOTT
            RRData.Calc_Catsott(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CATSOTT"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00004
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00004"), Convert.ToString("00004"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00005
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00005"), Convert.ToString("00005"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00007
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00007"), Convert.ToString("00007"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00009
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00009"), Convert.ToString("00009"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00010
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00010"), Convert.ToString("00010"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00032
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00032"), Convert.ToString("00032"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00044
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00044"), Convert.ToString("00044"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00116
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00116"), Convert.ToString("00116"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00117
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00117"), Convert.ToString("00117"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00125"), Convert.ToString("00125"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00130
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00130"), Convert.ToString("00130"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00137
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00137"), Convert.ToString("00137"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00143
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00143"), Convert.ToString("00143"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00353
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00353"), Convert.ToString("00353"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00370
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00370"), Convert.ToString("00370"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00375
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00375"), Convert.ToString("00375"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00377
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00377"), Convert.ToString("00377"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00378
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00378"), Convert.ToString("00378"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00507
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00507"), Convert.ToString("00507"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00510
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00510"), Convert.ToString("00510"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00520
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00520"), Convert.ToString("00520"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00521
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00521"), Convert.ToString("00521"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00543
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00543"), Convert.ToString("00543"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00552
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00552"), Convert.ToString("00552"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00609
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00609"), Convert.ToString("00609"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00667
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00667"), Convert.ToString("00667"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00696
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00696"), Convert.ToString("00696"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00697
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00697"), Convert.ToString("00697"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00709
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00709"), Convert.ToString("00709"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00724
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00724"), Convert.ToString("00724"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00734
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00734"), Convert.ToString("00734"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00906
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00906"), Convert.ToString("00906"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00932
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00932"), Convert.ToString("00932"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00940
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00940"), Convert.ToString("00940"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00941
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00941"), Convert.ToString("00941"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL01003
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL01003"), Convert.ToString("01003"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05277
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05277"), Convert.ToString("05277"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05314
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05314"), Convert.ToString("05314"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05315
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05315"), Convert.ToString("05315"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05316
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05316"), Convert.ToString("05316"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05325
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05325"), Convert.ToString("05325"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05397
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05397"), Convert.ToString("05397"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05399
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05399"), Convert.ToString("05399"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL09418
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL09418"), Convert.ToString("09418"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05414
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05414"), Convert.ToString("05414"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL01175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL01175"), Convert.ToString("01175"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05331
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05331"), Convert.ToString("05331"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL06315
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL06315"), Convert.ToString("06315"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05344
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05344"), Convert.ToString("05344"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05416
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05416"), Convert.ToString("05416"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODDEAL
            RRData.Calc_CodDeal(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODDEAL"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODFRONT
            RRData.Calc_CodFront(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODFRONT"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // return data index
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Elsag:01593.05
        /// </summary>
        /// <param name="pReportElsag"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaElsag_0159305(RegulatoryReportReport pReportElsag, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "01593.05";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportElsag.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportElsag.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportElsag.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //ISTITUTO
            RRData.Calc_Istituto(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ISTITUTO"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NDG
            RRData.Calc_Servprov(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NDG"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERPROV
            RRData.Calc_Istituto(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERPROV"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO
            RRData.Calc_Servizio(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //FILIALE
            RRData.Calc_Filiale(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FILIALE"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMRAPP
            RRData.Calc_Numrapp(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMRAPP"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATACOMP
            RRData.Calc_Datacomp(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATACOMP"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE
            RRData.Calc_Voce(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++); ;
            //SVOCE
            RRData.Calc_Svoce(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SVOCE"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // VAL00003: DIGIT DIVISA
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00003"), Convert.ToString("00003"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CATSOTT
            RRData.Calc_Catsott(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CATSOTT"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00004
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00004"), Convert.ToString("00004"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00005
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00005"), Convert.ToString("00005"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00007
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00007"), Convert.ToString("00007"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00009
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00009"), Convert.ToString("00009"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00010
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00010"), Convert.ToString("00010"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00032
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00032"), Convert.ToString("00032"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00044
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00044"), Convert.ToString("00044"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00116
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00116"), Convert.ToString("00116"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00117
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00117"), Convert.ToString("00117"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00125"), Convert.ToString("00125"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00130
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00130"), Convert.ToString("00130"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00137
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00137"), Convert.ToString("00137"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00143
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00143"), Convert.ToString("00143"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00353
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00353"), Convert.ToString("00353"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00370
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00370"), Convert.ToString("00370"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00375
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00375"), Convert.ToString("00375"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00377
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00377"), Convert.ToString("00377"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00378
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00378"), Convert.ToString("00378"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00507
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00507"), Convert.ToString("00507"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00510
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00510"), Convert.ToString("00510"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00520
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00520"), Convert.ToString("00520"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00521
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00521"), Convert.ToString("00521"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00543
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00543"), Convert.ToString("00543"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00552
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00552"), Convert.ToString("00552"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00609
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00609"), Convert.ToString("00609"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00610
            //FeedData(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00610"), Convert.ToString("00610"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00667
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00667"), Convert.ToString("00667"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00696
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00696"), Convert.ToString("00696"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00697
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00697"), Convert.ToString("00697"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00709
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00709"), Convert.ToString("00709"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00724
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00724"), Convert.ToString("00724"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00734
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00734"), Convert.ToString("00734"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00906
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00906"), Convert.ToString("00906"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00932
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00932"), Convert.ToString("00932"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00940
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00940"), Convert.ToString("00940"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL00941
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL00941"), Convert.ToString("00941"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL01003
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL01003"), Convert.ToString("01003"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05277
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05277"), Convert.ToString("05277"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05314
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05314"), Convert.ToString("05314"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05315
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05315"), Convert.ToString("05315"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05316
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05316"), Convert.ToString("05316"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05325
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05325"), Convert.ToString("05325"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05397
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05397"), Convert.ToString("05397"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05399
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05399"), Convert.ToString("05399"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL09418
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL09418"), Convert.ToString("09418"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05414
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05414"), Convert.ToString("05414"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL01175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL01175"), Convert.ToString("01175"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05331
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05331"), Convert.ToString("05331"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL06315
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL06315"), Convert.ToString("06315"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05344
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05344"), Convert.ToString("05344"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VAL05416
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VAL05416"), Convert.ToString("05416"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODDEAL
            RRData.Calc_CodDeal(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODDEAL"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODFRONT
            RRData.Calc_CodFront(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODFRONT"), pReportElsag.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // return data index
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:TIT.70 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT70(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.70";
            int dataIndex = 0;
            //
            int MaxCountTIT70 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountTIT70];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659 
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_REVISIONE_CONTRATTO_1501
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_REVISIONE_CONTRATTO_1501"), Convert.ToString("00378"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_CONTRATTO_RISCHI_MERCATO_0262 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_CONTRATTO_RISCHI_MERCATO_0262"), Convert.ToString("00370"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_RISCHI_MERCATO_0239
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_RISCHI_MERCATO_0239"), Convert.ToString("00130"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_RISCHIO_COPERTO_1850
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_RISCHIO_COPERTO_1850"), Convert.ToString("05316"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAFOGLIO_IAS_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAFOGLIO_IAS_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_EURO_0420
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_EURO_0420"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_VALUTA_0421
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_VALUTA_0421"), Convert.ToString("00709"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_IAS_1907
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_IAS_1907"), Convert.ToString("06696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_IAS_1908
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_IAS_1908"), Convert.ToString("06697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_TASSO_FISSO_INDICIZZATO_0145
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_TASSO_FISSO_INDICIZZATO_0145"), Convert.ToString("00113"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_INDICIZZATO_RM_0238
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_INDICIZZATO_RM_0238"), Convert.ToString("00117"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_STRUMENTO_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_STRUMENTO_2476"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_UNIVOCO_DERIVATO_2499
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_UNIVOCO_DERIVATO_2499"), Convert.ToString("05277"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }
    }

    /// <summary>
    /// Build forme tecniche for capFloor
    /// </summary>
    public class RRFormaTecnicaCap : RRFormaTecnica
    {
        public RRFormaTecnicaCap(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRData = new RRDataCap(pDomesticCurrency, pReport);
        }

        /// <summary>
        /// BancaItalia:01593.01 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159301(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.01";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // INDICATORE DURATA 
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO TASSO (FISSO O INDICIZZATO)
            RRData.Calc_00113(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00113"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TASSO RISCHIO MERCATO
            RRData.Calc_00117(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00117"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TASSO FISSO 
            RRData.Calc_00130(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00130"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO CONTRATTO RISCHI MERCATO
            RRData.Calc_00370(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00370"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
            RRData.Calc_00378(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00378"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // ESPOSIZIONE FUTURA
            RRData.Calc_00667(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO NEGATIVO 
            RRData.Calc_00696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DELTA OPZIONI 00299 (DELTA_OPZIONI_0258) 
            RRData.Calc_00299(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE GAMMA 00526 (FATTORE_GAMMA_2497) 
            RRData.Calc_00526(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE VEGA  00527 (FATTORE_VEGA_2478)
            RRData.Calc_00527(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VOLATILITA IMPLICITA 00528 (VOLATILITA_IMPLICITA_2479) 
            RRData.Calc_00528(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO OPZIONE 00530 (TIPO_OPZIONE_2473) 
            RRData.Calc_00530(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            RRData.Calc_05277(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01593.05
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159305(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.05";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // INDICATORE DURATA 
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO TASSO (FISSO O INDICIZZATO)
            RRData.Calc_00113(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00113"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TASSO RISCHIO MERCATO
            RRData.Calc_00117(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00117"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TASSO FISSO 
            RRData.Calc_00130(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00130"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO CONTRATTO RISCHI MERCATO
            RRData.Calc_00370(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00370"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
            RRData.Calc_00378(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00378"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // ESPOSIZIONE FUTURA
            RRData.Calc_00667(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO NEGATIVO 
            RRData.Calc_00696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DELTA OPZIONI 00299 (DELTA_OPZIONI_0258) 
            RRData.Calc_00299(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE GAMMA 00526 (FATTORE_GAMMA_2497) 
            RRData.Calc_00526(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE VEGA  00527 (FATTORE_VEGA_2478)
            RRData.Calc_00527(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VOLATILITA IMPLICITA 00528 (VOLATILITA_IMPLICITA_2479) 
            RRData.Calc_00528(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO OPZIONE 00530 (TIPO_OPZIONE_2473) 
            RRData.Calc_00530(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            RRData.Calc_05277(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 01593.98 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pCapLetFloorLetIndex"></param>
        public override void BuildFormaTecnica_0159398(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pCapLetFloorLetIndex)
        {
            string formaTecnicaName = "01593.98";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // UNIQUE CODE RELATIONSHIP 
            RRData.Calc_UniqueCodeRelationship(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("UniqueCodeRelationship"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CAPLET FLOORLET SEQUENCE NUMBER 
            RRData.Calc_SequenceNumber(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("SequenceNumber"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TASSO RISCHIO MERCATO
            RRData.Calc_00117(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00117"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TASSO FISSO 
            RRData.Calc_00130(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00130"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DELTA OPZIONI 00299 (DELTA_OPZIONI_0258) 
            RRData.Calc_00299(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE CORRENTE STRUMENTO FINANZIARIO
            RRData.Calc_00520(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SEGNO VALORE CORRENTE STRUMENTO FINANZIARIO
            RRData.Sign_00520(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("Segno00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pCapLetFloorLetIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE VEGA  00527 (FATTORE_VEGA_2478)
            RRData.Calc_00527(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VOLATILITA IMPLICITA 00528 (VOLATILITA_IMPLICITA_2479) 
            RRData.Calc_00528(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE GAMMA 00526 (FATTORE_GAMMA_2497) 
            RRData.Calc_00526(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
            RRData.Calc_00378(formaTecnicaName, pFormaTecnicaIndex, pCapLetFloorLetIndex, Convert.ToString("00378"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01593.99 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pCapLetFloorLetIndex"></param>
        public override void BuildFormaTecnica_0159399(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pCapLetFloorLetIndex)
        {
            string formaTecnicaName = "01593.99";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // UNIQUE CODE RELATIONSHIP 
            RRData.Calc_UniqueCodeRelationship(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("UniqueCodeRelationship"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CAPLET FLOORLET SEQUENCE NUMBER 
            RRData.Calc_SequenceNumber(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("SequenceNumber"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TASSO RISCHIO MERCATO
            RRData.Calc_00117(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00117"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TASSO FISSO 
            RRData.Calc_00130(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00130"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DELTA OPZIONI 00299 (DELTA_OPZIONI_0258) 
            RRData.Calc_00299(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE CORRENTE STRUMENTO FINANZIARIO
            RRData.Calc_00520(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SEGNO VALORE CORRENTE STRUMENTO FINANZIARIO
            RRData.Sign_00520(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("Segno00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pCapLetFloorLetIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE VEGA  00527 (FATTORE_VEGA_2478)
            RRData.Calc_00527(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VOLATILITA IMPLICITA 00528 (VOLATILITA_IMPLICITA_2479) 
            RRData.Calc_00528(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE GAMMA 00526 (FATTORE_GAMMA_2497) 
            RRData.Calc_00526(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
            RRData.Calc_00378(formaTecnicaName, pFormaTecnicaIndex, pCapLetFloorLetIndex, Convert.ToString("00378"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pCapLetFloorLetIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// Oasi: TIT.70 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT70(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.70";
            int dataIndex = 0;
            int MaxCountTIT70 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountTIT70];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659 
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052/ BKI 00010: DATA DI SCADENZA DELL'IMPEGNO
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_REVISIONE_CONTRATTO_1501
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_REVISIONE_CONTRATTO_1501"), Convert.ToString("00378"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150 /BKI 00007 CODICE VALUTA 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098/ BKI 00143
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_CONTRATTO_RISCHI_MERCATO_0262 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_CONTRATTO_RISCHI_MERCATO_0262"), Convert.ToString("00370"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_RISCHI_MERCATO_0239
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_RISCHI_MERCATO_0239"), Convert.ToString("00130"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_RISCHIO_COPERTO_1850
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_RISCHIO_COPERTO_1850"), Convert.ToString("05316"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAFOGLIO_IAS_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAFOGLIO_IAS_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_EURO_0420
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_EURO_0420"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_VALUTA_0421
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_VALUTA_0421"), Convert.ToString("00709"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_IAS_1907
            //GS 20110809: see ticket 17517
            //Only for capFloor: use NETTEDMTM to calcutate the Intrinsic value (Kondor MTM is a Dirty Price)
            RRData.Calc_ValoreIntrinsecoNegativoIAS_1907(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_IAS_1907"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_IAS_1908
            // GS 20110809: see ticket 17517
            // Only for capFloor: use NETTEDMTM to calcutate the Intrinsic value (Kondor MTM is a Dirty Price)
            RRData.Calc_ValoreIntrinsecoPositivoIAS_1908(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_IAS_1908"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_TASSO_FISSO_INDICIZZATO_0145
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_TASSO_FISSO_INDICIZZATO_0145"), Convert.ToString("00113"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_INDICIZZATO_RM_0238
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_INDICIZZATO_RM_0238"), Convert.ToString("00117"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // TIPO_OPZIONE_2473 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_STRUMENTO_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_STRUMENTO_2476"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_VEGA_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_VEGA_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_GAMMA_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_GAMMA_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_UNIVOCO_DERIVATO_2499
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_UNIVOCO_DERIVATO_2499"), Convert.ToString("05277"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi: TIT.81
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT81(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.81";
            int dataIndex = 0;
            int MaxCountTIT81 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);

            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountTIT81];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), Convert.ToString("UniqueCodeRelationship"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // LIVELLO_ULTERIORE_DETTAGLIO_0647
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0647"), Convert.ToString("SequenceNumber"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_INDICIZZATO_RM_0238
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_INDICIZZATO_RM_0238"), Convert.ToString("00117"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_RISCHI_MERCATO_0239
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_RISCHI_MERCATO_0239"), Convert.ToString("00130"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_EURO_0420
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_EURO_0420"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_VALUTA_0421
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_VALUTA_0421"), Convert.ToString("00709"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_STRUMENTO_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_STRUMENTO_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_VEGA_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_VEGA_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_GAMMA_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_GAMMA_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_REVISIONE_CONTRATTO_1501
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_REVISIONE_CONTRATTO_1501"), Convert.ToString("00378"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // SEGNO_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SEGNO_2476"), Convert.ToString("Segno00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //                
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:TIT.82 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT82(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.82";
            int dataIndex = 0;
            int MaxCountTIT82 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountTIT82];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), Convert.ToString("UniqueCodeRelationship"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // LIVELLO_ULTERIORE_DETTAGLIO_0647
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0647"), Convert.ToString("SequenceNumber"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_INDICIZZATO_RM_0238
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_INDICIZZATO_RM_0238"), Convert.ToString("00117"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TASSO_RISCHI_MERCATO_0239
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TASSO_RISCHI_MERCATO_0239"), Convert.ToString("00130"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_EURO_0420
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_EURO_0420"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_VALUTA_0421
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_VALUTA_0421"), Convert.ToString("00709"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_STRUMENTO_2476 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_STRUMENTO_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_VEGA_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_VEGA_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_GAMMA_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_GAMMA_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_REVISIONE_CONTRATTO_1501
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_REVISIONE_CONTRATTO_1501"), Convert.ToString("00378"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // SEGNO_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SEGNO_2476"), Convert.ToString("Segno00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            pDataIndex = dataIndex;
        }
    }



    /// <summary>
    /// Build forme tecniche for BondOption
    /// </summary>
    public class RRFormaTecnicaBondOption : RRFormaTecnica
    {
        public RRFormaTecnicaBondOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRData = new RRDataBondOption(pDomesticCurrency, pReport);
        }

        /// <summary>
        /// BancaItalia:01593.01 
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159301(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.01";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // INDICATORE DURATA 
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE TITOLO SOTTOSTANTE 
            RRData.Calc_00033(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00033"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // Valore di contrattazione in EURO
            RRData.Calc_00610(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00610"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // Valore corrente rischi di mercato in EUR
            RRData.Calc_00724(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00724"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE DEL FAIR VALUE ATTIVITA' SOTTOSTANTE
            RRData.Calc_06315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // ESPOSIZIONE FUTURA
            RRData.Calc_00667(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO NEGATIVO 
            RRData.Calc_00696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA FUTURES OPZIONI 
            RRData.Calc_00540(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00540"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DELTA OPZIONI 00299 (DELTA_OPZIONI_0258) 
            RRData.Calc_00299(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE GAMMA 00526 (FATTORE_GAMMA_2497) 
            RRData.Calc_00526(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE VEGA  00527 (FATTORE_VEGA_2478)
            RRData.Calc_00527(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VOLATILITA IMPLICITA 00528 (VOLATILITA_IMPLICITA_2479) 
            RRData.Calc_00528(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO OPZIONE 00530 (TIPO_OPZIONE_2473) 
            RRData.Calc_00530(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            RRData.Calc_05277(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia:01593.05
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159305(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.05";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            // DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // INDICATORE DURATA 
            RRData.Calc_00005(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
            RRData.Calc_00009(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE TITOLO SOTTOSTANTE 
            RRData.Calc_00033(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00033"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // RAPPORTI  OGGETTO DI COPERTURA
            RRData.Calc_00375(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DIGIT SE CONTRATTO DI COPERTURA 
            RRData.Calc_00377(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN EURO
            RRData.Calc_00609(formaTecnicaName, pFormaTecnicaIndex, pNominalSchedulesIndex, Convert.ToString("00609"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // Valore di contrattazione in EURO
            RRData.Calc_00610(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00610"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // Valore corrente rischi di mercato in EUR
            RRData.Calc_00724(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00724"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE DEL FAIR VALUE ATTIVITA' SOTTOSTANTE
            RRData.Calc_06315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // ESPOSIZIONE FUTURA
            RRData.Calc_00667(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO NEGATIVO 
            RRData.Calc_00696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VALORE NOMINALE IN VALUTA
            RRData.Calc_00709(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00709"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA FUTURES OPZIONI 
            RRData.Calc_00540(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00540"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // DELTA OPZIONI 00299 (DELTA_OPZIONI_0258) 
            RRData.Calc_00299(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE GAMMA 00526 (FATTORE_GAMMA_2497) 
            RRData.Calc_00526(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // FATTORE VEGA  00527 (FATTORE_VEGA_2478)
            RRData.Calc_00527(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // VOLATILITA IMPLICITA 00528 (VOLATILITA_IMPLICITA_2479) 
            RRData.Calc_00528(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPO OPZIONE 00530 (TIPO_OPZIONE_2473) 
            RRData.Calc_00530(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            RRData.Calc_05277(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //DATA E N PARTITA
            RRData.Calc_09418(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 01593.88
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159388(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.88";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00011	ATTIVITA ECONOMICA CONTROPARTE
            RRData.Calc_00011(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00011"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA FUTURES OPZIONI 
            RRData.Calc_00540(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00540"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00799	VALORE NOMINALE CONTRATTI IN DIVISA
            RRData.Calc_00799(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);

        }

        /// <summary>
        /// BancaItalia: 01593.89
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        public override void BuildFormaTecnica_0159389(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pNominalSchedulesIndex)
        {
            string formaTecnicaName = "01593.89";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            //00003	DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	DIGIT RESIDENZA
            RRData.Calc_00004(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00011	ATTIVITA ECONOMICA CONTROPARTE
            RRData.Calc_00011(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00011"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // TIPOLOGIA FUTURES OPZIONI 
            RRData.Calc_00540(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00540"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00799	VALORE NOMINALE CONTRATTI IN DIVISA
            RRData.Calc_00799(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pNominalSchedulesIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 58195.02
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pPaidReceivedCashFlowsIndex"></param>
        public override void BuildFormaTecnica_5819502(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pExchangedCashFlowsIndex)
        {
            string formaTecnicaName = "58195.02";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //STATO DELLA CONTROPARTE (codice UIC del paese di residenza)
            RRData.Calc_00016(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00016"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CONTROVALORE IN EURO PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00699(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE NOMINALE PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00799(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SEGNO
            RRData.Calc_CashFlow_Sign(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("CashFlow_Sign"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 58195.06
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pPaidReceivedCashFlowsIndex"></param>
        public override void BuildFormaTecnica_5819506(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex, int pExchangedCashFlowsIndex)
        {
            string formaTecnicaName = "58195.06";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data15];
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //STATO DELLA CONTROPARTE (codice UIC del paese di residenza)
            RRData.Calc_00016(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00016"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //CONTROVALORE IN EURO PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00699(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE NOMINALE PREMI MARGINI E DIFFERENZIALI 
            RRData.Calc_00799(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("00799"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // SEGNO
            RRData.Calc_CashFlow_Sign(formaTecnicaName, pExchangedCashFlowsIndex, Convert.ToString("CashFlow_Sign"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// Oasi: TIT.70 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT70(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.70";
            int dataIndex = 0;
            int MaxCountTIT70 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountTIT70];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659 
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052/ BKI 00010: DATA DI SCADENZA DELL'IMPEGNO
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_REVISIONE_CONTRATTO_1501
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_REVISIONE_CONTRATTO_1501"), Convert.ToString("00378"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150 /BKI 00007 CODICE VALUTA 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098/ BKI 00143
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAFOGLIO_IAS_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAFOGLIO_IAS_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_EURO_0420
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_EURO_0420"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_NOMINALE_VALUTA_0421
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_NOMINALE_VALUTA_0421"), Convert.ToString("00709"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CONTRATTAZIONE_EURO_0462
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CONTRATTAZIONE_EURO_0462"), Convert.ToString("00610"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_RISCHI_MERCATO_0329
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_RISCHI_MERCATO_0329"), Convert.ToString("00724"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //IMPORTO_FAIR_VALUE_1870
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("IMPORTO_FAIR_VALUE_1870"), Convert.ToString("06315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //********************************************************************************
            //Oasi specific rule: 
            //Il valore intrinseco coincide con il valore intrinseco IAS 
            //perch la differenza tra i due importi  pari al rateo, 
            //che per le opzioni  pari a zero
            //i risconti non vengono presi in conto nel calcolo del valore intrinseco IAS
            //********************************************************************************
            //VALORE_INTRINSECO_NEGATIVO_IAS_1907
            RRData.Calc_ValoreIntrinsecoNegativoIAS_1907(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_IAS_1907"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_IAS_1908
            RRData.Calc_ValoreIntrinsecoPositivoIAS_1908(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_IAS_1908"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_TITOLO_SOTTOSTANTE_0140
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_TITOLO_SOTTOSTANTE_0140"), Convert.ToString("00033"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DURATA_ORIGINARIA_ATTIVITA_1609
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DURATA_ORIGINARIA_ATTIVITA_1609"), Convert.ToString("00005"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_FUTURES_OPZIONI_0179
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_FUTURES_OPZIONI_0179"), Convert.ToString("00540"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // TIPO_OPZIONE_2473 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_STRUMENTO_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_STRUMENTO_2476"), Convert.ToString("00609"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_VEGA_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_VEGA_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // FATTORE_GAMMA_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("FATTORE_GAMMA_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_UNIVOCO_DERIVATO_2499
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_UNIVOCO_DERIVATO_2499"), Convert.ToString("05277"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:AIM.84
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_AIM84(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "AIM.84";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //LIVELLO_ULTERIORE_DETTAGLIO_0583 
            RRData.Calc_LivelloUlterioreDettaglio_0583(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0583"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_DIVISA_0003
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_DIVISA_0003"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIVISA_0009
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIVISA_0009"), Convert.ToString("00003"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOGRUPPO_0170
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOGRUPPO_0170"), Convert.ToString("00011"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_FUTURES_OPZIONI_0179
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_FUTURES_OPZIONI_0179"), Convert.ToString("00540"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //IMPORTO_0461
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("IMPORTO_0461"), Convert.ToString("00799"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:PMD.03 
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_PMD03(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "PMD.03";
            int dataIndex = 0;
            //
            int MaxCountPDM03 = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "r0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[MaxCountPDM03];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //LIVELLO_ULTERIORE_DETTAGLIO_0583 
            RRData.Calc_LivelloUlterioreDettaglio_0583(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("LIVELLO_ULTERIORE_DETTAGLIO_0583"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_DIVISA_0003
            RRData.Calc_ResidenzaDivisa(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_DIVISA_0003"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_DIVISA_ESTERA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_DIVISA_ESTERA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //STATO_0160
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("STATO_0160"), Convert.ToString("00016"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SALDO_CONTABILE_EURO_0300
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SALDO_CONTABILE_EURO_0300"), Convert.ToString("00699"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SALDO_CONTABILE_VALUTA_0301
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SALDO_CONTABILE_VALUTA_0301"), Convert.ToString("00799"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SEGNO 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SEGNO"), Convert.ToString("CashFlow_Sign"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }
    }

    /// <summary>
    /// Build forme tecniche for fxSimpleOption
    /// This class is empty. all fxSimpleOption FT are available into RRFormaTecnica class  
    /// </summary>
    public class RRFormaTecnicaFxSimpleOption : RRFormaTecnica
    {
        public RRFormaTecnicaFxSimpleOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRData = new RRDataFxSimpleOption(pDomesticCurrency, pReport);
        }

        /// <summary>
        /// BancaItalia: 01597.01
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public override void BuildFormaTecnica_0159701(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.01";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            // RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00154	 CODICE VALUTA DA RICEVERE
            RRData.Calc_00154(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00154"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00163	 CODICE VALUTA DA CONSEGNARE 
            RRData.Calc_00163(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00163"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204 NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375  RAPPORTI  OGGETTO DI COPERTURA
            //RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00683	 CONTROVALORE DELLE VALUTA DA CONSEGNARE
            RRData.Calc_00683(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00683"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00685	 CONTROVALORE DELLE VALUTE DA RICEVERE
            RRData.Calc_00685(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00685"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            //RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00783	 VALUTE DA CONSEGNARE
            RRData.Calc_00783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00785	 VALUTE DA RICEVERE
            RRData.Calc_00785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05277	 CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            //RRData.Calc_05277(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05315	 CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05316	 TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05530	 TIPOLOGIA OPZIONE 
            //RRData.Calc_05330(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05330"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            //RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
        }

        /// <summary>
        /// BancaItalia: 01597.05
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public override void BuildFormaTecnica_0159705(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.05";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007 CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00154	 CODICE VALUTA DA RICEVERE
            RRData.Calc_00154(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00154"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204 NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375 RAPPORTI  OGGETTO DI COPERTURA
            //RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00684	 AMMONTARE DEGLI EURO NEGOZIATI PER ACQ/VENDITE DI VALUTA
            RRData.Calc_00684(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00684"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00685	 CONTROVALORE DELLE VALUTE DA RICEVERE
            RRData.Calc_00685(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00685"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            //RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00785	 VALUTE DA RICEVERE
            RRData.Calc_00785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00940 NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05277	 CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            //RRData.Calc_05277(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05315	 CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05316	 TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            //RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);

    }

    /// <summary>
        /// BancaItalia: 01597.09
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public override void BuildFormaTecnica_0159709(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.09";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007 CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00163	 CODICE VALUTA DA CONSEGNARE
            RRData.Calc_00163(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00163"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375 RAPPORTI  OGGETTO DI COPERTURA
            //RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00683	 CONTROVALORE DELLE VALUTA DA CONSEGNARE
            RRData.Calc_00683(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00683"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00684	 AMMONTARE DEGLI EURO NEGOZIATI PER ACQ/VENDITE DI VALUTA
            RRData.Calc_00684(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00684"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            //RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00783	 VALUTE DA CONSEGNARE
            RRData.Calc_00783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00940 NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05277	 CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            //RRData.Calc_05277(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05315	 CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05316	 TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            //RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);

        }


        /// <summary>
        /// Oasi:TIT.75
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT75(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.75";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];

            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_VALUTA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_VALUTA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_EURO_NEGOZIATI_0459 - out of the scope data value in TIT.75
            RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_EURO_NEGOZIATI_0459"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CONTROVALORE_VALUTE_RICEVERE_0717
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), Convert.ToString("00685"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_VALUTA_RICEVERE_0718
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), Convert.ToString("00785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CONTROVALORE_VALUTE_CONSEGNARE_0719
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_CONSEGNARE_0719"), Convert.ToString("00683"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_VALUTA_CONSEGNARE_0720
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), Convert.ToString("00783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_IAS_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_IAS_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_RISCHIO_COPERTO_1850
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_RISCHIO_COPERTO_1850"), Convert.ToString("05316"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAF_IAS_COPERTO_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAF_IAS_COPERTO_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEG_BILANCIO_1907
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEG_BILANCIO_1907"), Convert.ToString("06696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POS_BILANCIO_1908
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POS_BILANCIO_1908"), Convert.ToString("06697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_OPZIONE_2473
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_SOTTOSTANTE_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_SOTTOSTANTE_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VEGA_PER_OPZIONI_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VEGA_PER_OPZIONI_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GAMMA_PER_OPZIONI_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GAMMA_PER_OPZIONI_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALUTA_RICEVERE_0150 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), Convert.ToString("00154"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALUTA_CONSEGNARE_0155 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), Convert.ToString("00163"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:TIT.77
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pDomesticCurrencyPosition"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT77(RegulatoryReportReport pReportOasi, string pDomesticCurrencyPosition, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.77";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            string domesticCurrencyPosition = pDomesticCurrencyPosition;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_VALUTA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_VALUTA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_EURO_NEGOZIATI_0459
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_EURO_NEGOZIATI_0459"), Convert.ToString("00684"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            if (domesticCurrencyPosition == "pay")
            {

                //VALUTA_RICEVERE_0150
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), Convert.ToString("00154"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTE_RICEVERE_0717
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), Convert.ToString("00685"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_RICEVERE_0718
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), Convert.ToString("00785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //VALUTA_CONSEGNARE_0155 - out of the scope value in TIT.77 and domesticCurrencyPosition == "pay"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTA_CONSEGNARE_0719 - out of the scope value in TIT.77 and domesticCurrencyPosition == "pay"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTA_CONSEGNARE_0719"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_CONSEGNARE_0720 - out of the scope value in TIT.77 and domesticCurrencyPosition == "pay"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            }
            //
            if (domesticCurrencyPosition == "rec")
            {
                //VALUTA_CONSEGNARE_0155
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), Convert.ToString("00163"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTA_CONSEGNARE_0719
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_CONSEGNARE_0719"), Convert.ToString("00683"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_CONSEGNARE_0720
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), Convert.ToString("00783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //VALUTA_RICEVERE_0150 - out of the scope value in TIT.77 and domesticCurrencyPosition == "rec"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTE_RICEVERE_0717 - out of the scope value in TIT.77 and domesticCurrencyPosition == "rec"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_RICEVERE_0718 - out of the scope value in TIT.77 and domesticCurrencyPosition == "rec"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            }
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_IAS_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_IAS_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_RISCHIO_COPERTO_1850
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_RISCHIO_COPERTO_1850"), Convert.ToString("05316"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAF_IAS_COPERTO_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAF_IAS_COPERTO_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEG_BILANCIO_1907
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEG_BILANCIO_1907"), Convert.ToString("06696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POS_BILANCIO_1908
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POS_BILANCIO_1908"), Convert.ToString("06697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_OPZIONE_2473
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_SOTTOSTANTE_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_SOTTOSTANTE_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VEGA_PER_OPZIONI_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VEGA_PER_OPZIONI_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GAMMA_PER_OPZIONI_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GAMMA_PER_OPZIONI_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }


    }

    /// <summary>
    /// Build forme tecniche for fxBarrierOption
    /// This class is empty. all fxSimpleOption FT are available into RRFormaTecnica class  
    /// </summary>
    public class RRFormaTecnicaFxBarrierOption : RRFormaTecnica
    {
        public RRFormaTecnicaFxBarrierOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRData = new RRDataFxBarrierOption(pDomesticCurrency, pReport);
        }

        /// <summary>
        /// BancaItalia: 01597.01
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public override void BuildFormaTecnica_0159701(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.01";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00154	 CODICE VALUTA DA RICEVERE
            RRData.Calc_00154(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00154"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00163	 CODICE VALUTA DA CONSEGNARE 
            RRData.Calc_00163(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00163"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204 NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375  RAPPORTI  OGGETTO DI COPERTURA
            //RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00683	 CONTROVALORE DELLE VALUTA DA CONSEGNARE
            RRData.Calc_00683(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00683"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00685	 CONTROVALORE DELLE VALUTE DA RICEVERE
            RRData.Calc_00685(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00685"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            //RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00783	 VALUTE DA CONSEGNARE
            RRData.Calc_00783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00785	 VALUTE DA RICEVERE
            RRData.Calc_00785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            // NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05277	 CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            //RRData.Calc_05277(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05315	 CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05316	 TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05530	 TIPOLOGIA OPZIONE 
            //RRData.Calc_05330(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05330"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            //RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
    }

    /// <summary>
        /// BancaItalia: 01597.05
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public override void BuildFormaTecnica_0159705(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.05";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007 CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00154	 CODICE VALUTA DA RICEVERE
            RRData.Calc_00154(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00154"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204 NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375 RAPPORTI  OGGETTO DI COPERTURA
            //RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00684	 AMMONTARE DEGLI EURO NEGOZIATI PER ACQ/VENDITE DI VALUTA
            RRData.Calc_00684(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00684"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00685	 CONTROVALORE DELLE VALUTE DA RICEVERE
            RRData.Calc_00685(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00685"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            //RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00785	 VALUTE DA RICEVERE
            RRData.Calc_00785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00940 NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05277	 CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            //RRData.Calc_05277(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05315	 CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05316	 TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            //RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);

        }

        /// <summary>
        /// BancaItalia: 01597.09
        /// </summary>
        /// <param name="pReportBancaItalia"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        public override void BuildFormaTecnica_0159709(RegulatoryReportReport pReportBancaItalia, int pFormaTecnicaIndex)
        {
            string formaTecnicaName = "01597.09";
            int pDataIndex = 0;
            //
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].sqc = "f0" + pFormaTecnicaIndex;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportBancaItalia.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[Data50];
            //00003	 DIGIT DIVISA
            RRData.Calc_00003(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00003"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00004	 DIGIT RESIDENZA 
            RRData.Calc_00004(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00004"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00005	 INDICATORE DURATA
            RRData.Calc_00005(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00005"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00007 CODICE VALUTA
            RRData.Calc_00007(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00007"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00009	 DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO 
            RRData.Calc_00009(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00009"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00010	 DATA DI SCADENZA DELL'IMPEGNO
            RRData.Calc_00010(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00010"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00013 SPORTELLO
            RRData.Calc_00013(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00013"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00030 CODICE ANAGRAFICO AZIENDALE
            RRData.Calc_00030(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00030"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00143	 TIPOLOGIA CONTRATTO
            RRData.Calc_00143(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00143"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00163	 CODICE VALUTA DA CONSEGNARE
            RRData.Calc_00163(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00163"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00204  NUMERO CONTO RAPPORTO
            RRData.Calc_00204(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00204"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00299	 DELTA PER OPZIONI  (3 INT. 3 DECIMALI)
            RRData.Calc_00299(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00299"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00375 RAPPORTI  OGGETTO DI COPERTURA
            //RRData.Calc_00375(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00375"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE
            RRData.Calc_05209(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05209"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00377  DIGIT SE CONTRATTO COPERTURA
            RRData.Calc_00377(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00377"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00520	 VALORE CORRENTE IN VALUTA STRUMENTO FINANZ.SOTTOSTANTE- METODO
            RRData.Calc_00520(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00520"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00526	 GAMMA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 8 DECIMALI)
            RRData.Calc_00526(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00526"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00527	 VEGA PER OPZIONI - METODO DELTA-PLUS (2 INTERI; 5 DECIMALI) 
            RRData.Calc_00527(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00527"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00528	 VOLATILITA' IMPLICITA - METODO DELTA-PLUS (2 INTERI, 5 DECIMALI
            RRData.Calc_00528(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00528"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00530	 TIPO OPZIONE 
            RRData.Calc_00530(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00530"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00667	 ESPOSIZIONE FUTURA 
            RRData.Calc_00667(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00667"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00683	 CONTROVALORE DELLE VALUTA DA CONSEGNARE
            RRData.Calc_00683(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00683"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00684	 AMMONTARE DEGLI EURO NEGOZIATI PER ACQ/VENDITE DI VALUTA
            RRData.Calc_00684(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00684"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00696	 VALORE INTRINSECO NEGATIVO
            RRData.Calc_00696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00697	 VALORE INTRINSECO POSITIVO
            RRData.Calc_00697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00699	 SOMMA VAL.NOMINALE CONTRATTI COMPENSATI SU TASSI DI INT.
            //RRData.Calc_00699(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00699"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00783	 VALUTE DA CONSEGNARE
            RRData.Calc_00783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //00940 NATURA CONTRATTO DERIVATO
            RRData.Calc_00940(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("00940"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //01175	 SERVIZIO IN CONTROPARTITA
            RRData.Calc_01175(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("01175"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05277	 CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
            //RRData.Calc_05277(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05277"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05315	 CLASSIFICAZIONE DEI DERIVATI AI FINI IAS
            RRData.Calc_05315(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05315"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05316	 TIPOLOGIA DI RISCHIO COPERTO
            RRData.Calc_05316(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05316"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05325	 TIPOLOGIA PORTAFOGLIO IAS COPERTO
            RRData.Calc_05325(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05325"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO NEGATIVO IAS
            RRData.Calc_06696(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06696"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //VALORE INTRINSECO POSITIVO IAS
            RRData.Calc_06697(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("06697"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //09418	DATA E N PARTITA
            //RRData.Calc_09418(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("09418"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //05416	CLIENTELA MIFID
            RRData.Calc_05416(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05416"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //GERARCHIA FAIR VALUE
            RRData.Calc_05344(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05344"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA DEL 31122009
            RRData.Calc_05783(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05783"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO
            RRData.Calc_05785(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05785"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);
            //ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'
            RRData.Calc_05260(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("05260"), pReportBancaItalia.formaTecnica[pFormaTecnicaIndex], pDataIndex++);

        }


        /// <summary>
        /// Oasi:TIT.75
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT75(RegulatoryReportReport pReportOasi, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.75";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];

            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_VALUTA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_VALUTA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_EURO_NEGOZIATI_0459 - out of the scope data value in TIT.75
            RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_EURO_NEGOZIATI_0459"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CONTROVALORE_VALUTE_RICEVERE_0717
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), Convert.ToString("00685"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_VALUTA_RICEVERE_0718
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), Convert.ToString("00785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CONTROVALORE_VALUTE_CONSEGNARE_0719
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_CONSEGNARE_0719"), Convert.ToString("00683"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_VALUTA_CONSEGNARE_0720
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), Convert.ToString("00783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_IAS_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_IAS_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_RISCHIO_COPERTO_1850
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_RISCHIO_COPERTO_1850"), Convert.ToString("05316"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAF_IAS_COPERTO_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAF_IAS_COPERTO_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEG_BILANCIO_1907
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEG_BILANCIO_1907"), Convert.ToString("06696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POS_BILANCIO_1908
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POS_BILANCIO_1908"), Convert.ToString("06697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_OPZIONE_2473
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_SOTTOSTANTE_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_SOTTOSTANTE_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VEGA_PER_OPZIONI_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VEGA_PER_OPZIONI_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GAMMA_PER_OPZIONI_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GAMMA_PER_OPZIONI_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALUTA_RICEVERE_0150 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), Convert.ToString("00154"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALUTA_CONSEGNARE_0155 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), Convert.ToString("00163"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897 
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }

        /// <summary>
        /// Oasi:TIT.77
        /// </summary>
        /// <param name="pReportOasi"></param>
        /// <param name="pDomesticCurrencyPosition"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pDataIndex"></param>
        public override void BuildFormaTecnicaOasi_TIT77(RegulatoryReportReport pReportOasi, string pDomesticCurrencyPosition, int pFormaTecnicaIndex, out int pDataIndex)
        {
            string formaTecnicaName = "TIT.77";
            int maxCount = RRDataLayout.MaxCountFieldInDataLayout(formaTecnicaName);
            int dataIndex = 0;
            string domesticCurrencyPosition = pDomesticCurrencyPosition;
            //
            pReportOasi.formaTecnica[pFormaTecnicaIndex].sqc = "ft0" + pFormaTecnicaIndex;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].name = formaTecnicaName;
            pReportOasi.formaTecnica[pFormaTecnicaIndex].data = new RegulatoryReportReportFormaTecnicaData[maxCount];
            //CODICE_BANCA
            RRData.Calc_CodiceBanca(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_BANCA"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOCE_STRALCIO_0001
            RRData.Calc_VoceStralcio_0001(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOCE_STRALCIO_0001"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_ANAGRAFICO_AZIENDALE_0125
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_ANAGRAFICO_AZIENDALE_0125"), Convert.ToString("00030"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SPORTELLO_0120
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SPORTELLO_0120"), Convert.ToString("00013"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NUMERO_CONTO_RAPPORTO_0655
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NUMERO_CONTO_RAPPORTO_0655"), Convert.ToString("00204"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SOTTOCODICE_CONTO_0659
            RRData.Calc_SottoCodiceConto_0659(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SOTTOCODICE_CONTO_0659"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //RESIDENZA_0008
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RESIDENZA_0008"), Convert.ToString("00004"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_INIZIO_RAPPORTO_0051
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_INIZIO_RAPPORTO_0051"), Convert.ToString("00009"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DATA_SCADENZA_RAPPORTO_0052
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DATA_SCADENZA_RAPPORTO_0052"), Convert.ToString("00010"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_VALUTA_0150
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_VALUTA_0150"), Convert.ToString("00007"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DELTA_OPZIONI_0258
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DELTA_OPZIONI_0258"), Convert.ToString("00299"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 05209 (ex. RAPPORTI_OGGETTO_COPERTURA_0346) 
            //RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("RAPPORTI_OGGETTO_COPERTURA_0346"), Convert.ToString("00375"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("PASS_ASSOCIATE_AD_ATTIV_VINCOLATE_05209_EX_0346"), Convert.ToString("05209"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //AMMONTARE_EURO_NEGOZIATI_0459
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_EURO_NEGOZIATI_0459"), Convert.ToString("00684"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ACQUIRENTE_VENDITORE_0567
            RRData.Calc_AcquirenteVenditore_0567(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ACQUIRENTE_VENDITORE_0567"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            if (domesticCurrencyPosition == "pay")
            {

                //VALUTA_RICEVERE_0150
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), Convert.ToString("00154"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTE_RICEVERE_0717
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), Convert.ToString("00685"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_RICEVERE_0718
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), Convert.ToString("00785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //VALUTA_CONSEGNARE_0155 - out of the scope value in TIT.77 and domesticCurrencyPosition == "pay"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTA_CONSEGNARE_0719 - out of the scope value in TIT.77 and domesticCurrencyPosition == "pay"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTA_CONSEGNARE_0719"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_CONSEGNARE_0720 - out of the scope value in TIT.77 and domesticCurrencyPosition == "pay"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            }
            //
            if (domesticCurrencyPosition == "rec")
            {
                //VALUTA_CONSEGNARE_0155
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_CONSEGNARE_0155"), Convert.ToString("00163"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTA_CONSEGNARE_0719
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_CONSEGNARE_0719"), Convert.ToString("00683"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_CONSEGNARE_0720
                RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_CONSEGNARE_0720"), Convert.ToString("00783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //VALUTA_RICEVERE_0150 - out of the scope value in TIT.77 and domesticCurrencyPosition == "rec"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALUTA_RICEVERE_0150"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //CONTROVALORE_VALUTE_RICEVERE_0717 - out of the scope value in TIT.77 and domesticCurrencyPosition == "rec"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CONTROVALORE_VALUTE_RICEVERE_0717"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
                //AMMONTARE_VALUTA_RICEVERE_0718 - out of the scope value in TIT.77 and domesticCurrencyPosition == "rec"
                RRData.Build_OutOfTheScopeDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("AMMONTARE_VALUTA_RICEVERE_0718"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            }
            //TIPOLOGIA_CONTRATTO_1098
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_CONTRATTO_1098"), Convert.ToString("00143"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ESPOSIZIONE_FUTURA_1175
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONE_FUTURA_1175"), Convert.ToString("00667"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEGATIVO_1177
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEGATIVO_1177"), Convert.ToString("00696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POSITIVO_1178
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POSITIVO_1178"), Convert.ToString("00697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //DIGIT_SE_CONTRATTO_COPERTURA_1500
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("DIGIT_SE_CONTRATTO_COPERTURA_1500"), Convert.ToString("00377"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLASSIFICAZIONE_DERIVATI_IAS_1849
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLASSIFICAZIONE_DERIVATI_IAS_1849"), Convert.ToString("05315"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_RISCHIO_COPERTO_1850
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_RISCHIO_COPERTO_1850"), Convert.ToString("05316"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPOLOGIA_PORTAF_IAS_COPERTO_1858
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPOLOGIA_PORTAF_IAS_COPERTO_1858"), Convert.ToString("05325"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_NEG_BILANCIO_1907
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_NEG_BILANCIO_1907"), Convert.ToString("06696"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_INTRINSECO_POS_BILANCIO_1908
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_INTRINSECO_POS_BILANCIO_1908"), Convert.ToString("06697"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //NATURA_CONTRATTO_DERIVATO_2471
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("NATURA_CONTRATTO_DERIVATO_2471"), Convert.ToString("00940"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //TIPO_OPZIONE_2473
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("TIPO_OPZIONE_2473"), Convert.ToString("00530"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VALORE_CORRENTE_SOTTOSTANTE_2476
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VALORE_CORRENTE_SOTTOSTANTE_2476"), Convert.ToString("00520"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VEGA_PER_OPZIONI_2478
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VEGA_PER_OPZIONI_2478"), Convert.ToString("00527"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //VOLATILITA_IMPLICITA_2479
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("VOLATILITA_IMPLICITA_2479"), Convert.ToString("00528"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GAMMA_PER_OPZIONI_2497
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GAMMA_PER_OPZIONI_2497"), Convert.ToString("00526"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //GERARCHIA_FAIRVALUE_1897
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("GERARCHIA_FAIRVALUE_1897"), Convert.ToString("05344"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ATTIVITA_NEGOZ_CONTO_PROPRIO_SVOLTA_SERV_INVESTIMENTO_1958"), Convert.ToString("05785"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //SERVIZIO_CONTROPARTITA_2066
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("SERVIZIO_CONTROPARTITA_2066"), Convert.ToString("01175"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CLIENTELA_MIFID_2192
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CLIENTELA_MIFID_2192"), Convert.ToString("05416"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            // ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("ESPOSIZIONI_ASSUNTE_PRIMA_31122009_1970"), Convert.ToString("05783"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495
            RRData.CopyDataValue(formaTecnicaName, pFormaTecnicaIndex, Convert.ToString("CODICE_IDENTIFICAZIONE_GRUPPO_PASSIVITA_1495"), Convert.ToString("05260"), pReportOasi.formaTecnica[pFormaTecnicaIndex], dataIndex++);
            //
            pDataIndex = dataIndex;
        }


    }

    /// <summary>
    /// Build forme tecniche for fxDigitalOption
    /// This class is empty. all fxSimpleOption FT are available into RRFormaTecnica class  
    /// </summary>
    public class RRFormaTecnicaFxDigitalOption : RRFormaTecnica
    {
        public RRFormaTecnicaFxDigitalOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRData = new RRDataFxDigitalOption(pDomesticCurrency, pReport);
        }
    }

    /// <summary>
    /// class containing methods to calculate the Puma2 fields  
    /// </summary>
    public class RRData
    {
        #region Members
        private string m_DomesticCurrency;
        protected RegulatoryReport m_Report;
        private RRGetBusinessInfos m_RRGetBusinessInfos;
        // data attribute
        protected string m_DataSourceProcess;
        protected string m_DataSourceStatic;
        protected string m_DataMissingAlertLevelError;
        protected string m_DataMissingAlertLevelWarning;
        #endregion
        #region Accessors
        public string DomesticCurrency
        {
            get { return this.m_DomesticCurrency; }
            set { this.m_DomesticCurrency = value; }
        }
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public RRGetBusinessInfos RRGetBusinessInfos
        {
            get { return this.m_RRGetBusinessInfos; }
            set { this.m_RRGetBusinessInfos = value; }
        }
        // data attribute
        public string DataSourceProcess
        {
            get { return this.m_DataSourceProcess; }
        }
        public string DataSourceStatic
        {
            get { return this.m_DataSourceStatic; }
        }
        public string DataMissingAlertLevelError
        {
            get { return this.m_DataMissingAlertLevelError; }
        }
        public string DataMissingAlertLevelWarning
        {
            get { return this.m_DataMissingAlertLevelWarning; }
        }
        #endregion
        #region Constructor
        public RRData(string pDomesticCurrency, RegulatoryReport pReport)
        {
            Report = pReport;
            DomesticCurrency = pDomesticCurrency;
            m_DataSourceProcess = Convert.ToString("process");
            m_DataSourceStatic = Convert.ToString("static");
            m_DataMissingAlertLevelError = Convert.ToString("ERROR");
            m_DataMissingAlertLevelWarning = Convert.ToString("WARNING");
        }
        #endregion
        virtual public void Calc_00033(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00113(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00117(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00130(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00143(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00378(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00540(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00610(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00724(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_06315(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00667(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00696(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00697(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00709(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00709(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00710(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00799(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_05330(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_06696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_06696(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_06697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_06697(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00370(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_00520(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Sign_00520(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_AcquirenteVenditore_0567(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_UniqueCodeRelationship(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_SequenceNumber(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_ValoreIntrinsecoNegativoIAS_1907(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }
        virtual public void Calc_ValoreIntrinsecoPositivoIAS_1908(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        { }

        /// <summary>
        /// It returns the value of a field 'data' from BKI formaTecnica
        /// This void is used by Elsag and Oasi subSystem
        /// </summary>
        /// <param name="pDataId"></param>
        /// <param name="pIndex"></param>
        protected string GetDataValue(string pDataId, int pIndex)
        {
            string dataValue = string.Empty;
            for (int i = 0; i < Report.report[0].formaTecnica[pIndex].data.Length; i++)
            {
                if (Report.report[0].formaTecnica[pIndex].data[i].field == pDataId)
                {
                    if (Report.report[0].formaTecnica[pIndex].data[i].value != null)
                    {
                        dataValue = Convert.ToString(Report.report[0].formaTecnica[pIndex].data[i].value);
                        return dataValue;
                    }
                    return dataValue;
                }
            }
            return dataValue;
        }

        /// <summary>
        /// GetErrorMessage
        /// Returns the error message from BKI formaTecnica field if exists
        /// This void is used by Elsag and Oasi
        /// </summary>
        /// <param name="pDataId"></param>
        /// <param name="pIndex"></param>
        protected string GetErrorMessage(string pDataId, int pIndex)
        {
            string errorMessage = null;
            for (int i = 0; i < Report.report[0].formaTecnica[pIndex].data.Length; i++)
            {
                if (Report.report[0].formaTecnica[pIndex].data[i].field == pDataId)
                {
                    if (Report.report[0].formaTecnica[pIndex].data[i].errMsg != null)
                    {
                        errorMessage = Convert.ToString(Report.report[0].formaTecnica[pIndex].data[i].errMsg);
                        return errorMessage;
                    }
                    else
                        return errorMessage;
                }
            }
            return errorMessage;
        }

        /// <summary>
        /// Read the "data" object from BKI formaTecnica (using the BKI data original name)
        /// Build a new "data" object
        /// Enhances new "data" object value with BKI data value 
        /// </summary>
        /// <param name="pFormaTecnica"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pOriginalDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void CopyDataValue(string pFormaTecnica, int pIndex, string pDataId, string pOriginalDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = GetDataValue(pOriginalDataId, pIndex);
            string errorMessage = GetErrorMessage(pOriginalDataId, pIndex);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnica, pDataIndex, pDataId, null, pOriginalDataId, DataSourceProcess, dataValue, errorMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// build dataValue element with out-of-the-scope value
        /// "*" is OASI subsystem out-of-the-scope value
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Build_OutOfTheScopeDataValue(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = string.Empty;
            string outOfTheScopeDataValue = Convert.ToString("*");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, outOfTheScopeDataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }


        /// <summary>
        /// INDICATORE DURATA 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00005(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "INDICATORE DURATA";
            string errMessage = "Indicazione durata non valorizzata. Verificare la trade date e la termination date";
            DateTime tradeDate = RRGetBusinessInfos.GetTradeDate();
            DateTime terminationDate = RRGetBusinessInfos.GetTerminationDate();
            TimeSpan dateDifference = RRGetBusinessInfos.GetDateDifference(terminationDate, tradeDate);

            if (dateDifference.Days <= 365)
                dataValue = Convert.ToString("1");
            if (dateDifference.Days > 365)
                dataValue = Convert.ToString("2");

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA DI SCADENZA DELL'IMPEGNO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00010(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].settlementDate, "yyyyMMdd");
                    break;
                case "03903.04":
                case "03903.06":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetForwardCashFlowSettlementDate(pIndex), "yyyyMMdd");
                    break;
                default:
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                    break;
            }
            string dataDisplayName = "DATA DI SCADENZA IMPEGNO";
            string errMessage = "Data di scadenza impegno assente. Verificare la termination date";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DELTA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00299(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "DELTA OPZIONI";
            string errMessage = null;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// FATTORE GAMMA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00526(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "FATTORE GAMMA";
            string errMessage = null;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;

        }

        /// <summary>
        /// FATTORE VEGA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00527(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "FATTORE VEGA";
            string errMessage = null;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VOLATILITA IMPLICITA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00528(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VOLATILITA IMPLICITA";
            string errMessage = null;
            //
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;


        }

        /// <summary>
        /// TIPO OPZIONE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00530(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO OPZIONE";
            string errMessage = null;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DIGIT DIVISA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00003(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage;
            string idc;

            switch (pFormaTecnicaName)
            {
                case "01597.01":
                case "01597.05":
                case "01597.09":
                case "01597.88":
                case "01597.90":
                    if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                    {
                        idc = RRGetBusinessInfos.GetPayCurrencyIdc();
                        errMessage = "Codice divisa del flusso da pagare assente.";
                    }
                    else
                    {
                        idc = RRGetBusinessInfos.GetRecCurrencyIdc();
                        errMessage = "Codice divisa del flusso da ricevere assente.";
                    }
                    break;
                case "01597.13":
                case "01597.89":
                    idc = RRGetBusinessInfos.GetPayCurrencyIdc();
                    errMessage = "Codice divisa del flusso da pagare assente.";
                    break;
                case "01597.17":
                case "01597.91":
                    idc = RRGetBusinessInfos.GetRecCurrencyIdc();
                    errMessage = "Codice divisa del flusso da ricevere assente.";
                    break;
                case "01593.98":
                case "01593.99":
                    idc = Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].idc;
                    errMessage = "Codice divisa del nozionale assente.";
                    break;
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    errMessage = "Codice divisa del flusso regolato assente.";
                    break;
                case "03903.04":
                case "03903.06":
                    idc = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].idc;
                    errMessage = "Codice divisa del flusso futuro da regolare assente.";
                    break;
                default:
                    idc = RRGetBusinessInfos.GetNotionalAmountIdc(pIndex);
                    errMessage = "Codice divisa del nozionale assente.";
                    break;
            }

            string dataValue = (idc == DomesticCurrency) ? "1" : "2";
            string dataDisplayName = "DIGIT DIVISA";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DIGIT RESIDENZA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00004(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "DIGIT RESIDENZA";
            string counterparty = RRGetBusinessInfos.GetCounterpartyIdentifier();
            string idCountryResidence = RRGetBusinessInfos.GetIdCountryResidence();
            string errMessage = "Codice residenza assente per la controparte [" + counterparty + "].";
            if (idCountryResidence == "IT")
                dataValue = "1";
            if (idCountryResidence != "IT")
                dataValue = "2";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_00007(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "CODICE VALUTA";
            string errMessage;
            switch (pFormaTecnicaName)
            {
                // IRD
                case "01593.98":
                case "01593.99":
                    dataValue = Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].uicCurrencyCode;
                    errMessage = "Codice divisa del nozionale assente.";
                    break;
                // FXOPTION
                case "01597.05":
                    dataValue = RRGetBusinessInfos.GetRecCurrencyUicCode();
                    errMessage = "Codice divisa del flusso da ricevere assente.";
                    break;
                case "01597.09":
                    dataValue = RRGetBusinessInfos.GetPayCurrencyUicCode();
                    errMessage = "Codice divisa del flusso da pagare assente.";
                    break;
                case "58195.02":
                case "58195.06":
                    dataValue = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].uicCurrencyCode;
                    errMessage = "Codice divisa del flusso regolato assente.";
                    break;
                case "03903.04":
                case "03903.06":
                    dataValue = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].uicCurrencyCode;
                    errMessage = "Codice divisa del flusso futuro da regolate assente.";
                    break;
                default:
                    dataValue = RRGetBusinessInfos.GetNotionalAmountUicCode(pIndex);
                    errMessage = "Codice divisa del nozionale assente.";
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA DI INIZIO DELL'OPERAZIONE O DEL RAPPORTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00009(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DATA DI INIZIO OPERAZIONE/RAPPORTO";
            string errMessage = "Data di accensione del trade assente (trade date).";
            string dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTradeDate(), "yyyyMMdd");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ATTIVITA ECONOMICA CONTROPARTE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00011(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "ATTIVITA ECONOMICA CONTROPARTE";
            string counterparty = RRGetBusinessInfos.GetCounterpartyIdentifier();
            string errMessage = "Economic area code assente per la controparte [" + counterparty + "].";
            string dataValue = Convert.ToString("0") + RRGetBusinessInfos.GetEconomicAreaCode();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SPORTELLO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00013(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "SPORTELLO";
            string counterparty = RRGetBusinessInfos.GetCounterpartyIdentifier();
            string errMessage = "Numero rapporto assente per la controparte [" + counterparty + "].";
            string dataValue = RRGetBusinessInfos.GetSportello();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// STATO DELLA CONTROPARTE
        /// codice UIC del paese di residenza
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00016(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "STATO DELLA CONTROPARTE";
            string counterparty = RRGetBusinessInfos.GetCounterpartyIdentifier();
            string errMessage = "Codice UIC del Paese di residenza assente per la controparte [" + counterparty + "].";
            string dataValue = RRGetBusinessInfos.GetUicCountryCode();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE ANAGRAFICO AZIENDALE (ndg)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00030(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CODICE ANAGRAFICO AZIENDALE";
            string counterparty = RRGetBusinessInfos.GetCounterpartyIdentifier();
            string errMessage = "Numero direzione generale assente per la controparte [" + counterparty + "].";
            string dataValue = RRGetBusinessInfos.GetNdg();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE VALUTA DA RICEVERE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00154(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CODICE VALUTA DA RICEVERE";
            string errMessage = "Codice divisa del flusso da ricevere assente.";

            string dataValue;
            if (RRGetBusinessInfos.GetRecCurrencyIdc() != DomesticCurrency)
                dataValue = RRGetBusinessInfos.GetRecCurrencyUicCode();
            else
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE VALUTA DA CONSEGNARE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00163(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CODICE VALUTA DA CONSEGNARE";
            string errMessage = "Codice divisa del flusso da consegnare assente.";

            string dataValue;
            if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                dataValue = RRGetBusinessInfos.GetPayCurrencyUicCode();
            else
                dataValue = Convert.ToString("0");

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DIGIT VALORE SOTTOSTANTE AL CONTRATTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00183(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "DIGIT VALORE SOTTOSTANTE AL CONTRATTO";
            string errMessage = string.Empty;
            //
            bool isCommodityPayCurrency = RRGetBusinessInfos.GetPayCurrencyIsCommodity();
            bool isCommodityRecCurrency = RRGetBusinessInfos.GetRecCurrencyIsCommodity();
            //
            if (isCommodityPayCurrency == true)
            {
                errMessage = "Campo non valorizzato. Controllare il campo business code_0183 delle commodity extra info nella sezione payCurrencyAmount";
                dataValue = RRGetBusinessInfos.GetPayCommodityExtraInfoCode0183();
            }
            else if (isCommodityRecCurrency == true)
            {
                errMessage = "Campo non valorizzato. Controllare il campo business code_0183 delle commodity extra info nella sezione recCurrencyAmount";
                dataValue = RRGetBusinessInfos.GetRecCommodityExtraInfoCode0183();
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// NUMERO CONTO RAPPORTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00204(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "NUMERO CONTO RAPPORTO";
            string counterparty = Report.trade.dataDocument.repository.counterparty.identifier;
            string errMessage = "Numero conto rapporto assente. Verificare il codice di direzione generale per l'attore [" + counterparty + "].";
            string dataValue = RRGetBusinessInfos.GetNumeroContoRapporto();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DIGIT SE CONTRATTO DI COPERTURA
        /// From Puma2 document:
        /// 0 = di negoziazione (valore di default) 
        /// 1 = di copertura di rischi non relativi a titoli del  portafoglio non immobilizzato                     
        /// 2 = di copertura di rischi relativi a titoli del portafoglio non immobilizzato                     
        /// 3 = di copertura ai finanziamenti con clausola  "cross-default"
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00377(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "DIGIT SE CONTRATTO DI COPERTURA";
            string book = Report.trade.dataDocument.repository.mainActor.bookIdentifier;
            string errMessage = "Classificazione derivati IAS assente per il book [" + book + "].";
            string IasDerivativeClassification = RRGetBusinessInfos.GetIasDerivativeClassification();

            if (IasDerivativeClassification != String.Empty)
            {
                switch (IasDerivativeClassification)
                {
                    // trading
                    case "00":
                        dataValue = "0";
                        break;
                    // hedging as default 
                    default:
                        dataValue = "1";
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPO PRODOTTO SPECIFICO MERCI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00525(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO PRODOTTO SPECIFICO MERCI";
            string errMessage = string.Empty;
            bool isCommodityPayCurrency = RRGetBusinessInfos.GetPayCurrencyIsCommodity();
            bool isCommodityRecCurrency = RRGetBusinessInfos.GetRecCurrencyIsCommodity();

            if (isCommodityPayCurrency == true)
            {
                errMessage = "Campo non valorizzato. Controllare il campo business code_0525 delle commodity extra info nella sezione payCurrencyAmount";
                dataValue = RRGetBusinessInfos.GetPayCommodityExtraInfoCode0525();
            }
            else if (isCommodityRecCurrency == true)
            {
                errMessage = "Campo non valorizzato. Controllare il campo business code_0525 delle commodity extra info nella sezione recCurrencyAmount";
                dataValue = RRGetBusinessInfos.GetRecCommodityExtraInfoCode0525();
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CONTROVALORE DELLE VALUTA DA CONSEGNARE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00683(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CONTROVALORE DELLE VALUTA DA CONSEGNARE";
            string errMessage = "Campo non valorizzato. Verificare la controvalorizzazione in Euro della divisa da consegnare." + pIndex;
            string dataValue;
            if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
            else
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// AMMONTARE DEGLI EURO NEGOZIATI PER ACQ/VENDITE DI VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00684(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "AMMONTARE DEGLI EURO NEGOZIATI PER ACQ/VENDITE DI VALUTA";
            string errMessage = "Campo non valorizzato. Verificare la controvalorizzazione in Euro della divisa da consegnare." + pIndex;
            string dataValue;
            if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
            else
                dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CONTROVALORE DELLE VALUTA DA RICEVERE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00685(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CONTROVALORE DELLE VALUTA DA RICEVERE";
            string errMessage = "Campo non valorizzato. Verificare la controvalorizzazione in Euro della divisa da ricevere." + pIndex;
            string dataValue;
            if (RRGetBusinessInfos.GetRecCurrencyIdc() != DomesticCurrency)
                dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
            else
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALUTA DA CONSEGNARE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00783(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALUTA DA CONSEGNARE";
            string errMessage = "Campo non valorizzato. Verificare il valore della valuta da consegnare." + pIndex;
            string dataValue;
            if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
            else
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALUTA DA RICEVERE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00785(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALUTA DA RICEVERE";
            string errMessage = "Campo non valorizzato. Verificare la valore della valuta da ricevere." + pIndex;
            string dataValue;
            if (RRGetBusinessInfos.GetRecCurrencyIdc() != DomesticCurrency)
                dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
            else
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// NATURA CONTRATTO DERIVATO
        /// Viene valorizzato con "000": derivato non strutturato.
        /// Viene valorizzato con "016": per derivato in un contratto "ospite" derivato
        /// Viene valorizzato con "017": per derivato "ospite" 
        /// (*) Per "Ospite" si intende il derivato master
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_00940(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "NATURA CONTRATTO DERIVATO";
            string errMessage = "Campo non valorizzato.";
            bool isStructuredProduct = Report.trade.header.isStructuredProduct;
            bool isStructuredMaster = Report.trade.header.isStructuredMaster;

            if (isStructuredProduct == true)
            {
                if (isStructuredMaster == true)
                    dataValue = "017";
                if (isStructuredMaster == false)
                    dataValue = "016";
            }
            else
                dataValue = "000";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SERVIZIO IN CONTROPARTITA
        /// From Puma2 documentation
        /// 103 = esecuzione di ordini per conto cliente
        /// 104 = gestione di portafogli
        /// 105 = collocamento
        /// 770 = non applicabile
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_01175(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "SERVIZIO IN CONTROPARTITA";
            string errMessage = "Campo non valorizzato.";
            bool isCounterpartyClient = RRGetBusinessInfos.GetIsCounterPartyClient();
            if (isCounterpartyClient == true)
                dataValue = Convert.ToString("103");
            else if (isCounterpartyClient == false)
                dataValue = Convert.ToString("770");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05277(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CODICE UNIVOCO DELLA STRUTTURA DEL DERIVATO";
            string errMessage = "Campo non valorizzato.";
            // if the trade is into structured product return concat string (linkID+dateFromField00010+CounterpartyType)
            bool isStructuredProduct = Report.trade.header.isStructuredProduct;

            string dataValue;
            if (isStructuredProduct)
            {
                string linkId = Report.trade.header.structuredIdentifier;
                string formattedLinkId = null;
                char padChar = '0';

                if (linkId.Length == 8)
                    formattedLinkId = linkId;

                if (linkId.Length > 8)
                    formattedLinkId = Convert.ToString(linkId.Substring(1, 8));

                if (linkId.Length < 8)
                    formattedLinkId = Convert.ToString(linkId.PadLeft(8, padChar));

                string ExpiryDate = GetDataValue(Convert.ToString("00010"), pIndex);

                string counterPartyType;
                if (Report.trade.dataDocument.repository.counterparty.isClient)
                    counterPartyType = "C";
                else
                    counterPartyType = "E";

                dataValue = formattedLinkId + Convert.ToString(ExpiryDate.Substring(2, 6)) + counterPartyType;
            }
            // GS 20101224: to verify if this value can be handle from datalayout 
            // if trade is not structured product returns static value (*)
            else
                dataValue = Convert.ToString("*");
            //
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CLASSIFICAZIONE DEI DERIVATI AI FINI IAS 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05315(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "CLASSIFICAZIONE DEI DERIVATI AI FINI IAS";
            string book = Report.trade.dataDocument.repository.mainActor.bookIdentifier;
            string errMessage = "Classificazione derivati IAS assente per il book [" + book + "].";
            string IasDerivativeClassification = RRGetBusinessInfos.GetIasDerivativeClassification();
            if (IasDerivativeClassification != String.Empty)
                dataValue = IasDerivativeClassification;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA DI RISCHIO COPERTO
        /// from Puma2 document:
        /// 0= NESSUNA COPERTURA;  
        /// 1= RISCHIO DI TASSO DI INTERESSE
        /// 2= RISCHIO DI CAMBIO; 
        /// 3= RISCHIO DI CREDITO
        /// 4= RISCHIO DI PREZZO; 
        /// 5= PIU' RISCHI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05316(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA DI RISCHIO COPERTO";
            string book = Report.trade.dataDocument.repository.mainActor.bookIdentifier;
            string errMessage = "Classificazione derivati IAS assente per il book [" + book + "].";

            string productFamily = RRGetBusinessInfos.GetProductFamily();
            string IasDerivativeClassification = RRGetBusinessInfos.GetIasDerivativeClassification();

            switch (IasDerivativeClassification)
            {
                case "00":
                    dataValue = "0";
                    break;
                case "01":
                    if (productFamily == "IRD")
                        dataValue = "1";
                    if (productFamily == "FX")
                        dataValue = "2";
                    break;
                default:
                    dataValue = "0";
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA PORTAFOGLIO IAS COPERTO 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05325(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "TIPOLOGIA PORTAFOGLIO IAS COPERTO";
            string book = Report.trade.dataDocument.repository.mainActor.bookIdentifier;
            string errMessage = "Tipologia portafoglio IAS coperto assente per il book [" + book + "].";
            string dataValue = RRGetBusinessInfos.GetIasHedgedDerivativeClassification();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CLIENTELA MIFID
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05416(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CLIENTELA MIFID";
            string actorIdentifier = RRGetBusinessInfos.GetCounterpartyIdentifier();
            string errMessage = "Classificazione Mifid assente per il l'attore [" + actorIdentifier + "].";
            string dataValue = RRGetBusinessInfos.GetMifidClientCategorisation();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// GERARCHIA FAIRVALUE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_05344(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "GERARCHIA FAIRVALUE";
            string errMessage = string.Empty;
            string dataValue = RRGetBusinessInfos.GetFairValueHierarchy();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ESPOSIZIONI ASSUNTE PRIMA DEL 31.12.2009 
        /// REMARK: This date is static or it is dynamic? 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05783(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "ESPOSIZIONI ASSUNTE PRIMA DEL 31.12.2009";
            string errMessage = "Esposizioni prima del 31.12.2009 non valorizzato. Verificare la data di accensione del contratto.";
            DateTime effectiveDate = RRGetBusinessInfos.GetTradeDate();
            DateTime checkDate = Convert.ToDateTime("31-12-2009");

            string dataValue;
            if (effectiveDate < checkDate)
                dataValue = Convert.ToString("1");
            else
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05785(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "ATTIVITA' DI NEGOZIAZIONE IN CONTO PROPRIO PER SERVIZI DI INVESTIMENTO";
            string errMessage = "Campo non valorizzato.";
            bool isClient = RRGetBusinessInfos.GetIsCounterPartyClient();
            if (isClient == true)
                dataValue = Convert.ToString("1");
            else if (isClient == false)
                dataValue = Convert.ToString("0");
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE 
        /// GS 20171121: ticket 23269 - Verifica su campi OTCml 0346 e 1495 [BANCAPERTA]
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05209(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "PASSIVIT ASSOCIATE AD ATTIVITA' VINCOLATE";
            string errMessage = "Campo non valorizzato.";
            if (Report.trade.dataDocument.repository.masterAgreement != null)
            {
                bool isCSA = RRGetBusinessInfos.ExistsCSA();
                // intrinsic value < zero (Main Actor:payer - Counterparty:receiver)
                // intrinsic value > zero (MainActor:receiver - Counterparty:payer)
                decimal IntrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(pIndex);

                if (isCSA && (IntrinsicValue < 0))
                    dataValue = Convert.ToString("1");
                else
                    dataValue = Convert.ToString("0");
            }

            else
                dataValue = Convert.ToString("0");

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA' 
        /// GS 20171121: ticket 23269 - Verifica su campi OTCml 0346 e 1495 [BANCAPERTA]
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_05260(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "ASSET ENCUMBRANCE, CODICE IDENTIFICAZIONE GRUPPO DI PASSIVITA'";
            string errMessage = "Campo non valorizzato.";

            if (Report.trade.dataDocument.repository.masterAgreement != null)
            {
                bool isCSA = RRGetBusinessInfos.ExistsCSA();
                // intrinsic value < zero (Main Actor:payer - Counterparty:receiver)
                // intrinsic value > zero (MainActor:receiver - Counterparty:payer)
                decimal IntrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(pIndex);

                if ((isCSA == true) && (IntrinsicValue < 0))
                    dataValue = Convert.ToString("DERIVAT0010000000000");
                else
                    dataValue = Convert.ToString("*");
            }

            else
                dataValue = Convert.ToString("*");

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DIFFERENZIALI DA RICEVERE/PAGARE SU DERIVATI FINANZIARI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_07014(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DIFFERENZIALI DA RICEVERE/PAGARE SU DERIVATI FINANZIARI";
            string errMessage = "Differenziali da ricevere/pagare non valorizzati. Verificare che siano presenti nel trade flussi futuri da pagare e/o da ricevere.";
            string idc = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].idc;

            string dataValue;
            if (idc != DomesticCurrency)
                dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
            else
                dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].amount));
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA E NUMERO PARTITA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_09418(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "DATA E NUMERO PARTITA";
            string errMessage;
            string tradeIdentifier = RRGetBusinessInfos.GetTradeIdentifier();
            string exportDate = RRGetBusinessInfos.GetExportDate().ToString("yyyyMMdd");
            char pad = '0';

            switch (pFormaTecnicaName)
            {
                case "03903.04":
                case "03903.06":
                    errMessage = "Data e numero partita non valorizzato. Verificare che siano presenti nel trade flussi futuri da pagare e/o da ricevere";
                    string settlementDate = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetForwardCashFlowSettlementDate(pIndex), "yyyyMMdd");
                    dataValue = tradeIdentifier.PadLeft(8, pad) + settlementDate.PadLeft(8, pad);
                    break;
                default:
                    errMessage = "Data e numero partita non valorizzato. Varificare data di esportazione e identificativo del trade.";
                    dataValue = Convert.ToString(exportDate + tradeIdentifier.PadLeft(8, pad));
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SEGNO CASH FLOW
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_CashFlow_Sign(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "SEGNO CASH FLOW";
            string errMessage = "Segno dei differenziali ricevuti/pagati non valorizzato. Verificare che siano presenti nel trade flussi pagati e/o ricevuti.";

            switch (pFormaTecnicaName)
            {
                // flussi incassati
                case "58195.02":
                    dataValue = "-";
                    break;
                // flussi pagati
                case "58195.06":
                    dataValue = "+";
                    break;
                // differenziali da ricevere;
                case "03903.04":
                    dataValue = "+";
                    break;
                // differenziali da consegnare;
                case "03903.06":
                    dataValue = "-";
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Codice Residenza Divisa
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        virtual public void Calc_ResidenzaDivisa(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Codice residenza divisa non valorizzato. Verificare che siano presenti il codice di residenza della controparte e il codice idc del flusso da dichiarare. ";
            string idCountryResidence = RRGetBusinessInfos.GetIdCountryResidence();
            string idc;

            switch (pFormaTecnicaName)
            {
                case "01597.88":
                case "01597.90":
                    if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                        idc = RRGetBusinessInfos.GetPayCurrencyIdc();
                    else
                        idc = RRGetBusinessInfos.GetRecCurrencyIdc();
                    break;
                case "01597.89":
                    idc = RRGetBusinessInfos.GetPayCurrencyIdc();
                    break;
                case "01597.91":
                    idc = RRGetBusinessInfos.GetRecCurrencyIdc();
                    break;
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    break;
                case "03903.04":
                case "03903.06":
                    idc = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].idc;
                    break;
                // for open and closed IRD (01593.88/01593.89)
                default:
                    idc = RRGetBusinessInfos.GetNotionalAmountIdc(pIndex);
                    break;
            }

            if (idCountryResidence == "IT")
            {
                if (idc == DomesticCurrency)
                    dataValue = "1";
                else
                    dataValue = "2";
            }

            else if (idCountryResidence != "IT")
            {
                if (idc == DomesticCurrency)
                    dataValue = "3";
                else
                    dataValue = "4";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE ISTITUTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Istituto(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo codice istituto non valorizzato: Controllare il codice banca della controparte";
            string dataValue = RRGetBusinessInfos.GetCodiceBanca();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// NDG CLIENTE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Ndg(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Controllare il codice anagrafico aziendale (NDG) della controparte";
            string dataValue = RRGetBusinessInfos.GetNdg();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SERVIZIO PROVENIENZA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Servprov(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo servizio provenienza non valorizzato: controllare i campi business  in anagrafica della controparte";
            string dataValue = RRGetBusinessInfos.GetServizioProvenienza();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SERVIZIO RAPPORTO 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Servizio(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo servizio rapporto non valorizzato: controllare i campi business in anagrafica della controparte";
            string dataValue = RRGetBusinessInfos.GetServizioRapporto();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// FILIALE RAPPORTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Filiale(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo filiale rapporto non valorizzato: controllare campo business sportello in anagrafica della controparte";
            string dataValue = RRGetBusinessInfos.GetSportello();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// NUMERO RAPPORTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Numrapp(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Controllare il codice anagrafico aziendale (NDG) della controparte";
            string dataValue = RRGetBusinessInfos.GetNumeroRapporto();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA COMPETENZA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Datacomp(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Controllare la data competenza";
            string endDate = DateTime.Parse(Convert.ToString(RRGetBusinessInfos.GetEndDate())).ToString("yyyyMMdd");
            string dataValue = Convert.ToString(endDate);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VOCE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Voce(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "forma tecnica non valorizzata";
            string dataValue = pFormaTecnicaName.Substring(0, 5);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOTTOVOCE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Svoce(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "forma tecnica non valorizzata";
            string dataValue = pFormaTecnicaName.Substring(5, 2);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CATEGORIA SOTTOSISTEMA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_Catsott(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "forma tecnica non valorizzata";
            string dataValue = pFormaTecnicaName.Substring(0, 5) + pFormaTecnicaName.Substring(5, 2);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODDEAL
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_CodDeal(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Identificativo del trade non valorizzato";
            string dataValue = RRGetBusinessInfos.GetTradeIdentifier();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODFRONT
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_CodFront(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo front trade id non valorizzato";
            string dataValue = RRGetBusinessInfos.GetFrontId();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Codice Banca
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_CodiceBanca(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string counterparty = Report.trade.dataDocument.repository.counterparty.identifier;
            string errMessage = "Codice Banca assente. Verificare il codice di direzione generale per l'attore [" + counterparty + "].";
            string dataValue = RRGetBusinessInfos.GetCodiceBanca();
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Voce stralcio
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_VoceStralcio_0001(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Voce stralcio non valorizzata. Verificare la forma tecnica.";
            string dataValue = pFormaTecnicaName;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SottoCodice Conto 0659
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_SottoCodiceConto_0659(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo non valorizzato. Verificare che siano presenti l'identificativo Spheres, l'identificativo del front e l'identificativo del prodotto.";
            string tradeIdentifier = RRGetBusinessInfos.GetTradeIdentifier();

            char pad = '0';
            string frontId = RRGetBusinessInfos.GetFrontId().PadLeft(4, pad);

            // GS 20151021: ticket 21429 - ERRORE PUMA2 - campo SOTTOCODICE_CONTO_659
            // temporary solution: il frammento di stringa contenente il Front Trade Id  troncato a lunghezza 4 
            // questa soluzione risolve il problema legato al frammento di stringa che contiene il Front Trade Id SIDORO (con lunghezza 12). 
            // Sino ad oggi il Front Id utilizzata  quello rilasciato da Kondor (lunghezza 4)
            // =============================================================================
            // GS 20160201: ticket 21183 CT 41
            // Modificata la regola attuale 
            // before: estratti i primi 4 caratteri del "Front Trade Id SIDORO"  
            // after : estratti gli ultimi 4 caratteri del "Front Trade Id SIDORO"  
            // =============================================================================
            int count = 4;
            string sbstrFrontId = frontId.Substring(frontId.Length - count, count);

            string substringProductIdentifier;
            if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pIndex))
                substringProductIdentifier = "z";
            else
                substringProductIdentifier = RRGetBusinessInfos.GetProductIdentifier().Substring(0, 1);

            string index = Convert.ToString(pIndex + 1);
            string dataValue = tradeIdentifier.PadLeft(5, pad) + "_" + sbstrFrontId.PadLeft(4, pad) + "_" + substringProductIdentifier + index.PadLeft(3, pad);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Livello Ulteriore Dettaglio 0583
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_LivelloUlterioreDettaglio_0583(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Campo non valorizzato. Verificare che siano presenti l'identificativo Spheres, l'identificativo del front e l'identificativo del prodotto.";
            string tradeIdentifier = RRGetBusinessInfos.GetTradeIdentifier();
            char pad = '0';
            string frontId = RRGetBusinessInfos.GetFrontId().PadLeft(4, pad);
            // GS 20151021: ticket 21429 - ERRORE PUMA2 - campo SOTTOCODICE_CONTO_659
            // temporary solution: il frammento di stringa contenente il Front Trade Id  troncato a lunghezza 4 
            // questa soluzione risolve il problema legato al frammento di stringa che contiene il Front Trade Id SIDORO (con lunghezza 12). 
            // Sino ad oggi il Front Id utilizzata  quello rilasciato da Kondor (lunghezza 4)
            // =============================================================================
            // GS 20160201: ticket 21183 CT 41
            // Modificata la regola attuale 
            // before: estratti i primi 4 caratteri del "Front Trade Id SIDORO"  
            // after : estratti gli ultimi 4 caratteri del "Front Trade Id SIDORO"  
            // =============================================================================
            int count = 4;
            string sbstrFrontId = frontId.Substring(frontId.Length - count, count);

            string substringProductIdentifier = RRGetBusinessInfos.GetProductIdentifier().Substring(0, 1);

            string index = Convert.ToString(pIndex + 1);
            string dataValue = tradeIdentifier.PadLeft(10, pad) + "_" + sbstrFrontId.PadLeft(4, pad) + "_" + substringProductIdentifier + index.PadLeft(3, pad);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Livello Ulteriore Dettaglio 0646
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public void Calc_LivelloUlterioreDettaglio_0646(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "campo non valorizzato. Verificare il campo business settlementDate (sezione ForwardCashFlow)";
            char pad = '0';
            string settlementDate = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetForwardCashFlowSettlementDate(pIndex), "yyyyMMdd");
            string dataValue = settlementDate.PadLeft(20, pad);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }
    }

    /// <summary>
    /// Swap specific methods to calculate the Puma2 fields   
    /// </summary>
    public class RRDataSwap : RRData
    {
        public RRDataSwap(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRGetBusinessInfos = new RRGetBusinessInfosSwap(pReport);

        }

        /// <summary>
        /// INDICATORE DURATA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00005(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "INDICATORE DURATA";
            string errMessage = "Campo non valorizzato. Verificare la trade date e la data di scadenza del nozionale in vigore";
            TimeSpan dateDifference;
            DateTime tradeDate = RRGetBusinessInfos.GetTradeDate();
            DateTime terminationDate = RRGetBusinessInfos.GetTerminationDate();
            DateTime notionalStepEndDate = RRGetBusinessInfos.GetNotionalStepEndDate(pIndex);

            if (notionalStepEndDate != DateTime.MinValue)
                dateDifference = RRGetBusinessInfos.GetDateDifference(notionalStepEndDate, tradeDate);
            else
                dateDifference = RRGetBusinessInfos.GetDateDifference(terminationDate, tradeDate);

            if (dateDifference.Days <= 365)
                dataValue = Convert.ToString("1");
            if (dateDifference.Days > 365)
                dataValue = Convert.ToString("2");

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA DI SCADENZA DELL'IMPEGNO 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00010(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {

            string dataValue = string.Empty;
            string dataDisplayName = "DATA DI SCADENZA IMPEGNO";
            string errMessage = "Controllare la termination date";

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].settlementDate, "yyyyMMdd");
                    break;
                case "03903.04":
                case "03903.06":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetForwardCashFlowSettlementDate(pIndex), "yyyyMMdd");
                    break;
                default:
                    string productType = RRGetBusinessInfos.GetProductType();
                    bool isAmortizing = RRGetBusinessInfos.GetIsAmortizing();
                    _ = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                    string formattedNextResetDate = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNextResetDate(), "yyyyMMdd");
                    string formattedNotionalStepEndDate = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNotionalStepEndDate(pIndex), "yyyyMMdd");

                    switch (productType)
                    {
                        case "SWAP-FLOATING-FLOATING":
                            if (false == Convert.IsDBNull(formattedNextResetDate))
                                dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNextResetDate(), "yyyyMMdd");
                            else dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                            break;
                        case "SWAP-FIXED-FLOATING":
                            if (isAmortizing == true)
                                if (false == Convert.IsDBNull(formattedNotionalStepEndDate))
                                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNotionalStepEndDate(pIndex), "yyyyMMdd");
                                else dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                            if (isAmortizing == false)
                                dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                            break;
                        default:
                            dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                            break;
                    }
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPO TASSO
        /// 0 = fix (SWAP-FIXED-FIXED, SWAP-ZERO-COUPON, SWAP-FIXED-FLOATING)
        /// 1 = floating (OVERNIGHT, SWAP-FLOATING-FLOATING)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00113(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO TASSO";
            string errMessage = "Campo tipo tasso non valorizzato: verificare il tipo prodotto.";
            bool isOvernight = RRGetBusinessInfos.GetIsOvernight();
            string productType = RRGetBusinessInfos.GetProductType();

            if (isOvernight == true)
                dataValue = "1";
            else
            {
                switch (productType)
                {
                    case ("SWAP-FIXED-FIXED"):
                    case ("SWAP-ZERO-COUPON"):
                    case ("SWAP-FIXED-FLOATING"):
                        dataValue = "0";
                        break;
                    case ("SWAP-FLOATING-FLOATING"):
                        dataValue = "1";
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TASSO RISCHIO MERCATO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00117(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TASSO RISCHIO MERCATO";
            string errMessage = "Tasso rischio mercato non valorizzato: consultare gli streams";
            string productType = RRGetBusinessInfos.GetProductType();
            string receivedStreamRateType = RRGetBusinessInfos.GetReceivedStreamRateType();
            string receivedPeriodRateType = RRGetBusinessInfos.GetReceivedPeriodRateType();
            bool isInterpolateRecFloatRate = RRGetBusinessInfos.GetIsInterpolateRecFloatRate();
            string receivedRateAssetCod = RRGetBusinessInfos.GetReceivedRateAssetCod();
            decimal receivedFixedRate = RRGetBusinessInfos.GetReceivedFixedRate();
            decimal receivedSpread = RRGetBusinessInfos.GetReceivedSpread();
            _ = RRGetBusinessInfos.GetPaidStreamRateType();
            string paidPeriodRateType = RRGetBusinessInfos.GetPaidPeriodRateType();
            bool isInterpolatePayFloatRate = RRGetBusinessInfos.GetIsInterpolatePayFloatRate();
            decimal paidSpread = RRGetBusinessInfos.GetPaidSpread();
            string paidRateAssetCod = RRGetBusinessInfos.GetPaidRateAssetCod();
            decimal paidFixedRate = RRGetBusinessInfos.GetPaidFixedRate();

            switch (productType)
            {
                case "SWAP-ZERO-COUPON":
                case "SWAP-FIXED-FLOATING":
                    if (receivedStreamRateType == "FLO")
                        if (isInterpolateRecFloatRate == true | receivedPeriodRateType == "FIX")
                            dataValue = RRGetBusinessInfos.GetFormattedFixedRate(receivedRateAssetCod, receivedFixedRate);
                        else
                            dataValue = RRGetBusinessInfos.GetFormattedFloatingRate(receivedRateAssetCod, receivedSpread);
                    if (receivedStreamRateType == "FIX" || receivedStreamRateType == "KNA")
                        if (isInterpolatePayFloatRate == true | paidPeriodRateType == "FIX")
                            dataValue = RRGetBusinessInfos.GetFormattedFixedRate(paidRateAssetCod, paidFixedRate);
                        else
                            dataValue = RRGetBusinessInfos.GetFormattedFloatingRate(paidRateAssetCod, paidSpread);
                    break;
                case "SWAP-FLOATING-FLOATING":
                    if (isInterpolateRecFloatRate == true | receivedPeriodRateType == "FIX")
                        dataValue = RRGetBusinessInfos.GetFormattedFixedRate(receivedRateAssetCod, receivedFixedRate);
                    else
                        dataValue = RRGetBusinessInfos.GetFormattedFloatingRate(receivedRateAssetCod, receivedSpread);
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TASSO FISSO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00130(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TASSO FISSO";
            string errMessage = "campo Tasso Fisso non valorizzato: consultare gli streams";
            string productType = RRGetBusinessInfos.GetProductType();
            string receivedStreamRateType = RRGetBusinessInfos.GetReceivedStreamRateType();
            _ = RRGetBusinessInfos.GetReceivedPeriodRateType();
            _ = RRGetBusinessInfos.GetIsInterpolateRecFloatRate();
            string receivedRateAssetCod = RRGetBusinessInfos.GetReceivedRateAssetCod();
            decimal receivedFixedRate = RRGetBusinessInfos.GetReceivedFixedRate();
            _ = RRGetBusinessInfos.GetPaidStreamRateType();
            string paidPeriodRateType = RRGetBusinessInfos.GetPaidPeriodRateType();
            bool isInterpolatePayFloatRate = RRGetBusinessInfos.GetIsInterpolatePayFloatRate();
            string paidRateAssetCod = RRGetBusinessInfos.GetPaidRateAssetCod();
            decimal paidFixedRate = RRGetBusinessInfos.GetPaidFixedRate();
            decimal paidSpread = RRGetBusinessInfos.GetPaidSpread();

            switch (productType)
            {
                case "SWAP-ZERO-COUPON":
                case "SWAP-FIXED-FLOATING":
                    if (receivedStreamRateType == "FIX" || receivedStreamRateType == "KNA")
                        dataValue = RRGetBusinessInfos.GetFormattedFixedRate(receivedRateAssetCod, receivedFixedRate);
                    else
                        dataValue = RRGetBusinessInfos.GetFormattedFixedRate(paidRateAssetCod, paidFixedRate);
                    break;
                case "SWAP-FLOATING-FLOATING":
                    // if paid period rate type is FIX or is an interpolate floating rate it returns formatted fixed rate 
                    if (isInterpolatePayFloatRate == true | paidPeriodRateType == "FIX")
                        dataValue = RRGetBusinessInfos.GetFormattedFixedRate(paidRateAssetCod, paidFixedRate);
                    else
                        dataValue = RRGetBusinessInfos.GetFormattedFloatingRate(paidRateAssetCod, paidSpread);
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA CONTRATTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00143(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA CONTRATTO";
            string errMessage = "Campo non valorizzato.";
            string productType = RRGetBusinessInfos.GetProductType();
            bool isOvernight = RRGetBusinessInfos.GetIsOvernight();

            if (isOvernight == true)
                dataValue = Convert.ToString("25");
            else if (isOvernight != true)
            {
                if (productType == "SWAP-FLOATING-FLOATING")
                    dataValue = Convert.ToString("26");
                if ((productType == "SWAP-ZERO-COUPON") | (productType == "SWAP-FIXED-FLOATING") | (productType == "SWAP-FIXED-FIXED"))
                    dataValue = Convert.ToString("21");
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPO CONTRATTO RISCHI MERCATO
        /// 02 = altri contratto (overnight)
        /// 00 = fisso/fisso - variabile/variabile - fisso/variabile - zero coupon
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00370(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO CONTRATTO RISCHI MERCATO";
            string errMessage = "campo non valorizzato.";
            bool isOvernight = RRGetBusinessInfos.GetIsOvernight();
            string productType = RRGetBusinessInfos.GetProductType();

            if (isOvernight == true)
                dataValue = Convert.ToString("02");
            else
            {
                switch (productType)
                {
                    case ("SWAP-FIXED-FIXED"):
                    case ("SWAP-FLOATING-FLOATING"):
                    case ("SWAP-ZERO-COUPON"):
                    case ("SWAP-FIXED-FLOATING"):
                        dataValue = "00";
                        break;
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// RAPPORTI OGGETTO DI COPERTURA
        /// From Puma2 documentation:
        /// Valorizzato solo se il rapporto  di copertura
        /// 1 = titoli di debito e tassi di interesse
        /// 2 = titoli di capitale
        /// 3 = tassi di cambio e oro
        /// 4 = altri rapporti
        /// per contratti di negoziazione questo campo non  da valorizzare
        /// BIM use static value (0)
        /// Bancaperta use static value (*)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "RAPPORTI OGGETTO DI COPERTURA";
            string IasCategory = RRGetBusinessInfos.GetIasCategory();
            string errMessage = string.Empty;

            if (IasCategory != String.Empty)
            {
                switch (IasCategory)
                {
                    // If the trade is different to Hedging (copertura)this field is out of the scope
                    case "DERIVATIVE":
                        dataValue = "*"; // out of the scope character 
                        break;
                    case "HEDGING":
                        dataValue = "1"; // 1 = titoli di debito e tassi di interesse
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00378(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO";
            string errMessage;

            // for fix leg of Zero Coupon it is the end of export period
            if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex))
            {
                dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetEndDate(), "yyyyMMdd");
                errMessage = "Data revisione contratto non calcolata. Verificare la data di fine del periodo di esportazione.";
            }
            else
            {
                // for IRS basis swap (FLOAT/FLOAT) it is the next reset date
                if (false == Convert.IsDBNull(RRGetBusinessInfos.GetNextResetDate()))
                {
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNextResetDate(), "yyyyMMdd");
                    errMessage = "Data revisione tasso indicizzato non calcolata. verificare la prima data di revisione del tasso indicizzato.";
                }
                // for IRS plain vanilla (FIXED/FIXED or FIXED/FLOAT) it is the trade termination date
                else
                {
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                    errMessage = "Data revisione tasso indicizzato non calcolata. Verificare la data di fine del trade.";
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pNominalSchedulesIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pNominalSchedulesIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "VALORE NOMINALE IN EURO";
            string errMessage;

            if (RRGetBusinessInfos.GetNotionalAmountIdc(pNominalSchedulesIndex) != DomesticCurrency)
            {
                errMessage = "Campo non valorizzato. Verificare il campo business couterValueAmount nella sezione notionalSchedule" + pNominalSchedulesIndex;
                dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountCounterValue(pNominalSchedulesIndex));
            }
            else
            {
                if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex) == true)
                {
                    errMessage = "Campo non valorizzato. Verificare gli interessi maturati nello stream zero coupon. ";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetZeroCouponStreamAccruedInterestValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione notionalSchedule" + pNominalSchedulesIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue(pNominalSchedulesIndex));
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ESPOSIZIONE FUTURA
        /// fonte circolare 155 (ISTRUZIONI PER LA COMPILAZIONE DELLE SEGNALAZIONI SUL PATRIMONIO DI VIGILANZA E SUI COEFFICIENTI PRUDENZIALI)
        /// paragrafo "3.1.3.2. Metodo del valore corrente", ai fini del calcolo dell'esposizione creditizia futura  indicato che:
        /// L'esposizione creditizia futura non va calcolata per i basis swaps in una sola valuta, cio per quei contratti che 
        /// prevedono lo scambio di due tassi d'interesse diversamente indicizzati. 
        /// Non va altres calcolata nel caso di contratti su tassi di cambio di vendita a termine di una valuta stipulati 
        /// dalla banca segnalante con un cliente che intende coprire dal rischio di cambio un debito in valuta contratto 
        /// con la stessa banca segnalante. 
        /// GS 20140610:
        /// ticket 19989 (PUMA2 mancata valorizzazione ESPOSIZIONE_FUTURA_1175)[BANCAPERTA]
        /// in ambito Basilea 3, le disposizioni della Circolare n. 155 cessano di essere valide 
        /// (essendo sostituita dalla Circolare n. 286) e quindi l'eccezione al calcolo dell'esposizione futura 
        /// prevista da tale Circolare per i basis swap non  pi in vigore;
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00667(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "ESPOSIZIONE FUTURA";
            string errMessage = "Esposizione creditizia futura non calcolata. Verificare il Valore nominale in euro e il coefficiente moltiplicativo nel nozionale [" + pIndex + "]";
            string productType = RRGetBusinessInfos.GetProductType();
            bool isOvernight = RRGetBusinessInfos.GetIsOvernight();

            string dataValue;
            if (productType == "SWAP-ZERO-COUPON" | productType == "SWAP-FIXED-FLOATING" | productType == "SWAP-FLOATING-FLOATING" | productType == "SWAP-FIXED-FIXED" | isOvernight == true)
                dataValue = Convert.ToString(RRGetBusinessInfos.GetEsposizioneFutura(pIndex, DomesticCurrency));
            else 
                dataValue = Convert.ToString(0.00M);

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00696(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Math.Abs(Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(pIndex)));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());

                if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex))
                    dataValue = "*";
                else
                {
                    if (nettedMTM < 0)
                        dataValue = Convert.ToString(intrinsicValue);
                    else if (nettedMTM > 0)
                        dataValue = "*";
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00697(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO POSITIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(pIndex));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());

                if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex))
                    dataValue = Convert.ToString(0.01M);
                else
                {
                    if (nettedMTM > 0)
                        dataValue = Convert.ToString(intrinsicValue);
                    else if (nettedMTM < 0)
                        dataValue = "*";
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOMMA VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO";
            string errMessage = string.Empty;
            string idc;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;

                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        // GS FI 20110812: 
                        // to do define decimal in invariant culture (modifier tous les decimal)
                        // to do before into RRBusiness methods
                        //dataValue =  StrFunc.FmtDecimalToInvariantCulture(Math.Abs(Report.trade.dataDocument.business.paidReceivedCashFlows.grossCashFlows[pIndex].amount)); 
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    }
                    break;
                case "01593.88":
                case "01593.89":
                    idc = RRGetBusinessInfos.GetNotionalAmountIdc(pIndex);

                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione NotionalAmount" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetNotionalAmountCounterValue(pIndex)));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione NotionalAmount" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetNotionalAmountValue(pIndex)));
                    }
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00709(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "VALORE NOMINALE IN VALUTA";
            string errMessage;

            if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex) == true)
            {
                errMessage = "Campo non valorizzato. Verificare gli interessi maturati nello stream zero coupon. ";
                dataValue = Convert.ToString(RRGetBusinessInfos.GetZeroCouponStreamAccruedInterestValue());
            }
            else
            {
                errMessage = "Campo non valorizzato. Verificare il campo business amount nella sezione NotionalAmount" + pIndex;
                dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue(pIndex));

            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERZIALE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00799(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERENZIALE";
            string errMessage = "Campo non valorizzato. Consultare il campo business amount";

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    break;
                case "01593.88":
                case "01593.89":
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].amount));
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06696(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal absIntrinsicValue = Math.Abs(Convert.ToDecimal(RRGetBusinessInfos.GetIASIntrinsicValue(pIndex)));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());
                decimal nettedAccruedInterest = Convert.ToDecimal(RRGetBusinessInfos.GetNettingAccruedInterest());

                if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex))
                    dataValue = "*";
                else
                {
                    if ((nettedMTM + nettedAccruedInterest) < 0)
                        dataValue = Convert.ToString(absIntrinsicValue);
                    else if ((nettedMTM + nettedAccruedInterest) > 0)
                        dataValue = "*";
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06697(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO POSITIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal absIntrinsicValue = Math.Abs(Convert.ToDecimal(RRGetBusinessInfos.GetIASIntrinsicValue(pIndex)));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());
                decimal nettedAccruedInterest = Convert.ToDecimal(RRGetBusinessInfos.GetNettingAccruedInterest());

                if (RRGetBusinessInfos.IsZeroCouponElementaryTrade(pFormaTecnicaIndex))
                    dataValue = Convert.ToString(0.01M);
                else
                {
                    if ((nettedMTM + nettedAccruedInterest) > 0)
                        dataValue = Convert.ToString(absIntrinsicValue);
                    else if ((nettedMTM + nettedAccruedInterest) < 0)
                        dataValue = "*";
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ACQUIRENTE VENDITORE (OASI)
        /// Floating/floating swap no zero coupon (static value 2)
        /// Fixed/floating swap no zero coupon: the counterparty pays the fixed rate (value 1)
        /// Fixed/floating swap no zero coupon: the bank pays the fixed rate (value 2)
        /// Zero coupon: the counterparty pays the fixed rate (value 1)
        /// Zero coupon: the bank pays the fixed rate (value 2)
        /// Cap: the Bank is Seller (value 1) - the Bank is Buyer (value 2)
        /// Floor: the Bank is Seller (value 2) - the Bank is Buyer (value 1)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_AcquirenteVenditore_0567(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Campo non valorizzato. Consultare il campo business productType";
            string productType = RRGetBusinessInfos.GetProductType();
            string payerStreamRateType = RRGetBusinessInfos.GetPaidStreamRateType();

            switch (productType)
            {
                case ("SWAP-FLOATING-FLOATING"):
                    dataValue = "2";
                    break;
                case ("SWAP-ZERO-COUPON"):
                case ("SWAP-FIXED-FLOATING"):
                    if (payerStreamRateType == "FIX" || payerStreamRateType == "KNA")
                        dataValue = "2";
                    else dataValue = "1";
                    break;
                case ("SWAP-FIXED-FIXED"):
                    dataValue = "0";
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }
    }

    /// <summary>
    /// CapFloor specific methods to calculate the Puma2 fields   
    /// </summary>
    public class RRDataCap : RRData
    {
        public RRDataCap(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRGetBusinessInfos = new RRGetBusinessInfosCap(pReport);
        }

        /// <summary>
        /// INDICATORE DURATA 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00005(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "INDICATORE DURATA";
            string errMessage = "Campo non valorizzato. Verificare la trade date e la data di scadenza del nozionale in vigore.";

            switch (pFormaTecnicaName)
            {
                case "01593.98":
                case "01593.99":
                    dataValue = Convert.ToString("3");
                    break;
                default:
                    TimeSpan dateDifference;
                    DateTime tradeDate = RRGetBusinessInfos.GetTradeDate();
                    DateTime terminationDate = RRGetBusinessInfos.GetTerminationDate();
                    DateTime notionalStepEndDate = RRGetBusinessInfos.GetNotionalStepEndDate(pIndex);

                    if (notionalStepEndDate != DateTime.MinValue)
                        dateDifference = RRGetBusinessInfos.GetDateDifference(notionalStepEndDate, tradeDate);
                    else
                        dateDifference = RRGetBusinessInfos.GetDateDifference(terminationDate, tradeDate);

                    if (dateDifference.Days <= 365)
                        dataValue = Convert.ToString("1");
                    if (dateDifference.Days > 365)
                        dataValue = Convert.ToString("2");
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA DI SCADENZA DELL'IMPEGNO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00010(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "DATA DI SCADENZA IMPEGNO";
            string errMessage = "Verificare la termination date";

            switch (pFormaTecnicaName)
            {
                case "01593.98":
                case "01593.99":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetCapLetFloorLetStepEndDate(pIndex), "yyyyMMdd");
                    break;
                case "58195.02":
                case "58195.06":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].settlementDate, "yyyyMMdd");
                    break;
                case "03903.04":
                case "03903.06":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetForwardCashFlowSettlementDate(pIndex), "yyyyMMdd");
                    break;
                default:
                    bool isAmortizing = RRGetBusinessInfos.GetIsAmortizing();
                    _ = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                    string formattedNotionalStepEndDate = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNotionalStepEndDate(pIndex), "yyyyMMdd");

                    if (isAmortizing == true)
                        if (false == Convert.IsDBNull(formattedNotionalStepEndDate))
                            dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNotionalStepEndDate(pIndex), "yyyyMMdd");
                        else dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                    if (isAmortizing == false)
                        dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPO TASSO
        /// 0 = fix (SWAP-FIXED-FIXED,SWAP-ZERO-COUPON,SWAP-FIXED-FLOATING)
        /// 1 = floating (OVERNIGHT,SWAP-FLOATING-FLOATING)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00113(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "TIPO TASSO";
            string errMessage = "campo non valorizzato.";
            string dataValue = "1";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TASSO RISCHIO MERCATO (TASSO INDICIZZATO)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00117(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "TASSO RISCHIO MERCATO";
            string errMessage = "Campo non valorizzato.";
            string floatRateAssetCode = RRGetBusinessInfos.GetFloatRateAssetCod();
            decimal spread = RRGetBusinessInfos.GetSpread();
            string dataValue = RRGetBusinessInfos.GetFormattedFloatingRate(floatRateAssetCode, spread);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TASSO FISSO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00130(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "TASSO FISSO";
            string errMessage = "campo tasso fisso non valorizzato. Consultare gli streams";
            string code = "F";
            decimal strike = RRGetBusinessInfos.GetStrike();
            string dataValue = RRGetBusinessInfos.GetFormattedFixedRate(code, strike);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA CONTRATTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00143(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA CONTRATTO";
            string errMessage = "Campo non valorizzato.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();

            if (mainActorBuyerSeller == "Buyer")
                dataValue = Convert.ToString("23");
            if (mainActorBuyerSeller == "Seller")
                dataValue = Convert.ToString("24");

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPO CONTRATTO RISCHI MERCATO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00370(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "TIPO CONTRATTO RISCHI MERCATO";
            string errMessage = "campo non valorizzato.";
            bool isOvernight = RRGetBusinessInfos.GetIsOvernight();

            string dataValue;
            if (isOvernight == true)
                dataValue = Convert.ToString("02");
            else
                dataValue = "01";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// RAPPORTI OGGETTO DI COPERTURA
        /// From Puma2 documentation:
        /// Valorizzato solo se il rapporto  di copertura
        /// 1 = titoli di debito e tassi di interesse
        /// 2 = titoli di capitale
        /// 3 = tassi di cambio e oro
        /// 4 = altri rapporti
        /// per contratti di negoziazione questo campo non  da valorizzare
        /// BIM use static value (0)
        /// Bancaperta use static value (*)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "RAPPORTI OGGETTO DI COPERTURA";
            string IasCategory = RRGetBusinessInfos.GetIasCategory();
            string errMessage = string.Empty;

            if (IasCategory != String.Empty)
            {
                switch (IasCategory)
                {
                    // If the trade is different to Hedging (copertura)this field is out of the scope
                    case "DERIVATIVE":
                        dataValue = "*"; // out of the scope character 
                        break;
                    case "HEDGING":
                        dataValue = "1"; // 1 = titoli di debito e tassi di interesse
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00378(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO";
            string errMessage;

            string dataValue;
            switch (pFormaTecnicaName)
            {
                // for caplet/floorlet it is the caplet/floorlet begin date
                case "01593.98":
                case "01593.99":
                    dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetCapLetFloorLetStepBeginDate(pIndex), "yyyyMMdd");
                    errMessage = "Data revisione contratto non calcolata. Verificare la data di inizio del caplet/floorlet [" + pIndex + "]";
                    break;
                default:

                    // Get the next reset date
                    if (false == Convert.IsDBNull(RRGetBusinessInfos.GetNextResetDate()))
                    {
                        dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetNextResetDate(), "yyyyMMdd");
                        errMessage = "Data revisione tasso indicizzato non calcolata. verificare la prima data di revisione del tasso indicizzato.";
                    }
                    // for the last calculation period is the trade termination date
                    else
                    {
                        dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                        errMessage = "Data revisione tasso indicizzato non calcolata. Verificare la data di fine del trade.";
                    }
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE NOMINALE IN EURO";
            string errMessage;
            string dataValue;
            // Caplet/Floorlet
            if ((pFormaTecnicaName == "01593.98") | (pFormaTecnicaName == "01593.99"))
            {
                if (RRGetBusinessInfos.GetCapLetFloorLetNotionalAmountIdc(pIndex) != DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business couterValueAmount nella sezione CapLetFloorLet" + pIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetCapLetFloorLetNotionalAmountCouterValue(pIndex));
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione CapLetFloorLet" + pIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetCapLetFloorLetNotionalAmountValue(pIndex));
                }
            }

            // Capfloor
            else
            {
                if (RRGetBusinessInfos.GetNotionalAmountIdc(pIndex) != DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business couterValueAmount nella sezione notionalSchedule" + pIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountCounterValue(pIndex));
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione notionalSchedule" + pIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue(pIndex));
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ESPOSIZIONE FUTURA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00667(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "ESPOSIZIONE FUTURA";
            string errMessage = "Esposizione creditizia futura non calcolata. Verificare il Valore nominale in euro e il coefficiente moltiplicativo nel nozionale [" + pIndex + "]";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetEsposizioneFutura(pIndex, DomesticCurrency));
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Math.Abs(Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(pIndex)));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());
                if (nettedMTM < 0)
                    dataValue = Convert.ToString(intrinsicValue);
                else if (nettedMTM > 0)
                    dataValue = "*";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO POSITIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if ((pFormaTecnicaName == "01593.98") | (pFormaTecnicaName == "01593.99"))
            {
                decimal positiveIntrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetCapLetFloorLetPositiveInstinsicValue(pIndex));
                dataValue = Convert.ToString(positiveIntrinsicValue);
            }
            else
            {
                if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
                {
                    decimal intrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(pIndex));
                    decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());
                    if (nettedMTM > 0)
                        dataValue = Convert.ToString(intrinsicValue);
                    else if (nettedMTM < 0)
                        dataValue = "*";
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOMMA VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO";
            string errMessage = string.Empty;
            string idc;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    }
                    break;
                case "01593.88":
                case "01593.89":
                    idc = RRGetBusinessInfos.GetNotionalAmountIdc(pIndex);
                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione NotionalAmount" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetNotionalAmountCounterValue(pIndex)));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione NotionalAmount" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetNotionalAmountValue(pIndex)));
                    }
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal iasIntrinsicValue = Math.Abs(Convert.ToDecimal(RRGetBusinessInfos.GetIASIntrinsicValue(pIndex)));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());
                decimal nettedAccruedInterest = Convert.ToDecimal(RRGetBusinessInfos.GetNettingAccruedInterest());
                if ((nettedMTM + nettedAccruedInterest) < 0)
                    dataValue = Convert.ToString(iasIntrinsicValue);
                else if ((nettedMTM + nettedAccruedInterest) > 0)
                    dataValue = "*";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO POSITIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal iasIntrinsicValue = Math.Abs(Convert.ToDecimal(RRGetBusinessInfos.GetIASIntrinsicValue(pIndex)));
                decimal nettedMTM = Convert.ToDecimal(RRGetBusinessInfos.GetNettingMarkToMarket());
                decimal nettedAccruedInterest = Convert.ToDecimal(RRGetBusinessInfos.GetNettingAccruedInterest());
                if ((nettedMTM + nettedAccruedInterest) > 0)
                    dataValue = Convert.ToString(iasIntrinsicValue);
                else if ((nettedMTM + nettedAccruedInterest) < 0)
                    dataValue = "*";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00709(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE NOMINALE IN VALUTA";
            string errMessage;
            string dataValue;
            switch (pFormaTecnicaName)
            {
                case "01593.98":
                case "01593.99":
                    errMessage = "Campo non valorizzato. Verificare il campo business amount nella sezione CapLetFloorLet" + pIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetCapLetFloorLetNotionalAmountValue(pIndex));
                    break;
                default:
                    errMessage = "Campo non valorizzato. Verificare il campo business amount nella sezione NotionalAmount" + pIndex;
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue(pIndex));
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFEREZIALE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00799(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERENZIALE";
            string errMessage = "Campo non valorizzato. Consultare il campo business amount";

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    break;
                case "01593.88":
                case "01593.89":
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].amount));
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE CORRENTE STRUMENTO FINANZIARIO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00520(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE CORRENTE STRUMENTO FINANZIARIO";
            string errMessage = "FraValue non valorizzato. Eseguire il trattamento MTM di fine mese.";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetCapLetFloorLetFraValue(pIndex));
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SEGNO VALORE CORRENTE STRUMENTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Sign_00520(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "SEGNO VALORE CORRENTE STRUMENTO";
            string errMessage = "FraValue non valorizzato. Eseguire il trattamento MTM di fine mese.";
            string dataValue = RRGetBusinessInfos.GetCapLetFloorLetFraValueSign(pIndex);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DELTA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00299(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DELTA OPZIONI";
            string errMessage = "Delta Opzioni non valorizzato. Eseguire il trattamento MTM di fine mese.";

            decimal delta;
            if ((pFormaTecnicaName == "01593.98") | (pFormaTecnicaName == "01593.99"))
                delta = RRGetBusinessInfos.GetCapLetFloorLetDelta(pIndex);
            else
                delta = RRGetBusinessInfos.GetDelta();

            string dataValue = Convert.ToString(delta);

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;

        }

        /// <summary>
        /// FATTORE GAMMA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00526(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "FATTORE GAMMA";
            string errMessage = "Fattore Gamma non valorizzato. Eseguire il trattamento MTM di fine mese.";

            decimal gamma;
            if ((pFormaTecnicaName == "01593.98") | (pFormaTecnicaName == "01593.99"))
                gamma = RRGetBusinessInfos.GetCapLetFloorLetGamma(pIndex);
            else
                gamma = RRGetBusinessInfos.GetGamma();

            string dataValue = Convert.ToString(gamma);

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// FATTORE VEGA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00527(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "FATTORE VEGA";
            string errMessage = "Fattore Vega non valorizzato. Eseguire il trattamento MTM di fine mese.";

            decimal vega;
            if ((pFormaTecnicaName == "01593.98") | (pFormaTecnicaName == "01593.99"))
                vega = RRGetBusinessInfos.GetCapLetFloorLetVega(pIndex);
            else
                vega = RRGetBusinessInfos.GetVega();

            string dataValue = Convert.ToString(vega);

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VOLATILITA IMPLICITA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00528(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VOLATILITA IMPLICITA";
            string errMessage = "Volatilita Implicita non valorizzata. Eseguire il trattamento MTM di fine mese.";
            decimal implicitVolatility;

            if ((pFormaTecnicaName == "01593.98") | (pFormaTecnicaName == "01593.99"))
                implicitVolatility = RRGetBusinessInfos.GetCapLetFloorLetImplicitVolatility(pIndex);
            else
                implicitVolatility = RRGetBusinessInfos.GetImplicitVolatility();

            string dataValue = Convert.ToString(implicitVolatility);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPO OPZIONE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00530(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO OPZIONE";
            string errMessage = "Tipo Opzione non valorizzato. Verificare il tipo prodotto.";
            string productType = RRGetBusinessInfos.GetProductType();

            if (productType == "CAP")
                dataValue = "21";
            if (productType == "FLOOR")
                dataValue = "22";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Valore Intrinseco Negativo IAS (OASI)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_ValoreIntrinsecoNegativoIAS_1907(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(pIndex));
                decimal absIntrinsicValue = Math.Abs(intrinsicValue);

                if ((intrinsicValue) < 0)
                    dataValue = Convert.ToString(absIntrinsicValue);
                else if (intrinsicValue > 0)
                    dataValue = "*";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Valore Intrinseco Positivo IAS (OASI)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_ValoreIntrinsecoPositivoIAS_1908(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(pIndex));
                decimal absIntrinsicValue = Math.Abs(intrinsicValue);

                if (intrinsicValue > 0)
                    dataValue = Convert.ToString(absIntrinsicValue);
                else if (intrinsicValue < 0)
                    dataValue = "*";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ACQUIRENTE VENDITORE 0567 (OASI)
        /// Floating/floating swap no zero coupon (static value 2)
        /// Fixed/floating swap no zero coupon: the counterparty pays the fixed rate (value 1)
        /// Fixed/floating swap no zero coupon: the bank pays the fixed rate (value 2)
        /// Zero coupon: the counterparty pays the fixed rate (value 1)
        /// Zero coupon: the bank pays the fixed rate (value 2)
        /// Cap: the Bank is Seller (value 1) - the Bank is Buyer (value 2)
        /// Floor: the Bank is Seller (value 2) - the Bank is Buyer (value 1)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_AcquirenteVenditore_0567(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Acquirente Venditore non valorizzato. Verificare il tipo prodotto.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            string productType = RRGetBusinessInfos.GetProductType();

            if ((productType == "CAP" & mainActorBuyerSeller == "Seller") | (productType == "FLOOR" & mainActorBuyerSeller == "Buyer"))
                dataValue = "1";
            if ((productType == "CAP" & mainActorBuyerSeller == "Buyer") | (productType == "FLOOR" & mainActorBuyerSeller == "Seller"))
                dataValue = "2";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Unique Code Relationship (OASI) 
        /// Reference field 'SOTTOCODICE_CONTO_0659'
        /// only for caplet or floorlet
        /// it has been inserted into BKI forme tecniche to enrich informations 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_UniqueCodeRelationship(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "SOTTOCODICE CONTO";
            string errMessage = "Sottocodice conto non valorizzato";
            string dataValue = RRGetBusinessInfos.GetCapLetFloorLetUniqueCodeRelationship(pIndex);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Sequence Number (OASI)
        /// Reference field 'LIVELLO ULTERIORE DETTAGLIO 647'
        /// only for caplet or floorlet
        /// it has been inserted into BKI forme tecniche to enrich informations  
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_SequenceNumber(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "LIVELLO ULTERIORE DETTAGLIO";
            string errMessage = "Livello Ulteriore Dettaglio non valorizzato.";
            string dataValue = RRGetBusinessInfos.GetCapLetFloorLetSequenceNumber(pIndex);
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }
    }

    /// <summary>
    /// Bond Option specific methods to calculate the Puma2 fields   
    /// </summary>
    public class RRDataBondOption : RRData
    {
        public RRDataBondOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRGetBusinessInfos = new RRGetBusinessInfosBondOption(pReport);

        }

        /// <summary>
        /// DIGIT DIVISA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00003(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DIGIT DIVISA";
            string errMessage;
            string idc;
            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    errMessage = "Codice divisa del flusso regolato assente.";
                    break;
                case "03903.04":
                case "03903.06":
                    idc = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].idc;
                    errMessage = "Codice divisa del flusso futuro da regolare assente.";
                    break;
                default:
                    idc = RRGetBusinessInfos.GetNotionalAmountIdc();
                    errMessage = "Codice divisa del nozionale assente.";
                    break;
            }
            string dataValue;
            if (idc == DomesticCurrency)
                dataValue = "1";
            else dataValue = "2";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00007(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "CODICE VALUTA";
            string errMessage;
            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    dataValue = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].uicCurrencyCode;
                    errMessage = "Codice divisa del flusso regolato assente.";
                    break;
                case "03903.04":
                case "03903.06":
                    dataValue = Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].uicCurrencyCode;
                    errMessage = "Codice divisa del flusso da regolate assente.";
                    break;
                default:
                    dataValue = RRGetBusinessInfos.GetNotionalAmountUicCode();
                    errMessage = "Codice divisa del nozionale assente.";
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// CODICE TITOLO SOTTOSTANTE
        /// undrlying ISIN CODE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00033(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "CODICE TITOLO SOTTOSTANTE";
            string errMessage = "Proprietary Id del titolo sottostante non disponibile";

            //dataValue = Convert.ToString(RRGetBusinessInfos.GetIsinCode());
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetProprietaryId());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA CONTRATTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00143(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA CONTRATTO";
            string errMessage = "Tipologia contratto non valorizzato. Consultare i campi business 'mainActorBuyerSeller' e 'settlementType'";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            string settlementType = RRGetBusinessInfos.GetSettlementType();

            if (mainActorBuyerSeller == "Buyer")
            {
                if (settlementType == "Physical")
                    dataValue = Convert.ToString("03");
                if (settlementType == "Cash")
                    dataValue = Convert.ToString("23");
            }
            if (mainActorBuyerSeller == "Seller")
            {
                if (settlementType == "Physical")
                    dataValue = Convert.ToString("04");
                if (settlementType == "Cash")
                    dataValue = Convert.ToString("24");
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// RAPPORTI OGGETTO DI COPERTURA
        /// From Puma2 documentation:
        /// Valorizzato solo se il rapporto  di copertura
        /// 1 = titoli di debito e tassi di interesse
        /// 2 = titoli di capitale
        /// 3 = tassi di cambio e oro
        /// 4 = altri rapporti
        /// per contratti di negoziazione questo campo non  da valorizzare
        /// BIM use static value (0)
        /// Bancaperta use static value (*)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "RAPPORTI OGGETTO DI COPERTURA";
            string IasCategory = RRGetBusinessInfos.GetIasCategory();
            string errMessage = string.Empty;

            if (IasCategory != String.Empty)
            {
                switch (IasCategory)
                {
                    // If the trade is different to Hedging (copertura)this field is out of the scope
                    case "DERIVATIVE":
                        dataValue = "*"; // out of the scope character 
                        break;
                    case "HEDGING":
                        dataValue = "2"; // 2 = titoli di capitale
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00378(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "DATA REVISIONE TASSO INDICIZZATO/SCADENZA TASSO FISSO";
            string errMessage = string.Empty;


            // Get the next reset date
            if (false == Convert.IsDBNull(RRGetBusinessInfos.GetTerminationDate()))
            {
                dataValue = RRGetBusinessInfos.GetFormattedDate(RRGetBusinessInfos.GetTerminationDate(), "yyyyMMdd");
                errMessage = "Data revisione tasso indicizzato non calcolata. verificare la prima data di revisione del tasso indicizzato.";
            }


            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA FUTURES OPZIONI 
        /// 3 = OPZIONI SU TITOLI DELLO STATO ITALIANO
        /// 4 = OPZIONI SU TITOLI DI DEBITO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00540(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "TIPOLOGIA FUTURES OPZIONI";
            string errMessage = "Stato dell'Issuer non disponibile.";
            string dataValue = "*";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN EURO
        /// Valore del nozionale controvalorizzato in EUR.
        /// Nel caso di BondOption su BTP (o altri titoli in EUR) il nozionale sar sempre espresso in EUR e dunque i campi 00609 e 00709 coincideranno.
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "VALORE NOMINALE IN EURO";
            string errMessage;


            if (RRGetBusinessInfos.GetNotionalAmountIdc() == DomesticCurrency)
            {
                errMessage = "Nozionale assente.";
                dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue());
            }
            else
            {
                errMessage = "Controvalore del nozionale non disponibile.";
                dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountCounterValue());
            }


            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE DI CONTRATTAZIONE IN EURO
        /// Il campo deve essere valorizzati con il valore nozionale (del titolo sottostante) 
        /// moltiplicato per la quotazione al corso secco del sottostante (Under Price)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00610(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            decimal underlyingPrice = RRGetBusinessInfos.GetUnderlyingPrice();
            decimal optionNotionalAmount = RRGetBusinessInfos.GetOptionNotionalAmount();

            string dataValue = Convert.ToString(optionNotionalAmount * underlyingPrice);
            string dataDisplayName = "VALORE DI CONTRATTAZIONE IN EURO";
            string errMessage = string.Empty;
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN VALUTA
        /// Valore del nozionale espresso nella divisa originale del contratto.
        /// Nel caso di BondOption su BTP (o altri titoli in EUR) il nozionale sar sempre espresso in EUR e dunque i campi 00609 e 00709 coincideranno.
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00709(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE NOMINALE IN VALUTA";
            string errMessage = "Valore nominale in valuta non valorizzato. Nessun ammontare da pagare  presente nel trade.";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue());

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE CORRENTE RISCHI DI MERCATO IN EUR
        /// Il campo deve essere valorizzati con il valore nozionale (del titolo sottostante) 
        /// moltiplicato per la quotazione al corso secco del sottostante (Under Price)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00724(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE CORRENTE RISCHI DI MERCATO IN EUR";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            decimal underlyingPrice = RRGetBusinessInfos.GetUnderlyingPrice();
            decimal optionNotionalAmount = RRGetBusinessInfos.GetOptionNotionalAmount();

            string dataValue = Convert.ToString(optionNotionalAmount * underlyingPrice);

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE DEL FAIR VALUE ATTIVITA' SOTTOSTANTE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
         public override void Calc_06315(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE DEL FAIR VALUE ATTIVITA' SOTTOSTANTE";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal nettingMarkToMarket = RRGetBusinessInfos.GetNettingMarkToMarket();
                // GS 20161115 - ticket 22257
                // only positive market value to be declared 
                // Market value < 0 then set zero value
                if (nettingMarkToMarket > 0)
                    dataValue = Convert.ToString(nettingMarkToMarket);
                else dataValue = Convert.ToString(Decimal.Zero);
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ESPOSIZIONE FUTURA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00667(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "ESPOSIZIONE FUTURA";
            string errMessage = "Esposizione creditizia futura non calcolata. Verificare il Valore nominale in euro e il coefficiente moltiplicativo nel nozionale [" + pIndex + "]";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetEsposizioneFutura(DomesticCurrency));
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            int i = 0;

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(i);

                if (intrinsicValue < 0)
                    dataValue = Convert.ToString(Math.Abs(intrinsicValue));
                else
                    dataValue = "0";
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }


        /// <summary>
        /// VALORE INTRINSECO POSITIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO POSITIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            int i = 0;

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(i);

                if (intrinsicValue >= 0)
                    dataValue = Convert.ToString(Math.Abs(intrinsicValue));
                else
                    dataValue = "0";
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            int i = 0;

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = RRGetBusinessInfos.GetIASIntrinsicValue(i);

                if (intrinsicValue < 0)
                    dataValue = Convert.ToString(Math.Abs(intrinsicValue));
                else
                    dataValue = "0";
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }


        /// <summary>
        /// VALORE INTRINSECO POSITIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE INTRINSECO POSITIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            _ = RRGetBusinessInfos.GetMainActorBuyerSeller();
            int i = 0;

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = RRGetBusinessInfos.GetIASIntrinsicValue(i);

                if (intrinsicValue >= 0)
                    dataValue = Convert.ToString(Math.Abs(intrinsicValue));
                else
                    dataValue = "0";
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Valore Intrinseco Negativo IAS (OASI)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_ValoreIntrinsecoNegativoIAS_1907(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            int i = 0;

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(i));
                decimal absIntrinsicValue = Math.Abs(intrinsicValue);

                if ((intrinsicValue) < 0)
                    dataValue = Convert.ToString(absIntrinsicValue);
                else if (intrinsicValue > 0)
                    dataValue = "0";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Valore Intrinseco Positivo IAS (OASI)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_ValoreIntrinsecoPositivoIAS_1908(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            int i = 0;

            if (Report.trade.dataDocument.business.closingEvents.markToMarket != null)
            {
                decimal intrinsicValue = Convert.ToDecimal(RRGetBusinessInfos.GetIntrinsicValue(i));
                decimal absIntrinsicValue = Math.Abs(intrinsicValue);

                if (intrinsicValue > 0)
                    dataValue = Convert.ToString(absIntrinsicValue);
                else if (intrinsicValue < 0)
                    dataValue = "0";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }



        /// <summary>
        /// DELTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00299(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DELTA OPZIONI";
            string errMessage = "Delta Opzioni non valorizzato.";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetDelta());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// GAMMA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00526(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "GAMMA OPZIONI";
            string errMessage = "Campo non valorizzato. Verificare il campo business gamma nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetGamma());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VEGA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00527(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VEGA OPZIONI";
            string errMessage = "Campo non valorizzato. Verificare il campo business vega nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetVega());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VOLATILITA' IMPLICITA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00528(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VOLATILITA' IMPLICITA";
            string errMessage = "Campo non valorizzato. Verificare il campo business volatilit implicita nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetImplicitVolatility());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        ///  TIPO OPZIONE
        ///  Valorizzato con "02" (European DebtOption)
        ///  Valorizzato con "03" (American DebtOption)
        ///  Valorizzato con "04" (Bermuda DebtOption)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00530(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO OPZIONE";
            string errMessage = " ";
            // European / American / Bermuda
            string exerciseStyle = RRGetBusinessInfos.GetExerciseStyle();

            if (exerciseStyle == "European")
                dataValue = "02";
            if (exerciseStyle == "American")
                dataValue = "03";
            if (exerciseStyle == "Bermuda")
                dataValue = "04";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOMMA VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO";
            string errMessage;
            string idc;

            string dataValue;
            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    }
                    break;
                default:
                    if (RRGetBusinessInfos.GetNotionalAmountIdc() == DomesticCurrency)
                    {
                        errMessage = "Nozionale assente.";
                        dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue());
                    }
                    else
                    {
                        errMessage = "Controvalore del nozionale non disponibile.";
                        dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountCounterValue());
                    }
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERZIALE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00799(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERENZIALE";
            string errMessage;

            string dataValue;
            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    break;
                default:
                    errMessage = "Nozionale assente.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetNotionalAmountValue());
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Codice Residenza Divisa
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_ResidenzaDivisa(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Codice residenza divisa non valorizzato. Verificare che siano presenti il codice di residenza della controparte e il codice idc del flusso da dichiarare. ";
            string idCountryResidence = RRGetBusinessInfos.GetIdCountryResidence();
            string idc;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    break;
                default:
                    idc = RRGetBusinessInfos.GetNotionalAmountIdc();
                    break;
            }

            if (idCountryResidence == "IT")
            {
                if (idc == DomesticCurrency)
                    dataValue = "1";
                else
                    dataValue = "2";
            }

            else if (idCountryResidence != "IT")
            {
                if (idc == DomesticCurrency)
                    dataValue = "3";
                else
                    dataValue = "4";
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ACQUIRENTE VENDITORE 0567 (OASI)
        /// 
        /// acquisto call e vendita put = 1 
        /// vendita call e acquisto put =2
        /// 
        /// Valorizzato con "1" (acquisto)
        ///Bond Option Put venduta (Seller)dal MainActor 
        ///Bond Option Call acquistata (Buyer) dal MainActor   

        ///Valorizzato con "2" (vendita)
        ///Bond Option Put acquistata (Buyer) dal MainActor 
        ///Bond Option Call venduta (Seller) dal MainActor 
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_AcquirenteVenditore_0567(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Acquirente Venditore non valorizzato. Verificare il tipo prodotto.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            string optionType = RRGetBusinessInfos.GetOptionType();

            if ((mainActorBuyerSeller == "Seller" & optionType == "Put") | (mainActorBuyerSeller == "Buyer" & optionType == "Call"))
                dataValue = "1";
            if ((mainActorBuyerSeller == "Buyer" & optionType == "Put") | (mainActorBuyerSeller == "Seller" & optionType == "Call"))
                dataValue = "2";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }
    }

    /// <summary>
    /// FxSimpleOption specific methods to calculate the Puma2 fields   
    /// </summary>
    public class RRDataFxSimpleOption : RRData
    {
        public RRDataFxSimpleOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRGetBusinessInfos = new RRGetBusinessInfosFxSimpleOption(pReport);

        }

        /// <summary>
        /// TIPOLOGIA CONTRATTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00143(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA CONTRATTO";
            string errMessage = "Tipologia contratto non valorizzato. Consultare i campi business 'mainActorBuyerSeller' e 'settlementType'";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            string settlementType = RRGetBusinessInfos.GetSettlementType();

            if (mainActorBuyerSeller == "Buyer")
            {
                if (settlementType == "PHY")
                    dataValue = Convert.ToString("03");
                if (settlementType == "CSH")
                    dataValue = Convert.ToString("23");
            }
            if (mainActorBuyerSeller == "Seller")
            {
                if (settlementType == "PHY")
                    dataValue = Convert.ToString("04");
                if (settlementType == "CSH")
                    dataValue = Convert.ToString("24");
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// RAPPORTI OGGETTO DI COPERTURA
        /// From Puma2 documentation:
        /// Valorizzato solo se il rapporto  di copertura
        /// 1 = titoli di debito e tassi di interesse
        /// 2 = titoli di capitale
        /// 3 = tassi di cambio e oro
        /// 4 = altri rapporti
        /// per contratti di negoziazione questo campo non  da valorizzare
        /// BIM use static value (0)
        /// Bancaperta use static value (*)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "RAPPORTI OGGETTO DI COPERTURA";
            string IasCategory = RRGetBusinessInfos.GetIasCategory();
            string errMessage = string.Empty;

            if (IasCategory != String.Empty)
            {
                switch (IasCategory)
                {
                    // If the trade is different to Hedging (copertura)this field is out of the scope
                    case "DERIVATIVE":
                        dataValue = "*"; // out of the scope character 
                        break;
                    case "HEDGING":
                        dataValue = "3"; // 3 = tassi di cambio e oro
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DELTA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00299(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DELTA OPZIONI";
            string errMessage = "Delta Opzioni non valorizzato.";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetDelta());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE CORRENTE STRUMENTO FINANZIARIO
        /// Remarks: Validation rule requested
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00520(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string settlementType = RRGetBusinessInfos.GetSettlementType();
            bool isCommodityPayCurrency = RRGetBusinessInfos.GetPayCurrencyIsCommodity();
            bool isCommodityRecCurrency = RRGetBusinessInfos.GetRecCurrencyIsCommodity();

            // valorizzato per tutti i contratti con scambio di capitale 
            string dataValue;
            if ((settlementType == "CSH") | (settlementType == "PHY" & (isCommodityPayCurrency | isCommodityRecCurrency)))
                dataValue = Convert.ToString(RRGetBusinessInfos.GetSpotRateEndOfMonth());
            else
                dataValue = "*";

            string dataDisplayName = "VALORE CORRENTE STRUMENTO FINANZIARIO";
            string errMessage = "Campo non valorizzato. Verificare il campo business spotRate nella sezione ClosingEvent";
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// GAMMA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00526(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "GAMMA OPZIONI";
            string errMessage = "Campo non valorizzato. Verificare il campo business gamma nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetGamma());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VEGA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00527(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VEGA OPZIONI";
            string errMessage = "Campo non valorizzato. Verificare il campo business vega nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetVega());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VOLATILITA' IMPLICITA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00528(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VOLATILITA' IMPLICITA";
            string errMessage = "Campo non valorizzato. Verificare il campo business volatilit implicita nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetImplicitVolatility());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        ///  TIPO OPZIONE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00530(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO OPZIONE";
            string errMessage = "Campo TipoOpzione non valorizzato. Verificare il campo business productType";
            string exerciseStyle = RRGetBusinessInfos.GetExerciseStyle();

            if (exerciseStyle == "EUR")
                dataValue = "02";
            if (exerciseStyle == "AME")
                dataValue = "03";
            if (exerciseStyle == "BRM")
                dataValue = "04";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN EURO";
            string errMessage = string.Empty;

            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
                }
            }

            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetRecCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE DI CONTRATTAZIONE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00610(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE DI CONTRATTAZIONE IN EURO";
            string errMessage = string.Empty;

            //Physical with commodity rec amount 
            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Pay amount is EUR 
                if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da pagare  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                //Pay amount is Currency
                else
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da pagare  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
                }
            }

            //Physical with commodity pay amount 
            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Rec amount is EUR 
                if (RRGetBusinessInfos.GetRecCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da ricevere  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                //Rec amount is Currency
                else
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da ricevere  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ESPOSIZIONE FUTURA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00667(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "ESPOSIZIONE FUTURA";
            string errMessage = "Esposizione creditizia futura non calcolata. Verificare il nozionale da ricevere e/o pagare e il coefficiente di durata residua";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            int remainingDurationDays = RRGetBusinessInfos.GetRemainingDurationDays();
            Decimal remainingDurationRatio = RRGetBusinessInfos.GetRemainingDurationRatio();
            string idcRecCurrencyAmount = RRGetBusinessInfos.GetRecCurrencyIdc();
            string idcPayCurrencyAmount = RRGetBusinessInfos.GetPayCurrencyIdc();
            bool isCommodityRecCurrency = RRGetBusinessInfos.GetRecCurrencyIsCommodity();
            bool isCommodityPayCurrency = RRGetBusinessInfos.GetPayCurrencyIsCommodity();

            if (mainActorBuyerSeller == "Buyer")
            {
                if ((pFormaTecnicaName == "01597.01" | pFormaTecnicaName == "01597.05") & (remainingDurationDays > 14))
                {
                    if (idcRecCurrencyAmount != DomesticCurrency)
                    {
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyCounterValue());
                    }
                    else
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyValue());
                }
                if (pFormaTecnicaName == "01597.09" & remainingDurationDays > 14)
                {
                    if (idcPayCurrencyAmount != DomesticCurrency)
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyCounterValue());
                    else
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyValue());
                }
                if (pFormaTecnicaName == "01597.13" | pFormaTecnicaName == "01597.17")
                {
                    if (isCommodityPayCurrency == true)
                    {
                        if (idcRecCurrencyAmount != DomesticCurrency)
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyCounterValue());
                        else
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyValue());
                    }
                    if (isCommodityRecCurrency == true)
                    {
                        if (idcPayCurrencyAmount != DomesticCurrency)
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyCounterValue());
                        else
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyValue());
                    }
                }
            }

            if (mainActorBuyerSeller == "Seller")
            {
                dataValue = Convert.ToString(0.00M);
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        ///  VALORE INTRINSECO NEGATIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            decimal intrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(0);

            string dataValue;
            if (mainActorBuyerSeller == "Seller")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO POSITIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            decimal intrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(0);

            string dataValue;
            if (mainActorBuyerSeller == "Buyer")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOMMA VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO";
            string errMessage = string.Empty;
            string idc;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    }
                    break;
                default:
                    if (RRGetBusinessInfos.GetOptionType() == "Call")
                    {
                        idc = RRGetBusinessInfos.GetCallCurrencyIdc();
                        if (idc != DomesticCurrency)
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Call Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetCallCurrencyCounterValue()));
                        }
                        else
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Call Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetCallCurrencyValue()));
                        }
                    }
                    if (RRGetBusinessInfos.GetOptionType() == "Put")
                    {
                        idc = RRGetBusinessInfos.GetPutCurrencyIdc();
                        if (idc != DomesticCurrency)
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Put Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPutCurrencyCounterValue()));
                        }
                        else
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Put Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPutCurrencyValue()));
                        }
                    }
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERZIALE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00799(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERENZIALE";
            string errMessage = string.Empty;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    break;
                default:
                    if (RRGetBusinessInfos.GetOptionType() == "Call")
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Call Currency";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetCallCurrencyValue()));
                    }
                    if (RRGetBusinessInfos.GetOptionType() == "Put")
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Put Currency";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPutCurrencyValue()));
                    }
                    break;
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00709(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN VALUTA";
            string errMessage = string.Empty;

            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                {
                    errMessage = "Valore nominale in valuta non valorizzato. Nessun ammontare da pagare  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                else
                    dataValue = Convert.ToString(Decimal.Zero);
            }

            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetRecCurrencyIdc() != DomesticCurrency)
                {
                    errMessage = "Valore nominale in valuta non valorizzato. Nessun ammontare da ricevere  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                else
                    dataValue = Convert.ToString(Decimal.Zero);
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE DI CONTRATTAZIONE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00710(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE DI CONTRATTAZIONE IN VALUTA";
            string errMessage = string.Empty;

            //Physical with commodity rec amount 
            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Pay amount is EUR 
                if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                //Pay amount is Currency
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
                }
            }

            //Physical with commodity pay amount 
            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Rec amount is EUR 
                if (RRGetBusinessInfos.GetRecCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                //Rec amount is Currency
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA OPZIONE 
        /// Call 1
        /// Put 2
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_05330(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA OPZIONE";
            string errMessage = "Campo non valorizzato. Verificare il campo business option type.";
            string optionType = RRGetBusinessInfos.GetOptionType();

            if (optionType == "Call")
                dataValue = "1";
            if (optionType == "Put")
                dataValue = "2";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            decimal intrinsicValue = RRGetBusinessInfos.GetIASIntrinsicValue(0);

            string dataValue;
            if (mainActorBuyerSeller == "Seller")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO POSITIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            decimal intrinsicValue = RRGetBusinessInfos.GetIASIntrinsicValue(0);

            string dataValue;
            if (mainActorBuyerSeller == "Buyer")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Acquirente Venditore 0567 (OASI)
        /// for TIT75 (pay currency/rec currency): always 1
        /// for TIT77 (pay EUR/rec currency): 1
        /// for TIT77 (pay currency/rec EUR): 2
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_AcquirenteVenditore_0567(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Campo non valorizzato. Consultare i campi idc della sezione payCurrency e recCurrency";
            string payCurrencyIdc = RRGetBusinessInfos.GetPayCurrencyIdc();
            string recCurrencyIdc = RRGetBusinessInfos.GetRecCurrencyIdc();

            if (payCurrencyIdc != DomesticCurrency & recCurrencyIdc != DomesticCurrency)
                dataValue = "1";

            if (payCurrencyIdc == DomesticCurrency & recCurrencyIdc != DomesticCurrency)
                dataValue = "1";

            if (payCurrencyIdc != DomesticCurrency & recCurrencyIdc == DomesticCurrency)
                dataValue = "2";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }
    }

    /// <summary>
    /// FxBarrierOption specific methods to calculate the Puma2 fields 
    /// </summary>
    public class RRDataFxBarrierOption : RRData
    {
        public RRDataFxBarrierOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRGetBusinessInfos = new RRGetBusinessInfosFxBarrierOption(pReport);

        }

        /// <summary>
        /// TIPOLOGIA CONTRATTO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00143(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA CONTRATTO";
            string errMessage = "Tipologia contratto non valorizzato. Consultare i campi business 'mainActorBuyerSeller' e 'settlementType'";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            string settlementType = RRGetBusinessInfos.GetSettlementType();

            if (mainActorBuyerSeller == "Buyer")
            {
                if (settlementType == "PHY")
                    dataValue = Convert.ToString("03");
                if (settlementType == "CSH")
                    dataValue = Convert.ToString("23");
            }
            if (mainActorBuyerSeller == "Seller")
            {
                if (settlementType == "PHY")
                    dataValue = Convert.ToString("04");
                if (settlementType == "CSH")
                    dataValue = Convert.ToString("24");
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// RAPPORTI OGGETTO DI COPERTURA
        /// From Puma2 documentation:
        /// Valorizzato solo se il rapporto  di copertura
        /// 1 = titoli di debito e tassi di interesse
        /// 2 = titoli di capitale
        /// 3 = tassi di cambio e oro
        /// 4 = altri rapporti
        /// per contratti di negoziazione questo campo non  da valorizzare
        /// BIM use static value (0)
        /// Bancaperta use static value (*)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "RAPPORTI OGGETTO DI COPERTURA";
            string IasCategory = RRGetBusinessInfos.GetIasCategory();
            string errMessage = string.Empty;

            if (IasCategory != String.Empty)
            {
                switch (IasCategory)
                {
                    // If the trade is different to Hedging (copertura)this field is out of the scope
                    case "DERIVATIVE":
                        dataValue = "*"; // out of the scope character 
                        break;
                    case "HEDGING":
                        dataValue = "3"; // 3 = tassi di cambio e oro
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// DELTA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00299(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "DELTA OPZIONI";
            string errMessage = "Delta Opzioni non valorizzato.";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetDelta());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE CORRENTE STRUMENTO FINANZIARIO
        /// Remarks: Validation rule requested
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00520(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE CORRENTE STRUMENTO FINANZIARIO";
            string errMessage = "Campo non valorizzato. Verificare il campo business spotRate nella sezione ClosingEvent";
            string settlementType = RRGetBusinessInfos.GetSettlementType();
            bool isCommodityPayCurrency = RRGetBusinessInfos.GetPayCurrencyIsCommodity();
            bool isCommodityRecCurrency = RRGetBusinessInfos.GetRecCurrencyIsCommodity();
            string dataValue;
            // valorizzato per tutti i contratti con scambio di capitale 
            if ((settlementType == "CSH") | (settlementType == "PHY" & (isCommodityPayCurrency == true | isCommodityRecCurrency == true)))
                dataValue = Convert.ToString(RRGetBusinessInfos.GetSpotRateEndOfMonth());
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// GAMMA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00526(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "GAMMA OPZIONI";
            string errMessage = "Campo non valorizzato. Verificare il campo business gamma nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetGamma());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VEGA OPZIONI
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00527(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VEGA OPZIONI";
            string errMessage = "Campo non valorizzato. Verificare il campo business vega nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetVega());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VOLATILITA' IMPLICITA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00528(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VOLATILITA' IMPLICITA";
            string errMessage = "Campo non valorizzato. Verificare il campo business volatilit implicita nella sezione greeks";
            string dataValue = Convert.ToString(RRGetBusinessInfos.GetImplicitVolatility());
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }


        /// <summary>
        /// Get_OptionType_Internal
        /// for For FxOption with Active Single Barrier
        /// (Knock-In) e (ReverseKnockin): Segnalate come FxSimpleOption
        /// (Knock-out)   e (ReverseKnockout) : non segnalate
        /// </summary>
        /// <param name="pExerciseStyle"></param>
        /// <param name="pValue"></param>
        /// <returns>pValue: FxSimple Code for 00530 field</returns>
        private string Get_OptionType_Internal(string pExerciseStyle, out string pValue)
        {
            switch (pExerciseStyle)
            {
                case "EUR":
                    pValue = "02";
                    break;
                case "AME":
                    pValue = "03";
                    break;
                case "BRM":
                    pValue = "04";
                    break;
                default:
                    pValue = "99";
                    break;
            }

            return pValue;
        }


        /// <summary>
        ///  TIPO OPZIONE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00530(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPO OPZIONE";
            string errMessage = "Campo Tipo Opzione non valorizzato. Verificare le barriere";

            DateTime endDate = Report.trade.header.endDate;
            int count = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier.Length;

            string exerciseStyle = RRGetBusinessInfos.GetExerciseStyle();
            string triggerStatus;
            string barrierType;
            DateTime fixingDate;
            // FxBarrier KI-KO
            // 61: Nessuna Barriera Attiva
            // 23: Con ReverseKnockin attiva alla data di segnalazione, dicharata come una (ReverseKnockout)
            // 24: Con Knock-In attiva alla data di segnalazione, dicharata come una (Knock-out)
            if (count == 2)
            {
                barrierType = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[0].type;
                triggerStatus = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[0].triggerStatus;
                fixingDate = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[0].quotedCurrencyPair.fixingDate;

                string barrierType2 = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[1].type;
                string triggerStatus2 = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[1].triggerStatus;
                DateTime fixingDate2 = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[1].quotedCurrencyPair.fixingDate;

                // 61: Nessuna Barriera Attiva
                if (triggerStatus == "DEACTIV" && triggerStatus2 == "DEACTIV")
                    dataValue = "61";


                // 23: Con ReverseKnockin attiva alla data di segnalazione, dicharata come una (ReverseKnockout)
                // 24: Con Knock-In attiva alla data di segnalazione, dicharata come una (Knock-out)
                if (triggerStatus == "ACTIV" && fixingDate <= endDate)
                {
                    switch (barrierType)
                    {
                        case "KnockIn":
                            dataValue = "24";
                            break;
                        case "ReverseKnockIn":
                            dataValue = "23";
                            break;
                        default:
                            dataValue = "**";
                            break;
                    }
                }

                // 23: Con ReverseKnockin attiva alla data di segnalazione, dicharata come una (ReverseKnockout)
                // 24: Con Knock-In attiva alla data di segnalazione, dicharata come una (Knock-out)
                if (triggerStatus2 == "ACTIV" && fixingDate2 <= endDate)
                {
                    switch (barrierType2)
                    {
                        case "KnockIn":
                            dataValue = "24";
                            break;
                        case "ReverseKnockIn":
                            dataValue = "23";
                            break;
                        default:
                            dataValue = "**";
                            break;
                    }
                }
            }

            // Single FxBarrier
            if (count == 1)
            {
                barrierType = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[0].type;
                triggerStatus = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[0].triggerStatus;
                fixingDate = Report.trade.dataDocument.business.fxBarrierOption.fxBarrier[0].quotedCurrencyPair.fixingDate;


                // Fx Barrier (Barriera Non Attiva)*
                // 21: Barrier Up and In          (Knock-In)         [BAR/UPI]
                // 22: Barrier Down and In     (ReverseKnockin)      [BAR/DWI] 
                // 23: Barrier Up and Out       (ReverseKnockout)    [BAR/UPO] 
                // 24: Barrier Down and Out  (Knock-out)             [BAR/DWO]
                if (triggerStatus == "DEACTIV")
                {
                    switch (barrierType)
                    {
                        case "KnockIn":
                            dataValue = "21";
                            break;
                        case "KnockOut":
                            dataValue = "23";
                            break;
                        case "ReverseKnockIn":
                            dataValue = "22";
                            break;
                        case "ReverseKnockOut":
                            dataValue = "24";
                            break;
                        default:
                            dataValue = "61";
                            break;
                    }
                }

                // Fx Barrier (Barriera Attiva) alla data di segnalazione
                // (Knock-In) e (ReverseKnockin): Segnalate come FxSimpleOption
                // (Knock-out)   e (ReverseKnockout) : non segnalate
                if (triggerStatus == "ACTIV" && fixingDate <= endDate)
                {
                    switch (barrierType)
                    {
                        case "KnockIn":
                        case "ReverseKnockIn":
                            dataValue = Get_OptionType_Internal(exerciseStyle, out string _);
                            break;
                        default:
                            dataValue = "**";
                            break;
                    }
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN EURO";
            string errMessage = string.Empty;

            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
                }
            }

            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetRecCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE DI CONTRATTAZIONE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00610(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE DI CONTRATTAZIONE IN EURO";
            string errMessage = string.Empty;

            //Physical with commodity rec amount 
            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Pay amount is EUR 
                if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da pagare  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                //Pay amount is Currency
                else
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da pagare  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
                }
            }

            //Physical with commodity pay amount 
            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Rec amount is EUR 
                if (RRGetBusinessInfos.GetRecCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da ricevere  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                //Rec amount is Currency
                else
                {
                    errMessage = "Il valore di contrattazione in euro non valorizzato. Nessun ammontare da ricevere  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// ESPOSIZIONE FUTURA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00667(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "ESPOSIZIONE FUTURA";
            string errMessage = "Esposizione creditizia futura non calcolata. Verificare il nozionale da ricevere e/o pagare e il coefficiente di durata residua";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            int remainingDurationDays = RRGetBusinessInfos.GetRemainingDurationDays();
            Decimal remainingDurationRatio = RRGetBusinessInfos.GetRemainingDurationRatio();
            string idcRecCurrencyAmount = RRGetBusinessInfos.GetRecCurrencyIdc();
            string idcPayCurrencyAmount = RRGetBusinessInfos.GetPayCurrencyIdc();
            bool isCommodityRecCurrency = RRGetBusinessInfos.GetRecCurrencyIsCommodity();
            bool isCommodityPayCurrency = RRGetBusinessInfos.GetPayCurrencyIsCommodity();

            if (mainActorBuyerSeller == "Buyer")
            {
                if ((pFormaTecnicaName == "01597.01" | pFormaTecnicaName == "01597.05") & (remainingDurationDays > 14))
                {
                    if (idcRecCurrencyAmount != DomesticCurrency)
                    {
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyCounterValue());
                    }
                    else
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyValue());
                }
                if (pFormaTecnicaName == "01597.09" & remainingDurationDays > 14)
                {
                    if (idcPayCurrencyAmount != DomesticCurrency)
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyCounterValue());
                    else
                        dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyValue());
                }
                if (pFormaTecnicaName == "01597.13" | pFormaTecnicaName == "01597.17")
                {
                    if (isCommodityPayCurrency == true)
                    {
                        if (idcRecCurrencyAmount != DomesticCurrency)
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyCounterValue());
                        else
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetRecCurrencyValue());
                    }
                    if (isCommodityRecCurrency == true)
                    {
                        if (idcPayCurrencyAmount != DomesticCurrency)
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyCounterValue());
                        else
                            dataValue = Convert.ToString(remainingDurationRatio * RRGetBusinessInfos.GetPayCurrencyValue());
                    }
                }
            }

            if (mainActorBuyerSeller == "Seller")
            {
                dataValue = Convert.ToString(0.00M);
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        ///  VALORE INTRINSECO NEGATIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            int i = 0;
            decimal intrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(i);

            string dataValue;
            if (mainActorBuyerSeller == "Seller")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            int i = 0;
            decimal intrinsicValue = RRGetBusinessInfos.GetIntrinsicValue(i);

            string dataValue;
            if (mainActorBuyerSeller == "Buyer")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, "VALORE INTRINSECO POSITIVO", DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOMMA VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO";
            string errMessage = string.Empty;
            string idc;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    }
                    break;
                default:
                    if (RRGetBusinessInfos.GetOptionType() == "Call")
                    {
                        idc = RRGetBusinessInfos.GetCallCurrencyIdc();
                        if (idc != DomesticCurrency)
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Call Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetCallCurrencyCounterValue()));
                        }
                        else
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Call Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetCallCurrencyValue()));
                        }
                    }
                    if (RRGetBusinessInfos.GetOptionType() == "Put")
                    {
                        idc = RRGetBusinessInfos.GetPutCurrencyIdc();
                        if (idc != DomesticCurrency)
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Put Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPutCurrencyCounterValue()));
                        }
                        else
                        {
                            errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Put Currency";
                            dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPutCurrencyValue()));
                        }
                    }
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERZIALE
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00799(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN DIVISA PREMIO MARGINE E DIFFERENZIALE";
            string errMessage = string.Empty;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                    dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    break;
                default:
                    if (RRGetBusinessInfos.GetOptionType() == "Call")
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Call Currency";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetCallCurrencyValue()));
                    }
                    if (RRGetBusinessInfos.GetOptionType() == "Put")
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Put Currency";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPutCurrencyValue()));
                    }
                    break;
                }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00709(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN VALUTA";
            string errMessage = string.Empty;

            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetPayCurrencyIdc() != DomesticCurrency)
                {
                    errMessage = "Valore nominale in valuta non valorizzato. Nessun ammontare da pagare  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                else
                    dataValue = Convert.ToString(Decimal.Zero);
            }

            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "CSH")
            {
                if (RRGetBusinessInfos.GetRecCurrencyIdc() != DomesticCurrency)
                {
                    errMessage = "Valore nominale in valuta non valorizzato. Nessun ammontare da ricevere  presente nel trade.";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                else
                    dataValue = Convert.ToString(Decimal.Zero);
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE DI CONTRATTAZIONE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00710(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE DI CONTRATTAZIONE IN VALUTA";
            string errMessage = string.Empty;

            //Physical with commodity rec amount 
            if (pFormaTecnicaName == "01597.13" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Pay amount is EUR 
                if (RRGetBusinessInfos.GetPayCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyValue());
                }
                //Pay amount is Currency
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione PayCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayCurrencyCounterValue());
                }
            }

            //Physical with commodity pay amount 
            if (pFormaTecnicaName == "01597.17" & RRGetBusinessInfos.GetSettlementType() == "PHY")
            {
                //Rec amount is EUR 
                if (RRGetBusinessInfos.GetRecCurrencyIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyValue());
                }
                //Rec amount is Currency
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione RecCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetRecCurrencyCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// TIPOLOGIA OPZIONE 
        /// Call 1
        /// Put 2
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_05330(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "TIPOLOGIA OPZIONE";
            string errMessage = "Campo non valorizzato. Verificare il campo business option type.";
            string optionType = RRGetBusinessInfos.GetOptionType();

            if (optionType == "Call")
                dataValue = "1";
            if (optionType == "Put")
                dataValue = "2";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE INTRINSECO NEGATIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06696(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO NEGATIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            decimal intrinsicValue = RRGetBusinessInfos.GetIASIntrinsicValue(0);

            string dataValue;
            if (mainActorBuyerSeller == "Seller")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
            }

        /// <summary>
        /// VALORE INTRINSECO POSITIVO BILANCIO IAS
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_06697(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataDisplayName = "VALORE INTRINSECO POSITIVO BILANCIO IAS";
            string errMessage = "Eventi di chiusura contabile assenti alla data di estrazione del Puma2. Eseguire i trattamenti necessari.";
            string mainActorBuyerSeller = RRGetBusinessInfos.GetMainActorBuyerSeller();
            decimal intrinsicValue = RRGetBusinessInfos.GetIASIntrinsicValue(0);

            string dataValue;
            if (mainActorBuyerSeller == "Buyer")
                dataValue = Convert.ToString(Math.Abs(intrinsicValue));
            else
                dataValue = "*";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// Acquirente Venditore 0567 (OASI)
        /// for TIT75 (pay currency/rec currency): always 1
        /// for TIT77 (pay EUR/rec currency): 1
        /// for TIT77 (pay currency/rec EUR): 2
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_AcquirenteVenditore_0567(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string errMessage = "Campo non valorizzato. Consultare i campi idc della sezione payCurrency e recCurrency";
            string payCurrencyIdc = RRGetBusinessInfos.GetPayCurrencyIdc();
            string recCurrencyIdc = RRGetBusinessInfos.GetRecCurrencyIdc();

            if (payCurrencyIdc != DomesticCurrency & recCurrencyIdc != DomesticCurrency)
                dataValue = "1";

            if (payCurrencyIdc == DomesticCurrency & recCurrencyIdc != DomesticCurrency)
                dataValue = "1";

            if (payCurrencyIdc != DomesticCurrency & recCurrencyIdc == DomesticCurrency)
                dataValue = "2";

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, null, null, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }



    }

    /// <summary>
    /// FxDigitalOption specific methods to calculate the Puma2 fields 
    /// </summary>
    public class RRDataFxDigitalOption : RRData
    {
        public RRDataFxDigitalOption(string pDomesticCurrency, RegulatoryReport pReport)
            : base(pDomesticCurrency, pReport)
        {
            RRGetBusinessInfos = new RRGetBusinessInfosFxDigitalOption(pReport);

        }

        /// <summary>
        /// RAPPORTI OGGETTO DI COPERTURA
        /// From Puma2 documentation:
        /// Valorizzato solo se il rapporto  di copertura
        /// 1 = titoli di debito e tassi di interesse
        /// 2 = titoli di capitale
        /// 3 = tassi di cambio e oro
        /// 4 = altri rapporti
        /// per contratti di negoziazione questo campo non  da valorizzare
        /// BIM use static value (0)
        /// Bancaperta use static value (*)
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00375(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "RAPPORTI OGGETTO DI COPERTURA";
            string IasCategory = RRGetBusinessInfos.GetIasCategory();
            string errMessage = string.Empty;

            if (IasCategory != String.Empty)
            {
                switch (IasCategory)
                {
                    // If the trade is different to Hedging (copertura)this field is out of the scope
                    case "DERIVATIVE":
                        dataValue = "*"; // out of the scope character 
                        break;
                    case "HEDGING":
                        dataValue = "3"; // 3 = tassi di cambio e oro
                        break;
                }
            }
            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }


        /// <summary>
        /// VALORE NOMINALE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pFormaTecnicaIndex"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00609(string pFormaTecnicaName, int pFormaTecnicaIndex, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN EURO";
            string errMessage = string.Empty;

            if (pFormaTecnicaName == "01597.13")
            {
                if (RRGetBusinessInfos.GetPayoutIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione PayoutCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayoutValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione PayoutCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayoutCounterValue());
                }
            }

            if (pFormaTecnicaName == "01597.17")
            {
                if (RRGetBusinessInfos.GetIncomeIdc() == DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione IncomeCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetIncomeValue());
                }
                else
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business CounterValueAmount nella sezione IncomeCurrencyAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetIncomeCounterValue());
                }
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// SOMMA VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00699(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue;
            string dataDisplayName = "VALORE NOMINALE CONTRATTI CONTROVALORE IN EURO";
            string errMessage;
            string idc;

            switch (pFormaTecnicaName)
            {
                case "58195.02":
                case "58195.06":
                    idc = Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].idc;
                    if (idc != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].counterValueAmount.value));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Gross PaidReceivedCashFlows" + pIndex + ".";
                        dataValue = Convert.ToString(Math.Abs(Report.trade.dataDocument.business.exchangedCashFlows.grossCashFlows[pIndex].amount));
                    }
                    break;
                default:
                    if (RRGetBusinessInfos.GetPayoutIdc() != DomesticCurrency)
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo CounterValueAmount della sezione Payout Currency";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPayoutCounterValue()));
                    }
                    else
                    {
                        errMessage = "Campo non valorizzato. Consultare il campo Amount della sezione Payout Currency";
                        dataValue = Convert.ToString(Math.Abs(RRGetBusinessInfos.GetPayoutValue()));
                    }
                    break;
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }

        /// <summary>
        /// VALORE NOMINALE IN VALUTA
        /// </summary>
        /// <param name="pFormaTecnicaName"></param>
        /// <param name="pIndex"></param>
        /// <param name="pDataId"></param>
        /// <param name="pReportFormaTecnica"></param>
        /// <param name="pDataIndex"></param>
        public override void Calc_00709(string pFormaTecnicaName, int pIndex, string pDataId, RegulatoryReportReportFormaTecnica pReportFormaTecnica, int pDataIndex)
        {
            string dataValue = string.Empty;
            string dataDisplayName = "VALORE NOMINALE IN VALUTA";
            string errMessage = string.Empty;

            if (pFormaTecnicaName == "01597.13")
            {
                if (RRGetBusinessInfos.GetPayoutIdc() != DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione PayoutAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetPayoutValue());
                }
                else
                    dataValue = Convert.ToString(Decimal.Zero);
            }

            if (pFormaTecnicaName == "01597.17")
            {
                if (RRGetBusinessInfos.GetIncomeIdc() != DomesticCurrency)
                {
                    errMessage = "Campo non valorizzato. Verificare il campo business Amount nella sezione IncomeAmount";
                    dataValue = Convert.ToString(RRGetBusinessInfos.GetIncomeValue());
                }
                else
                    dataValue = Convert.ToString(Decimal.Zero);
            }

            RegulatoryReportReportFormaTecnicaData data = new RegulatoryReportReportFormaTecnicaData(pFormaTecnicaName, pDataIndex, pDataId, dataDisplayName, DataSourceProcess, dataValue, errMessage);
            pReportFormaTecnica.data[pDataIndex] = data;
        }
    }

    /// <summary>
    /// Get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfos
    {
        #region Members
        protected RegulatoryReport m_Report;
        #endregion
        #region Accessors
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        #endregion
        #region Constructor
        public RRGetBusinessInfos(RegulatoryReport pReport)
        {
            Report = pReport;
        }
        #endregion

        virtual public string GetProductType()
        {
            return null;
        }
        virtual public DateTime GetNotionalStepEndDate(int pIndex)
        {
            return DateTime.MinValue;
        }
        virtual public DateTime GetNextResetDate()
        {
            return DateTime.MinValue;
        }
        virtual public DateTime GetCapLetFloorLetStepBeginDate(int pIndex)
        {
            return DateTime.MinValue;
        }
        virtual public DateTime GetCapLetFloorLetStepEndDate(int pIndex)
        {
            return DateTime.MinValue;
        }
        virtual public string GetCapLetFloorLetNotionalAmountIdc(int pIndex)
        {
            return null;
        }
        virtual public decimal GetCapLetFloorLetNotionalAmountValue(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetNotionalAmountCouterValue(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public bool GetIsAmortizing()
        {
            return false;
        }
        virtual public bool GetIsOvernight()
        {
            return false;
        }
        virtual public bool IsZeroCoupon()
        {
            return false;
        }
        virtual public bool IsReceiverZeroCouponStream()
        {
            return false;
        }
        virtual public bool IsPayerZeroCouponStream()
        {
            return false;
        }
        virtual public bool IsZeroCouponElementaryTrade(int pIndex)
        {
            return false;
        }
        virtual public decimal GetZeroCouponStreamAccruedInterestValue()
        {
            return Decimal.MinusOne;
        }
        virtual public string GetReceivedRateType()
        {
            return null;
        }
        virtual public string GetReceivedStreamRateType()
        {
            return null;
        }
        virtual public string GetPaidStreamRateType()
        {
            return null;
        }
        virtual public string GetNotionalAmountIdc()
        {
            return null;
        }
        virtual public string GetNotionalAmountIdc(int pIndex)
        {
            return null;
        }
        virtual public string GetNotionalAmountUicCode()
        {
            return null;
        }
        virtual public string GetNotionalAmountUicCode(int pIndex)
        {
            return null;
        }
        virtual public decimal GetNotionalAmountValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetNotionalAmountValue(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetNotionalAmountCounterValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetNotionalAmountCounterValue(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public int GetRemainingDurationDays()
        {
            return 0;
        }
        virtual public decimal GetRemainingDurationRatio(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetRemainingDurationRatio()
        {
            return Decimal.MinusOne;
        }
        virtual public bool GetIsInterpolateRecFloatRate()
        {
            return false;
        }
        virtual public bool GetIsInterpolatePayFloatRate()
        {
            return false;

        }
        virtual public string GetReceivedRateAssetCod()
        {
            return null;

        }
        virtual public string GetPaidRateAssetCod()
        {
            return null;
        }
        virtual public decimal GetReceivedFixedRate()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetPaidFixedRate()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetReceivedSpread()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetPaidSpread()
        {
            return Decimal.MinusOne;
        }
        virtual public string GetPaidPeriodRateType()
        {
            return null;
        }
        virtual public string GetReceivedPeriodRateType()
        {
            return null;
        }
        virtual public string GetFloatRateAssetCod()
        {
            return null;
        }
        virtual public decimal GetSpread()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetStrike()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetPositiveInstinsicValue(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetDelta(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetGamma(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetImplicitVolatility(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetVega(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCapLetFloorLetFraValue(int pIndex)
        {
            return Decimal.MinusOne;
        }
        virtual public string GetCapLetFloorLetFraValueSign(int pIndex)
        {
            return null;
        }
        virtual public string GetCapLetFloorLetUniqueCodeRelationship(int pIndex)
        {
            return null;
        }
        virtual public string GetCapLetFloorLetSequenceNumber(int pIndex)
        {
            return null;
        }
        virtual public string GetOptionType()
        {
            return string.Empty;
        }
        virtual public string GetSettlementType()
        {
            return String.Empty;
        }
        virtual public string GetExerciseStyle()
        {
            return String.Empty;
        }
        virtual public string GetPayCurrencyUicCode()
        {
            return String.Empty;
        }
        virtual public string GetRecCurrencyUicCode()
        {
            return String.Empty;
        }
        virtual public string GetPayCurrencyIdc()
        {
            return String.Empty;
        }
        virtual public string GetRecCurrencyIdc()
        {
            return String.Empty;
        }
        virtual public decimal GetPayCurrencyValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetRecCurrencyValue()
        {
            return Decimal.MinusOne;
        }
        //virtual public decimal GetSpotRateEndOfMonth()
        //{
        //    return Decimal.MinusOne;
        //}
        virtual public bool GetPayCurrencyIsCommodity()
        {
            return false;
        }
        virtual public bool GetRecCurrencyIsCommodity()
        {
            return false;
        }
        virtual public string GetPayCommodityExtraInfoCode0183()
        {
            return string.Empty;
        }
        virtual public string GetRecCommodityExtraInfoCode0183()
        {
            return string.Empty;
        }
        virtual public string GetPayCommodityExtraInfoCode0525()
        {
            return string.Empty;
        }
        virtual public string GetRecCommodityExtraInfoCode0525()
        {
            return string.Empty;
        }
        virtual public decimal GetRecCurrencyCounterValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetPayCurrencyCounterValue()
        {
            return Decimal.MinusOne;
        }
        virtual public string GetCallCurrencyIdc()
        {
            return string.Empty;
        }
        virtual public decimal GetCallCurrencyValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetCallCurrencyCounterValue()
        {
            return Decimal.MinusOne;
        }
        virtual public string GetPutCurrencyIdc()
        {
            return string.Empty;
        }
        virtual public decimal GetPutCurrencyValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetPutCurrencyCounterValue()
        {
            return Decimal.MinusOne;
        }
        virtual public string GetPayoutIdc()
        {
            return string.Empty;
        }
        virtual public decimal GetPayoutValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetPayoutCounterValue()
        {
            return Decimal.MinusOne;
        }
        virtual public string GetIncomeIdc()
        {
            return string.Empty;
        }
        virtual public decimal GetIncomeValue()
        {
            return Decimal.MinusOne;
        }
        virtual public decimal GetIncomeCounterValue()
        {
            return Decimal.MinusOne;
        }

        virtual public decimal GetEsposizioneFutura(string pDomesticCurrency)
        {
            return Decimal.MinusOne;
        }

        virtual public decimal GetClosingPrice()
        {
            return Decimal.MinusOne;
        }

        virtual public string GetIssuerCountry()
        {
            return string.Empty;
        }

        virtual public string GetIsinCode()
        {
            return string.Empty;
        }

        virtual public string GetProprietaryId()
        {
            return string.Empty;
        }

        virtual public decimal GetUnderlyingPrice()
        {
            return Decimal.MinusOne;
        }

        virtual public decimal GetOptionNotionalAmount()
        {
            return Decimal.MinusOne;
        }

        virtual public decimal GetAccruedInterestRate()
        {
            return Decimal.MinusOne;
        }


        /// <summary>
        /// Date Difference
        /// </summary>
        /// <param name="pHigherDate">max date</param>
        /// <param name="pLowerDate">min date</param>
        /// <returns>Days difference between two dates</returns>
        public TimeSpan GetDateDifference(DateTime pHigherDate, DateTime pLowerDate)
        {
            return pHigherDate.Subtract(pLowerDate);
        }

        /// <summary>
        /// Formatted Date
        /// </summary>
        /// <param name="pDate"></param>
        /// <param name="pFormatType">eg. YYYYMMDD</param>
        /// <returns>Formatted date</returns>
        public string GetFormattedDate(DateTime pDate, string pFormatType)
        {
            DateTime DateParsed = DateTime.Parse(Convert.ToString(pDate));
            return DateParsed.ToString(pFormatType);
        }

        /// <summary>
        /// Formatted Fixed Rate
        /// </summary>
        /// <param name="pAssetCode"></param>
        /// <param name="pFixedRate"></param>
        /// <returns></returns>
        public string GetFormattedFixedRate(string pAssetCode, decimal pFixedRate)
        {
            char pad = '0';
            string numberWithOutPoint = String.Format("{0:0.000}", pFixedRate).Replace(".", string.Empty);
            string ret = pAssetCode + numberWithOutPoint.PadLeft(14, pad);
            return ret;
        }

        /// <summary>
        /// Formatted Floating Rate
        /// </summary>
        /// <param name="pFloatRateAssetCode"></param>
        /// <param name="pSpread"></param>
        /// <returns></returns>
        public string GetFormattedFloatingRate(string pFloatRateAssetCode, decimal pSpread)
        {
            char pad = '0';

            string sign;
            if (pSpread >= 0)
                sign = "+";
            else
                sign = "-";

            decimal formatSpread = Math.Abs(pSpread);

            string numberWithOutPoint = String.Format("{0:0.000}", formatSpread).Replace(".", string.Empty);
            return pFloatRateAssetCode + sign + numberWithOutPoint.PadLeft(5, pad);
        }

        /// <summary>
        /// IsOpenAndClosed
        /// </summary>
        /// <returns>true for Open&Closed trade</returns>
        public bool GetIsOpenAndClosed()
        {
            return Convert.ToBoolean(Report.trade.header.isOpenAndClosed);
        }

        /// <summary>
        /// IsOpen
        /// </summary>
        /// <returns>true for Open trade</returns>
        public bool GetIsOpen()
        {
            return Convert.ToBoolean(Report.trade.header.isOpen);
        }

        /// <summary>
        /// Product Family
        /// </summary>
        /// <returns>product family</returns>
        public string GetProductFamily()
        {
            return Convert.ToString(Report.trade.header.productFamily);
        }

        /// <summary>
        /// Product Identifier
        /// </summary>
        /// <returns>product identifier</returns>
        public string GetProductIdentifier()
        {
            return Convert.ToString(Report.trade.header.productIdentifier);
        }

        /// <summary>
        /// MainActor Buyer Seller
        /// buyer or seller of the trade
        /// </summary>
        /// <returns>buyer seller</returns>
        public string GetMainActorBuyerSeller()
        {
            return Report.trade.dataDocument.repository.mainActor.buyerSeller;
        }

        /// <summary>
        /// Trade Identifier
        /// </summary>
        /// <returns> trade identifier </returns>
        public string GetTradeIdentifier()
        {
            return Report.trade.header.identifier;
        }

        /// <summary>
        /// FrontId
        /// </summary>
        /// <returns> front trade id </returns>
        public string GetFrontId()
        {
            return Report.trade.header.frontId;
        }

        /// <summary>
        /// Counterparty Identifier
        /// </summary>
        /// <returns> Counterparty identifier </returns>
        public string GetCounterpartyIdentifier()
        {
            return Report.trade.dataDocument.repository.counterparty.identifier;
        }

        /// <summary>
        /// Country Residence Id
        /// </summary>
        /// <returns>  </returns>
        public string GetIdCountryResidence()
        {
            return Report.trade.dataDocument.repository.counterparty.idCountryResidence;
        }

        /// <summary>
        /// Uic Country Code
        /// </summary>
        /// <returns> the uic country code (eg. ITALY = 086) </returns>
        public string GetUicCountryCode()
        {
            return Report.trade.dataDocument.repository.counterparty.uicCountryCode;
        }

        /// <summary>
        /// Economic Area Code
        /// </summary>
        /// <returns> economic area code </returns>
        public string GetEconomicAreaCode()
        {
            return Convert.ToString(Report.trade.dataDocument.repository.counterparty.economicAreaCode);
        }

        /// <summary>
        /// Is CounterParty Client
        /// </summary>
        /// <returns> True if counterparty is a client </returns>
        public bool GetIsCounterPartyClient()
        {
            return Report.trade.dataDocument.repository.counterparty.isClient; ;
        }

        /// <summary>
        /// End Date
        /// </summary>
        /// <returns> end date </returns>
        public DateTime GetEndDate()
        {
            return Report.trade.header.endDate;
        }

        /// <summary>
        /// Export Date
        /// </summary>
        /// <returns> traitement date </returns>
        public DateTime GetExportDate()
        {
            return Report.trade.header.sysDate;
        }

        /// <summary>
        /// Trade Date
        /// </summary>
        /// <returns> trade date </returns>
        public DateTime GetTradeDate()
        {
            return Report.trade.header.tradeDate;
        }

        /// <summary>
        /// Termination Date
        /// </summary>
        /// <returns> termination date </returns>
        public DateTime GetTerminationDate()
        {
            return Report.trade.header.terminationDate;
        }

        /// <summary>
        /// Forward CashFlow Settlement Date
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public DateTime GetForwardCashFlowSettlementDate(int pIndex)
        {
            return Report.trade.dataDocument.business.forwardCashFlows.grossCashFlows[pIndex].settlementDate;
        }

        /// <summary>
        /// Codice Banca
        /// </summary>
        /// <returns>codice banca</returns>
        public string GetCodiceBanca()
        {
            return Report.trade.dataDocument.repository.counterparty.codiceBanca;
        }

        /// <summary>
        /// Servizio Provenienza
        /// </summary>
        /// <returns>servizio provenienza</returns>
        public string GetServizioProvenienza()
        {
            return Report.trade.dataDocument.repository.counterparty.servizioProvenienza;
        }

        /// <summary>
        /// NDG
        /// </summary>
        /// <returns>numero di direzione generale</returns>
        public string GetNdg()
        {
            return Report.trade.dataDocument.repository.counterparty.numeroDirezioneGenerale;
        }

        /// <summary>
        /// Servizio Rapporto
        /// </summary>
        /// <returns>servizio rapporto</returns>
        public string GetServizioRapporto()
        {
            return Report.trade.dataDocument.repository.counterparty.servizioRapporto;
        }

        /// <summary>
        /// Sportello
        /// </summary>
        /// <returns>sportello</returns>
        public string GetSportello()
        {
            return Report.trade.dataDocument.repository.counterparty.sportello;
        }

        /// <summary>
        /// Numero Rapporto
        /// </summary>
        /// <returns>sportello</returns>
        public string GetNumeroRapporto()
        {
            return Report.trade.dataDocument.repository.counterparty.numeroRapporto;
        }

        /// <summary>
        /// Codice Aziendale
        /// </summary>
        /// <returns>codice aziendale</returns>
        public string GetCodiceAziendale()
        {
            return Report.trade.dataDocument.repository.counterparty.codiceAziendale;
        }

        /// <summary>
        /// Numero Conto Rapporto
        /// </summary>
        /// <returns>numero conto rapporto</returns>
        public string GetNumeroContoRapporto()
        {
            return Report.trade.dataDocument.repository.counterparty.numeroContoRapporto;
        }

        /// <summary>
        /// Ias Derivative Classification
        /// </summary>
        /// <returns></returns>
        public string GetIasDerivativeClassification()
        {
            return Report.trade.dataDocument.repository.mainActor.iasDerivativeClassification;
        }

        /// <summary>
        /// Ias Category
        /// </summary>
        /// <returns></returns>
        public string GetIasCategory()
        {
            return Report.trade.dataDocument.repository.mainActor.iasCategory;
        }


        /// <summary>
        /// Ias Hedged Derivative Classification
        /// </summary>
        /// <returns></returns>
        public string GetIasHedgedDerivativeClassification()
        {
            return Report.trade.dataDocument.repository.mainActor.iasHedgedDerivativeClassification;
        }

        /// <summary>
        /// Esposizione Futura
        /// </summary>
        /// <param name="pIndex"></param>
        /// <param name="pDomesticCurrency"></param>
        /// <returns></returns>
        public decimal GetEsposizioneFutura(int pIndex, string pDomesticCurrency)
        {
            string idc = GetNotionalAmountIdc(pIndex);

            if (idc != pDomesticCurrency)
                return Math.Abs(GetNotionalAmountCounterValue(pIndex) * GetRemainingDurationRatio(pIndex));
            else
                return Math.Abs(GetNotionalAmountValue(pIndex) * GetRemainingDurationRatio(pIndex));
        }

        /// <summary>
        /// Mifid Client Categorisation
        /// </summary>
        /// <returns></returns>
        public string GetMifidClientCategorisation()
        {
            return Report.trade.dataDocument.repository.counterparty.mifidClientCategorisation;
        }

        /// <summary>
        /// Intrinsic Value
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public decimal GetIntrinsicValue(int pIndex)
        {
            if (null != Report.trade.dataDocument.business.closingEvents.intrinsicValues)
                return Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[pIndex].amount;
            else return Decimal.Zero;
        }

        /// <summary>
        /// IAS Intrinsic Value
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public decimal GetIASIntrinsicValue(int pIndex)
        {
            if (null != Report.trade.dataDocument.business.closingEvents.intrinsicValues)
                return Report.trade.dataDocument.business.closingEvents.intrinsicValues.schedule[pIndex].amountIAS;
            else return Decimal.Zero;
        }

        /// <summary>
        /// Netting Accrued Interest
        /// </summary>
        /// <returns></returns>
        public decimal GetNettingAccruedInterest()
        {
            if (null != Report.trade.dataDocument.business.closingEvents.accruedInterest)
                return Report.trade.dataDocument.business.closingEvents.accruedInterest.nettedAmount;
            else return Decimal.Zero;
        }

        /// <summary>
        /// Netting MarkToMarket
        /// </summary>
        /// <returns></returns>
        public decimal GetNettingMarkToMarket()
        {
            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                return Report.trade.dataDocument.business.closingEvents.markToMarket.nettedAmount;
            else return Decimal.Zero;
        }

        /// <summary>
        /// Delta
        /// </summary>
        /// <returns></returns>
        public decimal GetDelta()
        {
            if (null != Report.trade.dataDocument.business.closingEvents.greeks)
                return Report.trade.dataDocument.business.closingEvents.greeks.delta;
            else return Decimal.MinusOne;
        }

        /// <summary>
        /// Gamma
        /// </summary>
        /// <returns></returns>
        public decimal GetGamma()
        {
            if (null != Report.trade.dataDocument.business.closingEvents.greeks)
                return Report.trade.dataDocument.business.closingEvents.greeks.gamma;
            else return Decimal.MinusOne;
        }

        /// <summary>
        /// Implicit Volatility
        /// </summary>
        /// <returns></returns>
        public decimal GetImplicitVolatility()
        {
            if (null != Report.trade.dataDocument.business.closingEvents.greeks)
                return Report.trade.dataDocument.business.closingEvents.greeks.implicitVolatility;
            else return Decimal.MinusOne;
        }

        /// <summary>
        /// Vega
        /// </summary>
        /// <returns></returns>
        public decimal GetVega()
        {
            if (null != Report.trade.dataDocument.business.closingEvents.greeks)
                return Report.trade.dataDocument.business.closingEvents.greeks.vega;
            else return Decimal.MinusOne;
        }

        /// <summary>
        /// Gerarchia Fair Value
        /// 0=Valutazione non al Fair Value
        /// 1=Quotazione su mercato attivo
        /// 2=Valutazione basata su altri dati di mercato
        /// 3=Valutazione non basata su dati di mercato
        /// </summary>
        /// <returns>fair Value Hierarchy</returns>
        public string GetFairValueHierarchy()
        {
            return Convert.ToString(Report.trade.header.fairValueHierarchy);
        }

        /// <summary>
        /// ExistsCSA
        /// </summary>
        /// <returns></returns>
        public bool ExistsCSA()
        {
            if (null != Report.trade.dataDocument.repository.masterAgreement.creditSupportAgreementIdentifier)
                return true;
            else return false;
        }


        /// <summary>
        /// Spot Rate End-of-month
        /// </summary>
        /// <returns></returns>
        public decimal GetSpotRateEndOfMonth()
        {
            return Report.trade.dataDocument.business.closingEvents.spotRate;
        }


    }

    /// <summary>
    /// Swap specific methods to get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfosSwap : RRGetBusinessInfos
    {
        public RRGetBusinessInfosSwap(RegulatoryReport pReport)
            : base(pReport)
        {
        }

        /// <summary>
        /// Product Type
        /// </summary>
        /// <returns></returns>
        public override string GetProductType()
        {
            return Convert.ToString(Report.trade.dataDocument.business.swap.productType);
        }

        /// <summary>
        /// Notional Step End Date
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override DateTime GetNotionalStepEndDate(int pIndex)
        {
            return Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].stepEndDate; ;
        }

        /// <summary>
        /// Next Reset Date
        /// </summary>
        /// <returns></returns>
        public override DateTime GetNextResetDate()
        {
            return Report.trade.dataDocument.business.swap.nextResetDate;
        }

        /// <summary>
        /// Is Amortizing
        /// </summary>
        /// <returns></returns>
        public override bool GetIsAmortizing()
        {
            return Report.trade.dataDocument.business.swap.isAmortizing;
        }

        /// <summary>
        /// Is Overnight
        /// </summary>
        /// <returns>True if is an OIS</returns>
        public override bool GetIsOvernight()
        {
            return Report.trade.dataDocument.business.swap.isOvernight;
        }

        /// <summary>
        /// Is Zero Coupon
        /// </summary>
        /// <returns></returns>
        public override bool IsZeroCoupon()
        {
            if (GetProductType() == "SWAP-ZERO-COUPON")
                return true;
            else
                return false;
        }

        /// <summary>
        /// Is Receiver Zero Coupon Stream
        /// </summary>
        /// <returns></returns>
        public override bool IsReceiverZeroCouponStream()
        {
            if (IsZeroCoupon() == true && GetReceivedStreamRateType() == "KNA")
                return true;
            else
                return false;
        }

        /// <summary>
        /// Is Payer Zero Coupon Stream
        /// </summary>
        /// <returns></returns>
        public override bool IsPayerZeroCouponStream()
        {
            if (IsZeroCoupon() == true && GetPaidStreamRateType() == "KNA")
                return true;
            else
                return false;
        }

        /// <summary>
        /// Is ZeroCoupon Elementary Trade
        /// second elementary stream in factorization is a zero coupon elementary stream 
        /// </summary>
        /// <param name="pIndex">index of forma tecnica (RegulatoryReportReportFormaTecnica)</param>
        /// <returns></returns>
        public override bool IsZeroCouponElementaryTrade(int pFormaTecnicaIndex)
        {
            if (GetProductType() == "SWAP-ZERO-COUPON" && pFormaTecnicaIndex == 1)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Receiver ZeroCoupon-Stream Accrued Interest Value
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetZeroCouponStreamAccruedInterestValue()
        {
            if (IsReceiverZeroCouponStream() == true)
                return Report.trade.dataDocument.business.swap.receiverStream.accruedInterest;
            else
                return Report.trade.dataDocument.business.swap.payerStream.accruedInterest;
        }

        /// <summary>
        /// Received Stream Rate Type
        /// </summary>
        /// <returns></returns>
        public override string GetReceivedStreamRateType()
        {
            return Report.trade.dataDocument.business.swap.receiverStream.streamRateType;
        }

        /// <summary>
        /// Paid Stream Rate Type
        /// </summary>
        /// <returns></returns>
        public override string GetPaidStreamRateType()
        {
            return Report.trade.dataDocument.business.swap.payerStream.streamRateType;
        }

        /// <summary>
        /// Received Rate Type
        /// </summary>
        /// <returns> Irs received rate type (eg. FIX)</returns>
        public override string GetReceivedRateType()
        {
            return Convert.ToString(Report.trade.dataDocument.business.swap.receiverStream.streamRateType);
        }

        /// <summary>
        /// Notional Idc
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetNotionalAmountIdc(int pIndex)
        {
            return Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].idc;
        }

        /// <summary>
        /// Notional Uic Currency Code
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetNotionalAmountUicCode(int pIndex)
        {
            return Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].uicCurrencyCode;
        }

        /// <summary>
        /// Notional Amount 
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetNotionalAmountValue(int pIndex)
        {
            return Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].amount;
        }

        /// <summary>
        /// Notional Coutervalue 
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetNotionalAmountCounterValue(int pIndex)
        {
            return Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].counterValueAmount.value;
        }

        /// <summary>
        /// Remaining Duration Ratio
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetRemainingDurationRatio(int pIndex)
        {
            return Report.trade.dataDocument.business.swap.nominal.notionalSchedule[pIndex].remainingDurationRatio;
        }

        /// <summary>
        /// Is Interpolate Rec Float Rate
        /// </summary>
        /// <returns></returns>
        public override bool GetIsInterpolateRecFloatRate()
        {
            return Report.trade.dataDocument.business.swap.receiverStream.isInterpolateFloatRate;
        }

        /// <summary>
        /// Paid Period Rate Type
        /// </summary>
        /// <returns></returns>
        public override bool GetIsInterpolatePayFloatRate()
        {
            return Report.trade.dataDocument.business.swap.payerStream.isInterpolateFloatRate;
        }

        /// <summary>
        /// Received Rate Asset Code
        /// </summary>
        /// <returns></returns>
        public override string GetReceivedRateAssetCod()
        {
            return Report.trade.dataDocument.business.swap.receiverStream.assetCode;
        }

        /// <summary>
        /// Paid Rate Asset Code
        /// </summary>
        /// <returns></returns>
        public override string GetPaidRateAssetCod()
        {
            return Report.trade.dataDocument.business.swap.payerStream.assetCode;
        }

        /// <summary>
        /// Received Fixed Rate
        /// </summary>
        /// <returns></returns>
        public override decimal GetReceivedFixedRate()
        {
            return Report.trade.dataDocument.business.swap.receiverStream.fixedRate;
        }

        /// <summary>
        /// Paid Fixed Rate
        /// </summary>
        /// <returns></returns>
        public override decimal GetPaidFixedRate()
        {
            return Report.trade.dataDocument.business.swap.payerStream.fixedRate;
        }

        /// <summary>
        /// Received Spread
        /// </summary>
        /// <returns></returns>
        public override decimal GetReceivedSpread()
        {
            return Report.trade.dataDocument.business.swap.receiverStream.spread;
        }

        /// <summary>
        /// Paid Spread
        /// </summary>
        /// <returns></returns>
        public override decimal GetPaidSpread()
        {
            return Report.trade.dataDocument.business.swap.payerStream.spread;
        }

        /// <summary>
        /// Paid Period Rate Type
        /// </summary>
        /// <returns></returns>
        public override string GetPaidPeriodRateType()
        {
            return Report.trade.dataDocument.business.swap.payerStream.periodRateType;
        }

        /// <summary>
        /// Received Period Rate Type
        /// </summary>
        /// <returns></returns>
        public override string GetReceivedPeriodRateType()
        {
            return Report.trade.dataDocument.business.swap.receiverStream.periodRateType;
        }
    }

    /// <summary>
    /// CapFloor specific methods to get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfosCap : RRGetBusinessInfos
    {
        public RRGetBusinessInfosCap(RegulatoryReport pReport)
            : base(pReport)
        {
        }

        /// <summary>
        /// Product Type
        /// </summary>
        /// <returns></returns>
        public override string GetProductType()
        {
            return Convert.ToString(Report.trade.dataDocument.business.capFloor.productType);
        }

        /// <summary>
        /// Notional Step End Date
        /// </summary>
        /// <returns> notional step end date </returns>
        public override DateTime GetNotionalStepEndDate(int pIndex)
        {
            return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].stepEndDate;
        }

        /// <summary>
        /// Next Reset Date
        /// </summary>
        /// <returns></returns>
        public override DateTime GetNextResetDate()
        {
            return Report.trade.dataDocument.business.capFloor.nextResetDate;
        }

        /// <summary>
        /// Caplet Floorlet Step Begin Date
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override DateTime GetCapLetFloorLetStepBeginDate(int pIndex)
        {
            return (Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].stepBeginDate);
        }

        /// <summary>
        /// Caplet Floorlet Step End Date
        /// returns step end date - 1day
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override DateTime GetCapLetFloorLetStepEndDate(int pIndex)
        {
            return (Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].stepEndDate.AddDays(-1));
        }

        /// <summary>
        /// Caplet Floorlet Notional Amount Idc
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetCapLetFloorLetNotionalAmountIdc(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].idc;
        }

        /// <summary>
        /// Caplet Floorlet Notional Amount
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetNotionalAmountValue(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].notionalAmount;
        }

        /// <summary>
        /// Caplet Floorlet Notional Amount Coutervalue
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetNotionalAmountCouterValue(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].counterValueAmount.value;
        }

        /// <summary>
        /// Caplet Floorlet Positive Instinsic Value
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetPositiveInstinsicValue(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].positiveMTM;
        }

        /// <summary>
        /// Caplet Floorlet Delta
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetDelta(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].delta;
        }

        /// <summary>
        /// Caplet Floorlet Gamma
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetGamma(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].gamma;
        }

        /// <summary>
        /// Caplet Floorlet Implicit Volatility
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetImplicitVolatility(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].implicitVolatility;
        }

        /// <summary>
        /// Caplet Floorlet Vega
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetVega(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].vega;
        }

        /// <summary>
        /// Caplet Floorlet Fra Value
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetCapLetFloorLetFraValue(int pIndex)
        {
            return Math.Abs(Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].fraValue);
        }

        /// <summary>
        /// Caplet Floorlet Fra Value Sign
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetCapLetFloorLetFraValueSign(int pIndex)
        {
            decimal fraValue = Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].fraValue;
            if (fraValue >= 0)
                return "+";
            else
                return "-";
        }

        /// <summary>
        /// Caplet Floorlet Unique Code Relationship
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetCapLetFloorLetUniqueCodeRelationship(int pIndex)
        {
            return Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].uniqueCodeRelationship;
        }

        /// <summary>
        /// Caplet Floorlet Sequence Number
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetCapLetFloorLetSequenceNumber(int pIndex)
        {
            char pad = '0';
            string sequenceNumber = Convert.ToString(Report.trade.dataDocument.business.closingEvents.capLetsFloorLets.schedule[pIndex].sequenceNumber).PadLeft(3, pad);
            return sequenceNumber;
        }

        /// <summary>
        /// Is Amortizing
        /// </summary>
        /// <returns>True if is an amortizing notional</returns>
        public override bool GetIsAmortizing()
        {
            return Report.trade.dataDocument.business.capFloor.isAmortizing;
        }

        /// <summary>
        /// Is Overnight
        /// </summary>
        /// <returns>True if is an OIS</returns>
        public override bool GetIsOvernight()
        {
            return Report.trade.dataDocument.business.capFloor.isOvernight;
        }

        /// <summary>
        /// Notional Idc
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetNotionalAmountIdc(int pIndex)
        {
            return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].idc;
        }

        /// <summary>
        /// Notional Uic Currency Code
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetNotionalAmountUicCode(int pIndex)
        {
            return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].uicCurrencyCode;
        }

        /// <summary>
        /// Notional Amount
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetNotionalAmountValue(int pIndex)
        {
            return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].amount;
        }

        /// <summary>
        /// Coutervalue Notional Amount
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetNotionalAmountCounterValue(int pIndex)
        {
            return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].counterValueAmount.value;
        }

        /// <summary>
        /// Remaining Duration Ratio
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetRemainingDurationRatio(int pIndex)
        {
            return Report.trade.dataDocument.business.capFloor.nominal.notionalSchedule[pIndex].remainingDurationRatio;
        }

        /// <summary>
        /// Float Rate Asset Code
        /// </summary>
        /// <returns></returns>
        public override string GetFloatRateAssetCod()
        {
            return Report.trade.dataDocument.business.capFloor.capFloorStream.assetCode;
        }

        /// <summary>
        /// Spread
        /// </summary>
        /// <returns></returns>
        public override decimal GetSpread()
        {
            return Report.trade.dataDocument.business.capFloor.capFloorStream.spread;
        }

        /// <summary>
        /// Strike
        /// </summary>
        /// <returns></returns>
        public override decimal GetStrike()
        {
            return Report.trade.dataDocument.business.capFloor.capFloorStream.strike;
        }
    }

    /// <summary>
    /// BondOption specific methods to get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfosBondOption : RRGetBusinessInfos
    {
        public RRGetBusinessInfosBondOption(RegulatoryReport pReport)
            : base(pReport)
        {
        }


        /// <summary>
        /// Closing Price from MTM events
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetClosingPrice()
        {

            if (null != Report.trade.dataDocument.business.closingEvents.markToMarket)
                return Report.trade.dataDocument.business.closingEvents.markToMarket.closingPrice;
            else return Decimal.Zero;
        }


        /// <summary>
        /// Option Type
        /// </summary>
        /// <returns> Call or Put </returns>
        public override string GetOptionType()
        {
            return Report.trade.dataDocument.business.bondOption.optionType;
        }



        public override string GetNotionalAmountIdc()
        {
            return Report.trade.dataDocument.business.bondOption.notionalAmount.idc;
        }


        /// <summary>
        /// Notional Uic Currency Code
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override string GetNotionalAmountUicCode()
        {
            return Report.trade.dataDocument.business.bondOption.notionalAmount.uicCurrencyCode;
        }

        /// <summary>
        /// Notional Amount
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetNotionalAmountValue()
        {
            return Report.trade.dataDocument.business.bondOption.notionalAmount.amount;
        }


        /// <summary>
        /// Notional amount Countervalue
        /// </summary>
        /// <returns></returns>
        public override decimal GetNotionalAmountCounterValue()
        {
            return Report.trade.dataDocument.business.bondOption.notionalAmount.counterValueAmount.value;
        }


        /// <summary>
        /// Settlement Type
        /// </summary>
        /// <returns> Phisical or cash settlement </returns>
        public override string GetSettlementType()
        {
            return Report.trade.dataDocument.business.bondOption.settlementType;
        }

        /// <summary>
        /// Exercise Style
        /// </summary>
        /// <returns>returns the type of exercise (AME - BRM - EUR) </returns>
        public override string GetExerciseStyle()
        {
            return Report.trade.dataDocument.business.bondOption.exerciseStyle;
        }

        /// <summary>
        /// Remaining Duration Ratio
        /// </summary>
        /// <param name="pIndex"></param>
        /// <returns></returns>
        public override decimal GetRemainingDurationRatio()
        {
            return Report.trade.dataDocument.business.bondOption.remainingDurationRatio;
        }

        /// <summary>
        /// Esposizione Futura
        /// </summary>
        /// <param name="pIndex"></param>
        /// <param name="pDomesticCurrency"></param>
        /// <returns></returns>
        public override decimal GetEsposizioneFutura(string pDomesticCurrency)
        {
            string idc = GetNotionalAmountIdc();

            if (idc != pDomesticCurrency)
                return Math.Abs(GetNotionalAmountCounterValue() * GetRemainingDurationRatio());
            else
                return Math.Abs(GetNotionalAmountValue() * GetRemainingDurationRatio());
        }

        /// <summary>
        /// Issuer Country
        /// </summary>
        /// <returns>returns the country of issuer </returns>
        public override string GetIssuerCountry()
        {
            return Report.trade.dataDocument.business.bondOption.bond.issuerCountry;
        }

        /// <summary>
        /// ISIN CODE
        /// </summary>
        /// <returns>Underlying ISIN Code</returns>
        public override string GetIsinCode()
        {
            return Report.trade.dataDocument.business.bondOption.bond.ISIN;
        }

        /// <summary>
        /// Proprietary ID
        /// </summary>
        /// <returns>Underlying Proprietary Id</returns>
        public override string GetProprietaryId()
        {
            return Report.trade.dataDocument.business.bondOption.bond.proprietaryId;
        }

        /// <summary>
        /// Underlying Price
        /// quotazione al corso secco del sottostante 
        /// </summary>
        /// <returns>Prezzo Attuale del titolo sottostante</returns>
        public override decimal GetUnderlyingPrice()
        {
            return Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.underlyingPrice;
        }

        /// <summary>
        /// Notional Amount
        /// </summary>
        /// <returns>Valore Nozionale dell'opzione</returns>
        public override decimal GetOptionNotionalAmount()
        {
            return Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.optionNotionalAmount;
        }

        /// <summary>
        /// Accrued Interest Rate
        /// </summary>
        /// <returns>Rateo cedolare del titolo sottostante espresso in percentuale</returns>
        public override decimal GetAccruedInterestRate()
        {
            return Report.trade.dataDocument.business.closingEvents.bondUnderlyingQuotation.accruedInterestRate;
        }
    }

    /// <summary>
    /// FxSimpleOption specific methods to get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfosFxSimpleOption : RRGetBusinessInfos
    {
        public RRGetBusinessInfosFxSimpleOption(RegulatoryReport pReport)
            : base(pReport)
        {
        }

        /// <summary>
        /// Option Type
        /// </summary>
        /// <returns> Call or Put </returns>
        public override string GetOptionType()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.optionType;
        }

        /// <summary>
        /// Settlement Type
        /// </summary>
        /// <returns> Phisical or cash settlement </returns>
        public override string GetSettlementType()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.settlementType;
        }

        /// <summary>
        /// Exercise Style
        /// </summary>
        /// <returns>returns the type of exercise (AME - BRM - EUR) </returns>
        public override string GetExerciseStyle()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.exerciseStyle;
        }

        /// <summary>
        /// Remaining Duration Days
        /// </summary>
        /// <returns> </returns>
        public override int GetRemainingDurationDays()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.remainingDurationDay;
        }

        /// <summary>
        /// Remaining Duration Ratio
        /// </summary>
        /// <returns> </returns>
        public override decimal GetRemainingDurationRatio()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.remainingDurationRatio;
        }

        /// <summary>
        /// Pay Currency Amount Uic Code 
        /// </summary>
        /// <returns> Returns UIC code of the paid currency </returns>
        public override string GetPayCurrencyUicCode()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.uicCurrencyCode;
        }

        /// <summary>
        /// Rec Currency Amount Uic Code 
        /// </summary>
        /// <returns> Returns UIC code of the received currency </returns>
        public override string GetRecCurrencyUicCode()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.uicCurrencyCode;
        }

        /// <summary>
        /// Pay Currency Amount Idc 
        /// </summary>
        /// <returns> Returns IDC code of the paied currency </returns>
        public override string GetPayCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.idc;
        }

        /// <summary>
        /// Rec Currency Amount Idc 
        /// </summary>
        /// <returns> Returns IDC code of the received currency </returns>
        public override string GetRecCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.idc;
        }

        /// <summary>
        /// Pay Currency Amount
        /// </summary>
        /// <returns> Returns the amount to pay by mainactor currency </returns>
        public override decimal GetPayCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.amount;
        }

        /// <summary>
        /// Rec Currency Amount
        /// </summary>
        /// <returns> Returns the amount to rac by mainactor currency </returns>
        public override decimal GetRecCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.amount;
        }

        /// <summary>
        /// Pay Currency Is Commodity
        /// </summary>
        /// <returns></returns>
        public override bool GetPayCurrencyIsCommodity()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.isCommodity;
        }

        /// <summary>
        /// Rec Currency Is Commodity
        /// </summary>
        /// <returns></returns>
        public override bool GetRecCurrencyIsCommodity()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.isCommodity;
        }

        /// <summary>
        /// Pay Commodity Extra Info Code 
        /// </summary>
        /// <returns></returns>
        public override string GetPayCommodityExtraInfoCode0183()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.commodityExtraInfo.code_0183;
        }

        /// <summary>
        /// Rec Commodity Extra Info Code
        /// </summary>
        /// <returns></returns>
        public override string GetRecCommodityExtraInfoCode0183()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.commodityExtraInfo.code_0183;
        }

        /// <summary>
        /// Pay Commodity Extra Info Code
        /// </summary>
        /// <returns></returns>
        public override string GetPayCommodityExtraInfoCode0525()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.commodityExtraInfo.code_0525;
        }

        /// <summary>
        /// Rec Commodity Extra Info Code
        /// </summary>
        /// <returns></returns>
        public override string GetRecCommodityExtraInfoCode0525()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.commodityExtraInfo.code_0525;
        }

        /// <summary>
        /// Rec Currency Countervalue Amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetRecCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.recCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Pay Currency Countervalue Amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetPayCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.payCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Call Currency Idc
        /// </summary>
        /// <returns> Returns IDC code of the call currency </returns>
        public override string GetCallCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.idc;
        }

        /// <summary>
        /// Put Currency Idc
        /// </summary>
        /// <returns> Returns IDC code of the put currency </returns>
        public override string GetPutCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.idc;
        }

        /// <summary>
        /// Call Currency Countervalue
        /// </summary>
        /// <returns></returns>
        public override decimal GetCallCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Put Currency Countervalue
        /// </summary>
        /// <returns></returns>
        public override decimal GetPutCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Call Currency amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetCallCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.callCurrencyAmount.amount;
        }

        /// <summary>
        /// Put Currency amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetPutCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxSimpleOption.putCurrencyAmount.amount;
        }

    }

    /// <summary>
    /// FxBarrierOption specific methods to get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfosFxBarrierOption : RRGetBusinessInfos
    {
        public RRGetBusinessInfosFxBarrierOption(RegulatoryReport pReport)
            : base(pReport)
        {
        }

        /// <summary>
        /// Option Type
        /// </summary>
        /// <returns> Call or Put </returns>
        public override string GetOptionType()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.optionType;
        }

        /// <summary>
        /// Settlement Type
        /// </summary>
        /// <returns> Phisical or cash settlement </returns>
        public override string GetSettlementType()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.settlementType;
        }

        /// <summary>
        /// Exercise Style
        /// </summary>
        /// <returns>returns the type of exercise (AME - BRM - EUR) </returns>
        public override string GetExerciseStyle()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.exerciseStyle;
        }

        /// <summary>
        /// Remaining Duration Days
        /// </summary>
        /// <returns> </returns>
        public override int GetRemainingDurationDays()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.remainingDurationDay;
        }

        /// <summary>
        /// Remaining Duration Ratio
        /// </summary>
        /// <returns> </returns>
        public override decimal GetRemainingDurationRatio()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.remainingDurationRatio;
        }

        /// <summary>
        /// Pay Currency Amount Uic Code 
        /// </summary>
        /// <returns> Returns UIC code of the paid currency </returns>
        public override string GetPayCurrencyUicCode()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.uicCurrencyCode;
        }

        /// <summary>
        /// Rec Currency Amount Uic Code 
        /// </summary>
        /// <returns> Returns UIC code of the received currency </returns>
        public override string GetRecCurrencyUicCode()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.uicCurrencyCode;
        }

        /// <summary>
        /// Pay Currency Amount Idc 
        /// </summary>
        /// <returns> Returns IDC code of the paied currency </returns>
        public override string GetPayCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.idc;
        }

        /// <summary>
        /// Rec Currency Amount Idc 
        /// </summary>
        /// <returns> Returns IDC code of the received currency </returns>
        public override string GetRecCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.idc;
        }

        /// <summary>
        /// Pay Currency Amount
        /// </summary>
        /// <returns> Returns the amount to pay by mainactor currency </returns>
        public override decimal GetPayCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.amount;
        }

        /// <summary>
        /// Rec Currency Amount
        /// </summary>
        /// <returns> Returns the amount to rac by mainactor currency </returns>
        public override decimal GetRecCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.amount;
        }

        /// <summary>
        /// Pay Currency Is Commodity
        /// </summary>
        /// <returns></returns>
        public override bool GetPayCurrencyIsCommodity()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.isCommodity;
        }

        /// <summary>
        /// Rec Currency Is Commodity
        /// </summary>
        /// <returns></returns>
        public override bool GetRecCurrencyIsCommodity()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.isCommodity;
        }


        /// <summary>
        /// Pay Commodity Extra Info Code 
        /// </summary>
        /// <returns></returns>
        public override string GetPayCommodityExtraInfoCode0183()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.commodityExtraInfo.code_0183;
        }

        /// <summary>
        /// Rec Commodity Extra Info Code
        /// </summary>
        /// <returns></returns>
        public override string GetRecCommodityExtraInfoCode0183()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.commodityExtraInfo.code_0183;
        }

        /// <summary>
        /// Pay Commodity Extra Info Code
        /// </summary>
        /// <returns></returns>
        public override string GetPayCommodityExtraInfoCode0525()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.commodityExtraInfo.code_0525;
        }

        /// <summary>
        /// Rec Commodity Extra Info Code
        /// </summary>
        /// <returns></returns>
        public override string GetRecCommodityExtraInfoCode0525()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.commodityExtraInfo.code_0525;
        }

        /// <summary>
        /// Rec Currency Countervalue Amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetRecCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.recCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Pay Currency Countervalue Amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetPayCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.payCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Call Currency Idc
        /// </summary>
        /// <returns> Returns IDC code of the call currency </returns>
        public override string GetCallCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.idc;
        }

        /// <summary>
        /// Put Currency Idc
        /// </summary>
        /// <returns> Returns IDC code of the put currency </returns>
        public override string GetPutCurrencyIdc()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.idc;
        }

        /// <summary>
        /// Call Currency Countervalue
        /// </summary>
        /// <returns></returns>
        public override decimal GetCallCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Put Currency Countervalue
        /// </summary>
        /// <returns></returns>
        public override decimal GetPutCurrencyCounterValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Call Currency amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetCallCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.callCurrencyAmount.amount;
        }

        /// <summary>
        /// Put Currency amount
        /// </summary>
        /// <returns></returns>
        public override decimal GetPutCurrencyValue()
        {
            return Report.trade.dataDocument.business.fxBarrierOption.putCurrencyAmount.amount;
        }


    }

    /// <summary>
    /// FxDigitalOption specific methods to get Business infos from report business section
    /// </summary>
    public class RRGetBusinessInfosFxDigitalOption : RRGetBusinessInfos
    {
        public RRGetBusinessInfosFxDigitalOption(RegulatoryReport pReport)
            : base(pReport)
        {
        }

        /// <summary>
        /// Payout Idc
        /// </summary>
        /// <returns></returns>
        public override string GetPayoutIdc()
        {
            return Report.trade.dataDocument.business.fxDigitalOption.payoutAmount.idc;
        }

        /// <summary>
        /// Payout amount Value
        /// </summary>
        /// <returns></returns>
        public override Decimal GetPayoutValue()
        {
            return Report.trade.dataDocument.business.fxDigitalOption.payoutAmount.amount;
        }

        /// <summary>
        /// Payout Countervalue amount
        /// </summary>
        /// <returns></returns>
        public override Decimal GetPayoutCounterValue()
        {
            return Report.trade.dataDocument.business.fxDigitalOption.payoutAmount.counterValueAmount.value;
        }

        /// <summary>
        /// Income Idc
        /// </summary>
        /// <returns></returns>
        public override string GetIncomeIdc()
        {
            return Report.trade.dataDocument.business.fxDigitalOption.incomeAmount.idc;
        }

        /// <summary>
        /// Income amount Value
        /// </summary>
        /// <returns></returns>
        public override Decimal GetIncomeValue()
        {
            return Report.trade.dataDocument.business.fxDigitalOption.incomeAmount.amount;
        }

        /// <summary>
        /// Income Countervalue amount
        /// </summary>
        /// <returns></returns>
        public override Decimal GetIncomeCounterValue()
        {
            return Report.trade.dataDocument.business.fxDigitalOption.incomeAmount.counterValueAmount.value;
        }
    }

    /// <summary>
    /// Feed Log section of the report  
    /// </summary>
    public class RRLog
    {
        #region Members
        protected RegulatoryReport m_Report;
        protected RegulatoryReportReport m_ReportReport;
        // REMARKS: add this object to restrict error message number into the log
        //protected int m_MaxLogMessages;
        #endregion
        #region Accessors
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public RegulatoryReportReport ReportReport
        {
            get { return this.m_ReportReport; }
            set { this.m_ReportReport = value; }
        }
        // REMARKS: add this object to restrict error message number into the log
        //public int MaxLogMessages
        //{
        //    get { return this.m_MaxLogMessages; }
        //}
        #endregion
        #region Constructor
        public RRLog(RegulatoryReport pReport, RegulatoryReportReport pReportReport)
        {
            Report = pReport;
            ReportReport = pReportReport;
            // REMARKS: add this object to restrict error message number into the log
            // eg: 99 max messages are writed into the log section
            //m_MaxLogMessages = 99;
        }
        #endregion constructor

        /// <summary>
        /// Count missing fields (alert level = ERROR) on subsystem report section (eg. Elsag or Oasi)
        /// </summary>
        /// <param name="pReportReport"></param>
        /// <returns></returns>
        private int CountMissingFieldDatas(RegulatoryReportReport pReportReport)
        {
            int count = 0;

            for (int ftIndex = 0; ftIndex < pReportReport.formaTecnica.Length; ftIndex++)
            {
                for (int dataIndex = 0; dataIndex < pReportReport.formaTecnica[ftIndex].data.Length; dataIndex++)
                {
                    if (pReportReport.formaTecnica[ftIndex].data[dataIndex] != null)
                    {
                        if (pReportReport.formaTecnica[ftIndex].data[dataIndex].alertLevel == "ERROR")
                            count++;
                    }
                }
            }
            return count;
        }

        /// <summary>
        /// Build log section on the report 
        /// </summary>
        /// <param name="pReport"></param>
        /// <param name="pReportReport"></param>
        public void FeedReportLog(RegulatoryReport pReport, RegulatoryReportReport pReportReport)
        {
            int countMissingFieldDatas = CountMissingFieldDatas(pReportReport);
            //
            if (countMissingFieldDatas > 0)
            {
                // GS 20101228 restrict the number of rows added into the log                    
                if (countMissingFieldDatas > 100)
                {
                    //string message = "More errors are occurs";
                    //Process.ProcessLogAddDetail(message);
                }
                else
                {
                    RegulatoryReportLog ReportLog = new RegulatoryReportLog();
                    Report.log[0] = ReportLog;
                    ReportLog.name = pReportReport.name;
                    this.BuildLogMessage(ReportLog, pReportReport, pReportReport, countMissingFieldDatas);
                }
            }
        }

        /// <summary>
        /// Build log message data for each missing fields (alert level = ERROR) on subsystem report section (eg. Elsag or Oasi)
        /// </summary>
        /// <param name="pReportLog"></param>
        /// <param name="pReport"></param>
        /// <param name="pReportReport"></param>
        /// <param name="pLogDataNumber"></param>
        private void BuildLogMessage(RegulatoryReportLog pReportLog, RegulatoryReportReport pReport, RegulatoryReportReport pReportReport, int pLogDataNumber)
        {
            pReportLog.data = new RegulatoryReportLogData[pLogDataNumber];
            int iData = 0;

            for (int ftIndex = 0; ftIndex < pReportReport.formaTecnica.Length; ftIndex++)
            {
                for (int dataIndex = 0; dataIndex < pReportReport.formaTecnica[ftIndex].data.Length; dataIndex++)
                {
                    // GS 20100916: remove this condition
                    if (pReportReport.formaTecnica[ftIndex].data[dataIndex] != null)
                    {
                        if (pReportReport.formaTecnica[ftIndex].data[dataIndex].alertLevel == "ERROR")
                        {
                            RegulatoryReportLogData logData = new RegulatoryReportLogData
                            {
                                ftkey = pReport.formaTecnica[ftIndex].sqc,
                                ftname = pReport.formaTecnica[ftIndex].name,
                                field = pReport.formaTecnica[ftIndex].data[dataIndex].field,
                                orField = pReport.formaTecnica[ftIndex].data[dataIndex].originalName,
                                logLevel = pReport.formaTecnica[ftIndex].data[dataIndex].alertLevel,
                                msg = pReport.formaTecnica[ftIndex].data[dataIndex].errMsg
                            };
                            pReportLog.data[iData] = logData;
                            iData++;
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// XML Serialize of report classes  
    /// Store xml report into RREPORTDET table
    /// </summary>
    public class RRStore
    {
        #region Members
        private string m_Cs;
        private RegulatoryReport m_Report;
        private string m_IdRReport;
        private int m_UserId;
        private string m_ProcessId;
        private string m_ReportType;
        #endregion
        #region Accessors
        public string Cs
        {
            get { return this.m_Cs; }
            set { this.m_Cs = value; }
        }
        public RegulatoryReport Report
        {
            get { return this.m_Report; }
            set { this.m_Report = value; }
        }
        public string IdRReport
        {
            get { return this.m_IdRReport; }
            set { this.m_IdRReport = value; }
        }
        public int UserId
        {
            get { return this.m_UserId; }
            set { this.m_UserId = value; }
        }
        public string ProcessId
        {
            get { return this.m_ProcessId; }
            set { this.m_ProcessId = value; }
        }
        public string ReportType
        {
            get { return this.m_ReportType; }
            set { this.m_ReportType = value; }
        }
        #endregion
        #region constructor
        public RRStore(string pCs, RegulatoryReport pReport, string pIdRReport, int pUserId, string pProcessId, string pReportType)
        {
            Cs = pCs;
            Report = pReport;
            IdRReport = pIdRReport;
            UserId = pUserId;
            ProcessId = pProcessId;
            ReportType = pReportType;
        }
        #endregion constructor

        /// <summary>
        /// XML serialize of report classes 
        /// call method to store a row into RREPORTDET table
        /// </summary>
        /// <param name="pIdt"></param>
        private void XmlSerialize(Int32 pIdt)
        {
            using (System.IO.StringWriter sw = new System.IO.StringWriter())
            {
                var xs = new XmlSerializer(typeof(RegulatoryReport));
                xs.Serialize(sw, Report);
                string xmlEncoded = sw.ToString();
                AddRReportDetRow(IdRReport, pIdt, xmlEncoded, UserId, ProcessId, ReportType);
            }

            #region old version
            //// Create a memory stream
            //System.IO.MemoryStream ms = new System.IO.MemoryStream();
            ////Serialize report 
            //XmlSerializer s = new XmlSerializer(typeof(RegulatoryReport));
            //System.Xml.XmlTextWriter tw = new System.Xml.XmlTextWriter(ms, null);
            //s.Serialize(tw, Report);
            //// Rewind the memory stream
            //ms.Seek(0, System.IO.SeekOrigin.Begin);
            //System.Xml.XmlDocument doc = new System.Xml.XmlDocument();
            //// load memory stream
            //doc.Load(ms);
            //// set xml report string with the memory stream 
            //string xmlReport = doc.OuterXml;
            //// add xml report string into a RREPORTDET column
            //AddRReportDetRow(IdRReport, pIdt, xmlReport, UserId, ProcessId, ReportType);
            #endregion
        }

        /// <summary>
        /// Insert a row into RREPORTDET table
        /// </summary>
        /// <param name="Cs"></param> 
        private void AddRReportDetRow(string pIdRReport, Int32 pIdt, string pXmlReport, int pUserId, string pProcessId, string pReportType)
        {
            string productIdentifier = Report.trade.header.productIdentifier;
            string tradeIdentifier = Report.trade.header.identifier;
            DateTime dtReport = Report.trade.header.endDate;

            DataParameters parameters = new DataParameters();
            parameters.Add(new DataParameter(Cs, "IDRREPORT", DbType.String), pIdRReport);
            parameters.Add(new DataParameter(Cs, "IDT", DbType.Int32), pIdt);
            parameters.Add(new DataParameter(Cs, "TRADEIDENTIFIER", DbType.String), tradeIdentifier);
            parameters.Add(new DataParameter(Cs, "PRODUCT", DbType.String), productIdentifier);
            parameters.Add(new DataParameter(Cs, "XMLREPORT", DbType.Xml), pXmlReport);
            // FI 20200820 [25468] dates systemes en UTC
            parameters.Add(DataParameter.GetParameter(Cs,DataParameter.ParameterEnum.DTINS), OTCmlHelper.GetDateSysUTC(Cs));
            parameters.Add(new DataParameter(Cs, "IDAINS", DbType.Int32), pUserId);
            parameters.Add(new DataParameter(Cs, "DTREPORT", DbType.Date), dtReport); // FI 20201006 [XXXXX] DbType.Date
            parameters.Add(new DataParameter(Cs, "PROCESSID", DbType.String), pProcessId);
            parameters.Add(new DataParameter(Cs, "REPORTTYPE", DbType.String), pReportType);
            StrBuilder sqlInsert = new StrBuilder();
            sqlInsert += SQLCst.INSERT_INTO_DBO + "RREPORTDET" + Cst.CrLf;
            sqlInsert += "(IDRREPORT, IDT, TRADEIDENTIFIER,PRODUCT,XMLREPORT,DTINS,IDAINS,DTREPORT,PROCESSID, REPORTTYPE) values " + Cst.CrLf;
            sqlInsert += @"(@IDRREPORT, @IDT,@TRADEIDENTIFIER,@PRODUCT,@XMLREPORT,@DTINS,@IDAINS,@DTREPORT,@PROCESSID,@REPORTTYPE)" + Cst.CrLf;
            DataHelper.ExecuteNonQuery(Cs, CommandType.Text, sqlInsert.ToString(), parameters.GetArrayDbParameter());
        }

        /// <summary>
        /// Call methods to serialize and store the report classes  
        /// </summary>
        /// <param name="pIdt"></param>
        virtual public void Store(Int32 pIdt)
        {
            bool isInTheScope = Report.trade.header.isInTheScope;
            if (isInTheScope == true)
                this.XmlSerialize(pIdt);
        }
    }
}
