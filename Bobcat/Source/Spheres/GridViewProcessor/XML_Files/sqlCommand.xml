<?xml version="1.0" encoding="utf-8" ?>
<!-- 
FI 20160229 [21830] POSACTIONDET_PRESELECT, POSACTIONDET_TRADE_PRESELECT (Modify on PRICE Column)
RD 20160215 [21384] POSACTIONDET_OTC_PRESELECT use periode  
RD 20160209 [21384] POSACTIONDET_PRESELECT use periode  
FI 20160205 [XXXXX] DENBULK_PRESELECT ajout <choose> </choose>
FI 20160129 [XXXXX] FLOWSBYASSETOTC_SELECT %%CC:ITRADEINSTRUMENT_JOIN%% utilisé  à un niveau plus bas dans la requête 
CC 20151118 [21489] Add new consultation for flows by asset (OTC) (FLOWSBYASSETOTC_ALLOC)  (using 'choose' functionality)
RD 20150925 [21397] POSDETOTC_ALLOC consultation - Modify POSDETOTC_PRESELECT
FI 20150917 [21312] add choose expression on FLOWSBYCURRENCY_SELECT + usage de TRADEINSTRUMENT à la place de TRADEACTOR
FI 20150917 [21312] add choose expression on RISKPERFORMANCE_SELECT + usage de TRADEINSTRUMENT à la place de TRADEACTOR
FI 20150917 [21312] add choose expression on MCO_RPT_SELECT
FI 20150916 [21312] add choose expression on CASHPAYMENT_SELECT
FI 20150916 [21312] add choose expression on POSACTIONDET_OTC_SELECT et POSACTIONDET_SELECT
FI 20150916 [21312] add choose expression on FLOWSBYCURRENCY_SELECT
FI 20150916 [21312] add choose expression on POSDETOTC_PRESELECT
FI 20150914 [21312] add choose expression on POSDET_PRESELECT et POSSYNT_PRESELECT
CC/PL 20150717 - CASHBALANCE consultation - Add SKP (Safekeeping Payment)
CC/PL/EG/PM 20150616 [21124]  Display flow on new EventClass VAL (ValueDate)
CC/PL 20150515 [20987] Modify MCO_RPT_SELECT
CC/FI 20150513 [XXXXX] Suppression MCO_RPT_FINPER_SELECT et intégration dans MCO_RPT_SELECT
CC/FI 20150513 [20987] Modify MCO_RPT_SELECT
CC/PM 20150330 CASHBALANCE_SELECT - Add LPC/UST (Unsettled Transaction)
PL 20150324 Add BWA
CC 20150323 FLOWSBYCURRENCY_SELECT - Add limitation on EventCode CBS (CashBalanceStream) to display flows on original currency flow
PM 20150212 [20793] Modify FLOWSBYASSET_SELECT : add amount of events RMV in disabled date with inverted payer and receiver and always show disabled events
CC/PL 20150205 [20770] CASHPAYMENT_SELECT  
CC/PL 20150126 CASHPAYMENT_SELECT - Modify join on EVENTENUM to display amount type
CC 20150119 [20689] CASHBALANCE_SELECT - Display flows on ExchangeCashBalanceStream and use ConditionDynamicArg
EG 20150120 [20683] Add DTOBSOLETE to MCO_RPT_SELECT, MCO_RPT_FINPER_SELECT
FI 20150114 [20674] Modify FLOWSBYASSET_SELECT prise en compte des assets tes que mat.MATURITYDATE>=@DATE1
CC 20141215 [20563] use ConditionDynamicArg on FLOWSBYASSET_SELECT
FI 20141215 [20563] use ConditionDynamicArg on POSSYNT_PRESELECT
FI 20141107 [20441] NOPARAMS on POSSYNT_PRESELECT et POSDET_PRESELECT 
FI 20141107 [20441] use %%SR:TRADEALLOC_JOIN%%,%%SR:TRADERISK_JOIN%%  
CC 20141029 POSACTIONDET_OTC_SELECT - End realization
CC 20141016 CASHBALANCE_SELECT - Add new amounts (Fee, Premium, Cash Settlement)
PM 20141010 [18685] Modification of FLOWSBYASSET_SELECT : Exclude TrdType 'OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003)' from "Qty Traded"
PM 20141008 [20405] Add columns LOV_UNIT, LOV_SIGNED, UMG_UNIT, UMG_SIGNED to POSSYNT_PRESELECT
EG 20141002 POSACTIONDET_OTC_SELECT - In progress
CC 20141002 CASHBALANCE_SELECT - Add new amounts (UK method)
FI 20140924 [XXXXX] %%CC:ITRADEINSTRUMENT%% est remplacé par %%CC:ITRADEINSTRUMENT_JOIN%%
CC 20140922 [20351] POSDET_PRESELECT: Add columns IDA_COUNTERPARTY and IDB_COUNTERPARTY
CC 20140922 [20351] POSSYNT_PRESELECT: Add columns IDA_COUNTERPARTY and IDB_COUNTERPARTY
CC 20140819 Add consultation Posting detailed positions (OTC)
FI 20140702 [20161] Modification RISKPERFORMANCE_SELECT considération de la colonne TRADE.TIMING
FI 20140626 [20142] Ajout des mots clés %%CC:ITRADEINSTRUMENT%%
FI 20140428 [19746]
- POSSYNT_PRESELECT : Refactoring dans alimentation des tables temporaires
- POSDET_PRESELECT  : Refactoring dans alimentation des tables temporaires

RD 20140206 [19518] Balances and Movements by currency consultation (FLOWSBYCURRENCY_SELECT)
- Add column COLLATERAL_U (Collateral Used)
- Add column COLLATERAL_U_PREV (Collateral Used(previous amount))
- Rename of column: PREVCOLLATERAL_A to: COLLATERAL_A_PREV

FI 20140122 [] lecture de la colonne EVENTDET_ETD.SETTLTPRICE100
RD 20140121 [19671] Pour les Options avec SSJ Future, déterminer l'indicateur ITM/OTM en tenant compte de la base d'expression du prix de ce SSJ:
-	opérer une conversion si la base diffère de 100 (ex. 32)

CC 20140120 [19510] Flows by asset and Cash Balance consultations
- add column DAILYBALANCE on Cash Balance consultation
- add column CASHFLOW on Flows by asset consultation

RD 20140120 [] Balances and Movements by currency (FLOWSBYCURRENCY_SELECT)
- Rename of columns: INITIALMARGINREQ, MARGINAMOUNT, PREVMARGINAMOUNT
to: MARGINCALL,       MARGINREQ,    MARGINREQ_PREV
Cash balances (CASHBALANCE_SELECT)
- Rename of columns: INITIALMARGINREQ, MARGINAMOUNT
to: MARGINCALL,       MARGINREQ

RD 20140117 [19477] Refactoring of request of Balances and Movements by currency (FLOWSBYCURRENCY_SELECT)
RD 20140106 [19440] Refactoring of request of Balances and Movements by currency (FLOWSBYCURRENCY_SELECT)

RD 20131224 [18679] Financial Statement Member  (FLOWSBYCURRENCY_SELECT)
- Add column COLLATERAL_A (Securities Collateral (available))
- Add column PREVCOLLATERAL_A (Previous Securities Collateral (available))

CC 20131218 [19363] Flows by asset consultation  (FLOWSBYASSET_SELECT)
- rename column FEE to FEEINCLTAXAMOUNT (Fees amount including taxes)
- add column TAXAMOUNT (Taxes amount)
- add column FEEEXCLTAXAMOUNT (Fees amount excluding taxes)

RD 20131007 [18679] Financial Statement Member
EG 20130917 Refactoring complet des requêtes Flux par actifs / Soldes et mouvements par devise
20130704 [18745] MCO_RPT_SELECT add SYNTHESIS

CC 20121106 Add Uncovered initial margin on CASHBALANCE consultation
FI 20120831 [18048]
- add MCO_RPT_FINPER_SELECT => Requête utilisée pour la consultation des messages FINANCIALPERIODIC (extraits de compte)
- mod MCO_RPT_SELECT => La requête n'affiche que les messages ALLOCATION,FINANCIAL,POSITION,POSSYNTHETIC,POSACTION

FI 20120831 [18113] Nouveau Standard, les tables de travail (temporaires) se terminent par _W

FI 20120605
Modification de POSACTIONDET_SELECT, POSACTIONDET_PRESELECT, POSACTIONDET_TRADE_PRESELECT
Ajout de la colonne ITM_OTM

FI 20120601
Modification de POSACTIONDET_SELECT
L'action Transfert s'affiche s'il n'y a aucun changement de book
Côté Client,House
L'action Transfert s'affiche si le book côté dealear a changé
Côté Clearing
L'action Transfert s'affiche si le book côté clearing a changé

FI 20120516 Ajout de POSACTIONDET_TRADE_PRESELECT
utilisé par la consultation 3 boutons enfant de trade

FI 20120515 Refactoring de la consultaion POSACTIONDET
Ajout de POSACTIONDET_PRESELECT
et
Modification de POSACTIONDET_SELECT

FI 20120404 [Refactoring Messagerie Edition]
Reecriture query MCO_RPT_SELECT, utilisation de la colonne MCO.IDB_SENDTOPARTY

FI 20120314 ticket[17721] add prefix dbo. (quote dbo.VW_QUOTE_H%ROWTYPE;)
FI 20120228 Modification ds POSACTIONDET_SELECT (voir le tag concerné)

FI 20111121 Resource xml qui contient une liste de requêtes SQL
de type ReferentialsReferentialSQLSelect (voir cette classe)
Ces requêtes sont susceptibles d'être utilisées par une consultation 3pts ou 5pts

Chaque requête est identifiée via un name
Il existe jusqu'à 4 version d'une même requête (Oracle/sqlServer et SessionRestrict oui/non)
-->

<sqlCommands>

  <item name="POSSYNT_PRESELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[delete from POSSYNT_%%SHORTSESSIONID%%_W;]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
  /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        
  insert into POSSYNT_%%SHORTSESSIONID%%_W
  (CLIENT_IDA , POSTYPE, DATAKEYFIELD, DTBUSINESS, IDASSET,
  IDA_DEALERORCLEARER,IDB_DEALERORCLEARER,
  IDA_COUNTERPARTY, IDB_COUNTERPARTY,
  QTY_BUY,WAVGPRICE_BUY,
  QTY_SELL,WAVGPRICE_SELL,
  SIDE_NET,QTY_NET, IDM,
  LOV_UNIT, LOV_SIGNED, UMG_UNIT, UMG_SIGNED)
  select 
  arCLIENT.IDA,
  rs.POSTYPE,
  rs.DATAKEYFIELD,
  rs.DTBUSINESS, rs.IDASSET, 
  rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER,
  rs.IDA_COUNTERPARTY, rs.IDB_COUNTERPARTY,
  nullif(rs.QTY_BUY,0) as QTY_BUY, 
  nullif(rs.WAVGPRICE_BUY,0) as WAVGPRICE_BUY, 
  nullif(rs.QTY_SELL,0) as QTY_SELL, 
  nullif(rs.WAVGPRICE_SELL,0) as WAVGPRICE_SELL, 
  rs.SIDE_NET,
  rs.QTY_NET,
  rs.IDM,
  rs.LOV_UNIT,
  rs.LOV_SIGNED,
  rs.UMG_UNIT,
  rs.UMG_SIGNED
  from
  (
  <choose>
  <when test="{POSTYPE}=1 or {POSTYPE}=0">
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- ************************************************************************************************************************************************************
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  select  /*+ ordered */
  1 as POSTYPE,
  '1' || '|' || 
  '%%DA:DATE1.GetDataValue()%%' || '|' || 
  convert(varchar, ti.IDASSET) || '|' || 
  convert(varchar, ti.IDB_DEALER) || '|' || 
  convert(varchar, ti.IDB_CLEARER) as DATAKEYFIELD, 
  ti.IDASSET as IDASSET, 
  @DATE1 as DTBUSINESS,
  ti.IDA_DEALER as IDA_DEALERORCLEARER, ti.IDB_DEALER as IDB_DEALERORCLEARER,
  ti.IDA_CLEARER as IDA_COUNTERPARTY, ti.IDB_CLEARER as IDB_COUNTERPARTY, 
  sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) as QTY_BUY,
  sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) * ti.PRICE else 0 end) / 
    nullif(sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end),0) as WAVGPRICE_BUY,
  sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end) as QTY_SELL,
  sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) * ti.PRICE else 0 end) / 
    nullif(sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end),0) as WAVGPRICE_SELL,
  case when (sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) - sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end)) > 0 then 'Long'
     when (sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) - sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end)) &lt; 0 then 'Short'
     else 'Flat' end as SIDE_NET,
  abs(sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) - sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end)) as QTY_NET, 
  ti.IDM,
  e_amt.UNIT as LOV_UNIT, sum(e_amt.LOV_SIGNED) LOV_SIGNED,
  e_amt.UNIT as UMG_UNIT, sum(e_amt.UMG_SIGNED) UMG_SIGNED
  from dbo.TRADE t
  inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = t.IDT) and (ti.INSTRUMENTNO = 1)
  %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
  inner join dbo.TRADESTSYS tsys on ( tsys.IDT = t.IDT ) and (tsys.IDSTACTIVATION = 'REGULAR') and (tsys.IDSTBUSINESS = 'ALLOC')
  inner join dbo.INSTRUMENT ns on ( ns.IDI = t.IDI)
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.GPRODUCT = 'FUT')
  inner join dbo.BOOK b on b.IDB = ti.IDB_DEALER
  inner join dbo.BOOK b2 on b2.IDB = ti.IDB_CLEARER
  %%SR:TRADEALLOC_JOIN%%(t.IDT,ti,b)
  left outer join (   
    select SUM(pad.QTY) as QTY, pad.IDT_SELL as IDT
    from dbo.POSACTION pa
    inner join dbo.POSACTIONDET pad on pad.IDPA = pa.IDPA
    where (pa.DTBUSINESS &lt;= @DATE1)
    and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
    group by pad.IDT_SELL
  ) pas on (pas.IDT=t.IDT)

  left outer join (   
    select SUM(pad.QTY) as QTY, pad.IDT_BUY as IDT
    from dbo.POSACTION pa
    inner join dbo.POSACTIONDET pad on pad.IDPA = pa.IDPA
    where (pa.DTBUSINESS &lt;= @DATE1)
    and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
    group by pad.IDT_BUY
  ) pab on (pab.IDT=t.IDT)

  left outer join (/* Cumul des flux LOV/UMG, LPC s’il en existe (donc flux EOD), sinon LPI (donc flux Intraday)*/
    select
    sum(case when e.EVENTTYPE='LOV' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as LOV_SIGNED,
    sum(case when e.EVENTTYPE='UMG' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as UMG_SIGNED,
    e.IDT, e.UNIT as UNIT
    from dbo.EVENT e
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=e.IDT) and ( (ti.IDA_DEALER=e.IDA_PAY) or (ti.IDA_DEALER=e.IDA_REC) )
    inner join dbo.EVENTCLASS ec on (ec.IDE=e.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT=%%DA:DATE1.GetDataSQLValue()%%)
    where (e.EVENTCODE='LPC') and (e.EVENTTYPE in ('LOV','UMG'))
    and ( (e.IDSTACTIVATION='REGULAR') or (e.IDSTACTIVATION='DEACTIV' and e.DTSTACTIVATION > %%DA:DATE1.GetDataSQLValue()%%))
    group by e.IDT, e.UNIT
    union all
    select
    sum(case when e.EVENTTYPE='LOV' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as LOV_SIGNED,
    sum(case when e.EVENTTYPE='UMG' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as UMG_SIGNED,
    e.IDT, e.UNIT as UNIT
    from dbo.EVENT e
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=e.IDT) and ( (ti.IDA_DEALER=e.IDA_PAY) or (ti.IDA_DEALER=e.IDA_REC) )
    inner join dbo.EVENTCLASS ec on (ec.IDE=e.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT=%%DA:DATE1.GetDataSQLValue()%%)
    left outer join dbo.EVENT e2 on (e2.IDT=e.IDT) and (e2.EVENTCODE='LPC') and (e2.EVENTTYPE=e.EVENTTYPE)
    and ( (e2.IDSTACTIVATION='REGULAR') or (e2.IDSTACTIVATION='DEACTIV' and e2.DTSTACTIVATION > %%DA:DATE1.GetDataSQLValue()%%))
    left outer join dbo.EVENTCLASS ec2 on (ec2.IDE=e2.IDE) and (ec2.EVENTCLASS='VAL') and (ec2.DTEVENT=%%DA:DATE1.GetDataSQLValue()%%)
    where (e.EVENTCODE='LPI') and (e.EVENTTYPE in ('LOV','UMG'))
    and ( (e.IDSTACTIVATION='REGULAR') or (e.IDSTACTIVATION='DEACTIV' and e.DTSTACTIVATION > %%DA:DATE1.GetDataSQLValue()%%))
    and (ec2.IDE is null)
    group by e.IDT, e.UNIT
  ) e_amt on (e_amt.IDT=t.IDT)

  where 
  (@DATE1 >= case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end)
  and (b.ISPOSKEEPING=1)
  and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
  and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
  
  group by ti.IDASSET, 
  ti.IDA_DEALER, ti.IDB_DEALER, 
  ti.IDB_CLEARER, ti.IDM,
  ti.IDA_CLEARER, e_amt.UNIT
  having (sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) > 0) or
     (sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end) > 0)
  </when>
  </choose>
  
  <choose>
  <when test="{POSTYPE}=0">
  -- ============================================================================================================================================================                
  union all                
  -- ============================================================================================================================================================                
  </when>
  </choose>
  
  <choose>
  <when test="{POSTYPE}=2 or {POSTYPE}=0">
  select  /*+ ordered */
  2 as POSTYPE,
  '2' || '|' || 
  '%%DA:DATE1.GetDataValue()%%' || '|' || 
  convert(varchar, ti.IDASSET) || '|' || 
  convert(varchar, ti.IDB_CLEARER) as DATAKEYFIELD, 
  ti.IDASSET as IDASSET, 
  @DATE1 as DTBUSINESS,
  ti.IDA_CLEARER as IDA_DEALERORCLEARER, ti.IDB_CLEARER as IDB_DEALERORCLEARER,
  null as IDA_COUNTERPARTY, null as IDB_COUNTERPARTY, 
  sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) as QTY_BUY,
  sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) * ti.PRICE else 0 end) / nullif(sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end),0) as WAVGPRICE_BUY,
  sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end) as QTY_SELL,
  sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) * ti.PRICE else 0 end) / nullif(sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end),0) as WAVGPRICE_SELL,
  case when (sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) - sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end)) > 0 then 'Long'
     when (sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) - sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end)) &lt; 0 then 'Short'
     else 'Flat' end as SIDE_NET,
  abs(sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) - sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end)) as QTY_NET,
  ti.IDM,
  e_amt.UNIT as LOV_UNIT, sum(e_amt.LOV_SIGNED) LOV_SIGNED,
  e_amt.UNIT as UMG_UNIT, sum(e_amt.UMG_SIGNED) UMG_SIGNED
  from dbo.TRADE t
  inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = t.IDT) and (ti.INSTRUMENTNO = 1)
  %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
  inner join dbo.TRADESTSYS tsys on (tsys.IDT = t.IDT ) and (tsys.IDSTACTIVATION = 'REGULAR') and (tsys.IDSTBUSINESS = 'ALLOC')
  inner join dbo.INSTRUMENT ns on (ns.IDI = t.IDI)
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.GPRODUCT = 'FUT')
  inner join dbo.BOOK b on b.IDB = ti.IDB_DEALER
  inner join dbo.BOOK b2 on b2.IDB = ti.IDB_CLEARER
  %%SR:TRADEALLOC_JOIN%%(t.IDT,ti,b)
  left outer join (   
    select SUM(pad.QTY) as QTY, pad.IDT_SELL as IDT
    from dbo.POSACTION pa
    inner join dbo.POSACTIONDET pad on pad.IDPA = pa.IDPA
    where (pa.DTBUSINESS &lt;= @DATE1)
    and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
    group by pad.IDT_SELL
  ) pas on (pas.IDT=t.IDT)

  left outer join (   
    select SUM(pad.QTY) as QTY, pad.IDT_BUY as IDT
    from dbo.POSACTION pa
    inner join dbo.POSACTIONDET pad on pad.IDPA = pa.IDPA
    where (pa.DTBUSINESS &lt;= @DATE1)
    and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
    group by pad.IDT_BUY
  ) pab on (pab.IDT=t.IDT)

  left outer join (/* Cumul des flux LOV/UMG, LPC s’il en existe (donc flux EOD), sinon LPI (donc flux Intraday)*/
    select
    sum(case when e.EVENTTYPE='LOV' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as LOV_SIGNED,
    sum(case when e.EVENTTYPE='UMG' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as UMG_SIGNED,
    e.IDT, e.UNIT as UNIT
    from dbo.EVENT e
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=e.IDT) and ( (ti.IDA_DEALER=e.IDA_PAY) or (ti.IDA_DEALER=e.IDA_REC) )
    inner join dbo.EVENTCLASS ec on (ec.IDE=e.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT=%%DA:DATE1.GetDataSQLValue()%%)
    where (e.EVENTCODE='LPC') and (e.EVENTTYPE in ('LOV','UMG'))
    and ( (e.IDSTACTIVATION='REGULAR') or (e.IDSTACTIVATION='DEACTIV' and e.DTSTACTIVATION > %%DA:DATE1.GetDataSQLValue()%%))
    group by e.IDT, e.UNIT
    union all
    select
    sum(case when e.EVENTTYPE='LOV' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as LOV_SIGNED,
    sum(case when e.EVENTTYPE='UMG' then case when e.IDA_PAY=ti.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as UMG_SIGNED,
    e.IDT, e.UNIT as UNIT
    from dbo.EVENT e
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=e.IDT) and ( (ti.IDA_DEALER=e.IDA_PAY) or (ti.IDA_DEALER=e.IDA_REC) )
    inner join dbo.EVENTCLASS ec on (ec.IDE=e.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT=%%DA:DATE1.GetDataSQLValue()%%)
    left outer join dbo.EVENT e2 on (e2.IDT=e.IDT) and (e2.EVENTCODE='LPC') and (e2.EVENTTYPE=e.EVENTTYPE)
    and ( (e2.IDSTACTIVATION='REGULAR') or (e2.IDSTACTIVATION='DEACTIV' and e2.DTSTACTIVATION > %%DA:DATE1.GetDataSQLValue()%%))
    left outer join dbo.EVENTCLASS ec2 on (ec2.IDE=e2.IDE) and (ec2.EVENTCLASS='VAL') and (ec2.DTEVENT=%%DA:DATE1.GetDataSQLValue()%%)
    where (e.EVENTCODE='LPI') and (e.EVENTTYPE in ('LOV','UMG'))
    and ( (e.IDSTACTIVATION='REGULAR') or (e.IDSTACTIVATION='DEACTIV' and e.DTSTACTIVATION > %%DA:DATE1.GetDataSQLValue()%%))
    and (ec2.IDE is null)
    group by e.IDT, e.UNIT
  ) e_amt on (e_amt.IDT=t.IDT)

  where 
  (@DATE1 >= case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end)
  and (b.ISPOSKEEPING=1)
  and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
  and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
  
  group by ti.IDASSET, 
  ti.IDA_CLEARER, ti.IDB_CLEARER, 
  ti.IDM, e_amt.UNIT
  having (sum(case when ti.SIDE = '1' then (ti.QTY - isnull(pab.QTY,0)) else 0 end) > 0) or
     (sum(case when ti.SIDE = '2' then (ti.QTY - isnull(pas.QTY,0)) else 0 end) > 0)
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- ************************************************************************************************************************************************************
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  </when>
  </choose>
  ) rs
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=rs.IDA_DEALERORCLEARER);
			]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <!--FI 20140428 [19746] utilisation de union ALL -->
      <Command rdbms="sqlserver" >
        <![CDATA[
  delete from POSSYNTQUOTE_%%SHORTSESSIONID%%_W;
  
  insert into POSSYNTQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL, IDQUOTE_H, VALUE,TIME, QUOTETIMING, SOURCE,ITM_OTM)
  select asset_etd.IDASSET, assetQuoteUnl.IDASSET_UNL, assetQuoteUnl.ASSETCATEGORY_UNL,
  quote_last.IDQUOTE_H,quote_last.VALUE, quote_last.TIME,quote_last.QUOTETIMING,quote_last.SOURCE,
  case  
  -- 1 = Call
  when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE then 'Out the money'
  when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE then 'In the money' 
  when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE then 'At the money' 
  -- 0 = Put
  when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE then 'In the money'
  when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE then 'Out the money'
  when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE then 'At the money'
  else 'N/A' end as ITM_OTM
  from 
  (
    select asset_etd.IDASSET as IDASSET, 
    asset_unl.IDASSET as IDASSET_UNL ,
    'Future' as ASSETCATEGORY_UNL ,
    case when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 
        then asset_etd.STRIKEPRICE
    else 
        floor(asset_etd.STRIKEPRICE) + 
        ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE)) * 
        case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
        (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
    end as STRIKE_PRICE ,
    (
      select top 1 IDQUOTE_H
      from dbo.VW_QUOTE_H quote
      where 
      (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') 
      and (quote.ISENABLED=1) 
      and quote.TIME < (@DATE1+1)  
      and quote.IDASSET = asset_unl.IDASSET
      and quote.ASSETCATEGORY= 'Future'
      order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose')   
                                      when 'OfficialSettlement' then 0 
                                      when 'OfficialClose' then 1
                                      else 2 end asc	 				

    ) as IDQUOTE_H_UNL
    from dbo.ASSET_ETD asset_etd
    inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
    inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O' and dc_asset.ASSETCATEGORY='Future'
    inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET = da_asset.IDASSET)
    inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
    inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
    where  exists (select IDASSET from POSSYNT_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET)
    
    union all 
    
    select asset_etd.IDASSET as IDASSET, 
    vw_asset_unl.IDASSET as IDASSET_UNL ,
    vw_asset_unl.ASSETCATEGORY as ASSETCATEGORY_UNL ,
    asset_etd.STRIKEPRICE as STRIKE_PRICE ,
    (
      select top 1 IDQUOTE_H
      from dbo.VW_QUOTE_H quote
      where 
      (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') 
      and (quote.ISENABLED=1) 
      and quote.TIME < (@DATE1+1)  
      and quote.IDASSET = vw_asset_unl.IDASSET
      and quote.ASSETCATEGORY= vw_asset_unl.ASSETCATEGORY
      order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose')   
                                      when 'OfficialSettlement' then 0 
                                      when 'OfficialClose' then 1
                                      else 2 end asc	 				

    ) as IDQUOTE_H_UNL
    from dbo.ASSET_ETD asset_etd
    inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
    inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O' and dc_asset.ASSETCATEGORY!='Future'
    inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY and vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL
    where  exists (select IDASSET from POSSYNT_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET)
    ) assetQuoteUnl
    inner join dbo.ASSET_ETD asset_etd on asset_etd.IDASSET = assetQuoteUnl.IDASSET
    inner join dbo.VW_QUOTE_H quote_last on quote_last.IDQUOTE_H = assetQuoteUnl.IDQUOTE_H_UNL and
                              quote_last.IDASSET=assetQuoteUnl.IDASSET_UNL and
                              quote_last.ASSETCATEGORY=assetQuoteUnl.ASSETCATEGORY_UNL;
      
      ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
  delete from POSSYNTQUOTE_%%SHORTSESSIONID%%_W;

  insert into POSSYNTQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL,IDQUOTE_H,VALUE,TIME,QUOTETIMING,SOURCE,ITM_OTM)
  select asset_etd.IDASSET as IDASSET,  vw_asset_unl.IDASSET, vw_asset_unl.ASSETCATEGORY, 
         null, null, null, null,null,null
  from dbo.ASSET_ETD asset_etd
  inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
  inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O'
  inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY and
  (
    (dc_asset.ASSETCATEGORY != 'Future' and vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL)
    or
    (dc_asset.ASSETCATEGORY = 'Future' and vw_asset_unl.IDASSET=da_asset.IDASSET)
  )
  where exists (select IDASSET from POSSYNT_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET);
      ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
declare 
quote dbo.VW_QUOTE_H%ROWTYPE;
found boolean ;  

cursor c1 is
select possyntquote_w.IDASSET,possyntquote_w.IDASSET_UNL,possyntquote_w.ASSETCATEGORY_UNL,possyntquote_w.IDQUOTE_H,
asset_etd.PUTCALL,
case when possyntquote_w.ASSETCATEGORY_UNL='Future' then
  case 
    when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 
      then asset_etd.STRIKEPRICE
    else 
      floor(asset_etd.STRIKEPRICE) + 
      ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE)) * 
      case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
      (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
  end
else 
  asset_etd.STRIKEPRICE 
end as STRIKE_PRICE
from POSSYNTQUOTE_%%SHORTSESSIONID%%_W possyntquote_w
inner join dbo.ASSET_ETD asset_etd on asset_etd.IDASSET = possyntquote_w.IDASSET
left outer join dbo.ASSET_ETD asset_unl on (possyntquote_w.ASSETCATEGORY_UNL='Future' and asset_unl.IDASSET = possyntquote_w.IDASSET_UNL)
left outer join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
left outer join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
order by possyntquote_w.IDASSET_UNL ;

  begin
    for row1 in c1
    loop
        found:= true;
        
        begin
        select quoteLast.* into quote 
        from(
            select quote.*
            from dbo.VW_QUOTE_H quote
            where 
              (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or 
              quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') 
              and (quote.ISENABLED=1) 
              and quote.TIME < ( %%DA:DATE1.GetDataSQLValue()%% +1)
              and quote.IDASSET = row1.IDASSET_UNL
              and quote.ASSETCATEGORY = row1.ASSETCATEGORY_UNL
              and exists (select 1 from POSSYNTQUOTE_%%SHORTSESSIONID%%_W 
                                       where IDQUOTE_H is null and IDASSET_UNL = row1.IDASSET_UNL and ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL)
              order by quote.TIME desc, case nvl(quote.QUOTESIDE,'OfficialClose')   
                          when 'OfficialSettlement' then 0 
                          when 'OfficialClose' then 1
                          else 2 end asc                                     
              ) quoteLast
            where rownum =1;
        exception
             when NO_DATA_FOUND then
              found:= false;
        end;
  
        if (found) then
          update POSSYNTQUOTE_%%SHORTSESSIONID%%_W
          set 
              IDQUOTE_H  = quote.IDQUOTE_H,
              VALUE = quote.VALUE,
              TIME = quote.TIME,
              QUOTETIMING = quote.QUOTETIMING,
              SOURCE = quote.SOURCE,
              ITM_OTM = ( case  
                          -- 1 = Call
                          when row1.PUTCALL='1' and row1.STRIKE_PRICE > quote.VALUE then 'Out the money'
                          when row1.PUTCALL='1' and row1.STRIKE_PRICE < quote.VALUE then 'In the money' 
                          when row1.PUTCALL='1' and row1.STRIKE_PRICE = quote.VALUE then 'At the money' 
                          -- 0 = Put
                          when row1.PUTCALL='0' and row1.STRIKE_PRICE > quote.VALUE then 'In the money'
                          when row1.PUTCALL='0' and row1.STRIKE_PRICE < quote.VALUE then 'Out the money'
                          when row1.PUTCALL='0' and row1.STRIKE_PRICE = quote.VALUE then 'At the money'
                          else 'N/A' end                          
                        )
          where 
          IDASSET = row1.IDASSET and 
          IDASSET_UNL = row1.IDASSET_UNL and 
          ASSETCATEGORY_UNL = row1.ASSETCATEGORY_UNL;
        end if;
    end loop;
  end;
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="POSDET_PRESELECT">
    <sqlCommand>
      <!-- 
      FI 20140428 [19746] utilisation de la table TRADE à la place de la vue VW_TRADE_POSETD 
      RD 20140717 [20206] Bug: les trades annulés (suite à une CA par exemple) sont chargés dans la consultation des postions
                          Ajout d'un inner join sur la table TRADESTSYS                                                                          
      -->
      <Command rdbms = "all">
        <![CDATA[
  /* Spheres:Hint ARITHABORT_ON NOPARAMS */
  delete from POSDET_%%SHORTSESSIONID%%_W;
  
  insert into POSDET_%%SHORTSESSIONID%%_W
  (CLIENT_IDA , POSTYPE, DATAKEYFIELD, DTBUSINESS, IDASSET, 
  IDA_DEALERORCLEARER,IDB_DEALERORCLEARER,
  IDA_COUNTERPARTY, IDB_COUNTERPARTY,
  IDT,
  SIDE,
  QTY_INITIAL,
  QTY_POS, IDM)
  select  
  arCLIENT.IDA as CLIENT_IDA,           
  rs.POSTYPE,           
  rs.DATAKEYFIELD,           
  rs.DTBUSINESS, 
  rs.IDASSET,            
  rs.IDA_DEALERORCLEARER, 
  rs.IDB_DEALERORCLEARER,                
  rs.IDA_COUNTERPARTY, 
  rs.IDB_COUNTERPARTY,
  rs.IDT,                 
  rs.SIDE,                
  rs.QTY_INITIAL, 
  rs.QTY_POS,                
  rs.IDM  
  from                
  (                
    <choose>
    <when test="{POSTYPE}=1 or {POSTYPE}=0">
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    -- ************************************************************************************************************************************************************                
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------               
    select 1 as POSTYPE,           
    '1' || '|' ||
    '%%DA:DATE1.GetDataValue()%%' || '|' || 
    convert(varchar, ti.IDASSET)   || '|' || 
    convert(varchar, ti.IDB_DEALER)|| '|' ||   
    convert(varchar, ti.IDB_CLEARER) as DATAKEYFIELD,            
    ti.IDASSET,            
    @DATE1 as DTBUSINESS,           
    ti.IDA_DEALER as IDA_DEALERORCLEARER, 
    ti.IDB_DEALER as IDB_DEALERORCLEARER,           
    ti.IDA_CLEARER as IDA_COUNTERPARTY, ti.IDB_CLEARER as IDB_COUNTERPARTY,
    t.IDT,           
    case ti.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
    floor(ti.QTY) as QTY_INITIAL,           
    ti.QTY - isnull(tas.QTY,0) - isnull(tab.QTY,0) as QTY_POS,           
    ti.IDM                
    from dbo.TRADE t                                
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = t.IDT) and (ti.INSTRUMENTNO = 1)
    %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
    inner join dbo.INSTRUMENT instrument on instrument.IDI=t.IDI
    inner join dbo.PRODUCT product on product.IDP=instrument.IDP and product.GPRODUCT = 'FUT'
    inner join dbo.TRADESTSYS tsys on (tsys.IDT = t.IDT) and (tsys.IDSTACTIVATION = 'REGULAR') and (tsys.IDSTBUSINESS = 'ALLOC')
    inner join dbo.BOOK b on b.IDB = ti.IDB_DEALER
    inner join dbo.BOOK b2 on b2.IDB = ti.IDB_CLEARER
    %%SR:TRADEALLOC_JOIN%%(t.IDT,ti,b)
    left outer join (               
      select sum(pat.QTY) as QTY, pat.IDT_SELL as IDT            
      from dbo.POSACTIONDET pat            
      inner join dbo.POSACTION pa on pa.IDPA = pat.IDPA            
      where (pa.DTBUSINESS &lt;= @DATE1)            
      and ((pat.DTCAN is null) or  (pat.DTCAN > @DATE1))            
      group by pat.IDT_SELL ) tas on (tas.IDT=t.IDT)                  

    left outer join (               
      select sum(pat.QTY) as QTY, pat.IDT_BUY as IDT            
      from dbo.POSACTIONDET pat             
      inner join dbo.POSACTION pa on pa.IDPA = pat.IDPA            
      where (pa.DTBUSINESS &lt;=  @DATE1)            
      and ((pat.DTCAN is null) or  (pat.DTCAN > @DATE1))            
      group by pat.IDT_BUY ) tab on (tab.IDT=t.IDT)                  

    where 
    (@DATE1 >= case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end)
    and (ti.QTY - isnull(tas.QTY,0) - isnull(tab.QTY,0) >0)
    and (b.ISPOSKEEPING=1)    
    and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
    and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
    </when>
    </choose>
    <choose>
    <when test="{POSTYPE}=0">
    -- ============================================================================================================================================================                
    union all                
    -- ============================================================================================================================================================                
    </when>
    </choose>
    <choose>
    <when test="{POSTYPE}=2 or {POSTYPE}=0">
    select 2 as POSTYPE,           
    '2' || '|' || 
    '%%DA:DATE1.GetDataValue()%%' || '|' || 
    convert(varchar, ti.IDASSET)   || '|' ||  
    convert(varchar, ti.IDB_CLEARER) as DATAKEYFIELD,            
    ti.IDASSET,            
    @DATE1 as DTBUSINESS,           
    ti.IDA_CLEARER as IDA_DEALERORCLEARER, 
    ti.IDB_CLEARER as IDB_DEALERORCLEARER,           
    ti.IDA_DEALER as IDA_COUNTERPARTY, ti.IDB_DEALER as IDB_COUNTERPARTY,
    t.IDT,           
    case ti.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
    floor(ti.QTY) as QTY_INITIAL,           
    ti.QTY - isnull(tas.QTY,0) - isnull(tab.QTY,0) as QTY_POS,           
    ti.IDM                
    from dbo.TRADE t                                
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = t.IDT) and (ti.INSTRUMENTNO = 1)
    %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
    inner join dbo.INSTRUMENT instrument on instrument.IDI=t.IDI
    inner join dbo.PRODUCT product on product.IDP=instrument.IDP and product.GPRODUCT = 'FUT'
    inner join dbo.TRADESTSYS tsys on (tsys.IDT = t.IDT) and (tsys.IDSTACTIVATION = 'REGULAR') and (tsys.IDSTBUSINESS = 'ALLOC')
    inner join dbo.BOOK b on b.IDB = ti.IDB_DEALER
    inner join dbo.BOOK b2 on b2.IDB = ti.IDB_CLEARER
    %%SR:TRADEALLOC_JOIN%%(t.IDT,ti,b)
    left outer join (               
      select sum(pat.QTY) as QTY, pat.IDT_SELL as IDT            
      from dbo.POSACTIONDET pat            
      inner join dbo.POSACTION pa on pa.IDPA = pat.IDPA            
      where (pa.DTBUSINESS &lt;= @DATE1)            
      and ((pat.DTCAN is null) or  (pat.DTCAN > @DATE1))           
      group by pat.IDT_SELL ) tas on (tas.IDT=t.IDT)                  

    left outer join ( 
      select sum(pat.QTY) as QTY, pat.IDT_BUY as IDT            
      from dbo.POSACTIONDET pat             
      inner join dbo.POSACTION pa on pa.IDPA = pat.IDPA            
      where (pa.DTBUSINESS &lt;=  @DATE1)
      and ((pat.DTCAN is null) or  (pat.DTCAN > @DATE1))            
      group by pat.IDT_BUY ) tab on (tab.IDT=t.IDT)                  

    where 
    (@DATE1 >= case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end)
    and (ti.QTY - isnull(tas.QTY,0) - isnull(tab.QTY,0) >0 and b.ISPOSKEEPING=1)                
    and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
    and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    -- ************************************************************************************************************************************************************                
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    </when>
    </choose>
  ) rs           
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=rs.IDA_DEALERORCLEARER)
  where rs.DATAKEYFIELD = case when 'N/A'=@FK then rs.DATAKEYFIELD else @FK end;
    ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <!--
      FI 20140428 [19746] utilisation de union ALL 
      RD 20140606 [19998] Bug: utilisation de "POSDET_" à la place de "POSSYNT_" dans la deuxième requête (union ALL) 
      -->
      <Command rdbms = "sqlserver">
        <![CDATA[
    delete from POSDETQUOTE_%%SHORTSESSIONID%%_W;
    
    insert into POSDETQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL, IDQUOTE_H, VALUE,TIME, QUOTETIMING, SOURCE,ITM_OTM)
    select asset_etd.IDASSET, assetQuoteUnl.IDASSET_UNL, assetQuoteUnl.ASSETCATEGORY_UNL,
    quote_last.IDQUOTE_H,quote_last.VALUE, quote_last.TIME,quote_last.QUOTETIMING,quote_last.SOURCE,
    case  -- 1 = Call
    when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE then 'Out the money'
    when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE then 'In the money' 
    when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE then 'At the money' 
    -- 0 = Put
    when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE then 'In the money'
    when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE then 'Out the money'
    when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE then 'At the money'
    else 'N/A' end as ITM_OTM
    from 
    (
      select asset_etd.IDASSET as IDASSET, 
					   asset_unl.IDASSET as IDASSET_UNL ,
					   'Future' as ASSETCATEGORY_UNL ,
            case 
              when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 
                then asset_etd.STRIKEPRICE
              else 
                floor(asset_etd.STRIKEPRICE) + 
                ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE)) * 
                case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
                (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
            end as STRIKE_PRICE ,
				    (
						select top 1 IDQUOTE_H
						from dbo.VW_QUOTE_H quote
						where 
						(quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') 
						and (quote.ISENABLED=1) 
						and quote.TIME < (@DATE1+1)  
						and quote.IDASSET = asset_unl.IDASSET
						and quote.ASSETCATEGORY= 'Future'
						order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose')   
																					when 'OfficialSettlement' then 0 
																					when 'OfficialClose' then 1
																					else 2 end asc	 				

				    ) as IDQUOTE_H_UNL
      from dbo.ASSET_ETD asset_etd
      inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
      inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O' and dc_asset.ASSETCATEGORY='Future'
      inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET = da_asset.IDASSET)
      inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
      inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
			where  exists (select IDASSET from POSDET_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET)
      
      union all 
    
      select asset_etd.IDASSET as IDASSET, 
      vw_asset_unl.IDASSET as IDASSET_UNL ,
      vw_asset_unl.ASSETCATEGORY as ASSETCATEGORY_UNL ,
      asset_etd.STRIKEPRICE as STRIKE_PRICE ,
      (
        select top 1 IDQUOTE_H
        from dbo.VW_QUOTE_H quote
        where 
        (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') 
        and (quote.ISENABLED=1) 
        and quote.TIME < (@DATE1+1)  
        and quote.IDASSET = vw_asset_unl.IDASSET
        and quote.ASSETCATEGORY= vw_asset_unl.ASSETCATEGORY
        order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose')   
                                        when 'OfficialSettlement' then 0 
                                        when 'OfficialClose' then 1
                                        else 2 end asc	 				

      ) as IDQUOTE_H_UNL
      from dbo.ASSET_ETD asset_etd
      inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
      inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O' and dc_asset.ASSETCATEGORY!='Future'
      inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY and vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL
      where exists (select IDASSET from POSDET_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET)
      
      
		) assetQuoteUnl
    inner join dbo.ASSET_ETD asset_etd on asset_etd.IDASSET = assetQuoteUnl.IDASSET
    inner join dbo.VW_QUOTE_H quote_last on quote_last.IDQUOTE_H = assetQuoteUnl.IDQUOTE_H_UNL and
													    quote_last.IDASSET=assetQuoteUnl.IDASSET_UNL and
													    quote_last.ASSETCATEGORY=assetQuoteUnl.ASSETCATEGORY_UNL;
    ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
  delete from POSDETQUOTE_%%SHORTSESSIONID%%_W;

  insert into POSDETQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL,IDQUOTE_H,VALUE,TIME,QUOTETIMING,SOURCE,ITM_OTM)
  select asset_etd.IDASSET as IDASSET,  vw_asset_unl.IDASSET, vw_asset_unl.ASSETCATEGORY, 
         null, null, null, null,null,null
  from dbo.ASSET_ETD asset_etd
  inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
  inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O'
  inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY and
  (
    (dc_asset.ASSETCATEGORY != 'Future' and vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL)
    or
    (dc_asset.ASSETCATEGORY = 'Future' and vw_asset_unl.IDASSET=da_asset.IDASSET)
  )
  where  exists (select IDASSET from POSDET_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET);
      ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
declare 
quote dbo.VW_QUOTE_H%ROWTYPE;
found boolean ;  

cursor c1 is
select posdetquote_w.IDASSET,posdetquote_w.IDASSET_UNL,posdetquote_w.ASSETCATEGORY_UNL,posdetquote_w.IDQUOTE_H,
asset_etd.PUTCALL,
case when posdetquote_w.ASSETCATEGORY_UNL='Future' then
  case 
    when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 
      then asset_etd.STRIKEPRICE
    else 
      floor(asset_etd.STRIKEPRICE) + 
      ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE)) * 
      case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
      (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
  end
else 
  asset_etd.STRIKEPRICE 
end as STRIKE_PRICE
from POSDETQUOTE_%%SHORTSESSIONID%%_W posdetquote_w
inner join dbo.ASSET_ETD asset_etd on asset_etd.IDASSET = posdetquote_w.IDASSET
left outer join dbo.ASSET_ETD asset_unl on (posdetquote_w.ASSETCATEGORY_UNL='Future' and asset_unl.IDASSET = posdetquote_w.IDASSET_UNL)
left outer join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
left outer join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
order by posdetquote_w.IDASSET_UNL ;

  begin
    for row1 in c1
    loop
        found:= true;
        
        begin
        select quoteLast.* into quote 
        from(
            select quote.*
            from dbo.VW_QUOTE_H quote
            where 
              (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or 
              quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement')
              and (quote.ISENABLED=1) 
              and quote.TIME < ( %%DA:DATE1.GetDataSQLValue()%% +1)
              and quote.IDASSET = row1.IDASSET_UNL
              and quote.ASSETCATEGORY = row1.ASSETCATEGORY_UNL
              and exists (select 1 from POSDETQUOTE_%%SHORTSESSIONID%%_W 
                                  where IDQUOTE_H is null and IDASSET_UNL =  row1.IDASSET_UNL and ASSETCATEGORY_UNL = row1.ASSETCATEGORY_UNL)
              order by quote.TIME desc, case nvl(quote.QUOTESIDE,'OfficialClose')   
                          when 'OfficialSettlement' then 0 
                          when 'OfficialClose' then 1
                          else 2 end asc                                     
              ) quoteLast
            where rownum = 1;
        exception
             when NO_DATA_FOUND then
              found:= false;
        end;
  
        if (found) then
          update POSDETQUOTE_%%SHORTSESSIONID%%_W 
          set IDQUOTE_H  = quote.IDQUOTE_H,
              VALUE = quote.VALUE,
              TIME = quote.TIME,
              QUOTETIMING = quote.QUOTETIMING,
              SOURCE = quote.SOURCE,
              ITM_OTM = ( case  
                          -- 1 = Call
                          when row1.PUTCALL='1' and row1.STRIKE_PRICE > quote.VALUE then 'Out the money'
                          when row1.PUTCALL='1' and row1.STRIKE_PRICE < quote.VALUE then 'In the money' 
                          when row1.PUTCALL='1' and row1.STRIKE_PRICE = quote.VALUE then 'At the money' 
                          -- 0 = Put
                          when row1.PUTCALL='0' and row1.STRIKE_PRICE > quote.VALUE then 'In the money'
                          when row1.PUTCALL='0' and row1.STRIKE_PRICE < quote.VALUE then 'Out the money'
                          when row1.PUTCALL='0' and row1.STRIKE_PRICE = quote.VALUE then 'At the money'
                          else 'N/A' end                          
                        )
          where 
          IDASSET = row1.IDASSET and 
          IDASSET_UNL = row1.IDASSET_UNL and 
          ASSETCATEGORY_UNL =row1.ASSETCATEGORY_UNL;
        end if;
    end loop;
  end;
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--
  RD 20150925 [21397] Use alias "b" and "b2" instead of respectively"bk" and "bk2"
                      script of %%SR:TRADEALLOC_WHERE_PREDICATE%% uses alias "b"
  -->
  <item name="POSDETOTC_PRESELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
  delete from POSDETOTC_%%SHORTSESSIONID%%_W;
  
  insert into POSDETOTC_%%SHORTSESSIONID%%_W
  (CLIENT_IDA , POSTYPE, POSDATETYPE, DATAKEYFIELD, DTTRADE, DTBUSINESS, DTSETTLT, DTPOS, IDASSET, ASSETCATEGORY, 
  IDA_DEALERORCLEARER,IDB_DEALERORCLEARER, IDT, SIDE, QTY_INITIAL, QTY_POS, IDM)
  select  
  arCLIENT.IDA as CLIENT_IDA, rs.POSTYPE, rs.POSDATETYPE, rs.DATAKEYFIELD, rs.DTTRADE, rs.DTBUSINESS, rs.DTSETTLT, rs.DTPOS, rs.IDASSET, rs.ASSETCATEGORY,            
  rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER, rs.IDT, rs.SIDE, rs.QTY_INITIAL, rs.QTY_POS, rs.IDM  
  from                
  (                
    <choose>
    <when test="{POSTYPE}=1 or {POSTYPE}=0">
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    -- ************************************************************************************************************************************************************                
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------               
    select 1 as POSTYPE, @POSDATETYPE as POSDATETYPE, 
    '1' || '|' || '@POSDATETYPE' || '|' || convert(varchar, ti.IDASSET)   || '|' || convert(varchar, ti.IDB_DEALER)|| '|' || convert(varchar, ti.IDB_CLEARER) as DATAKEYFIELD,            
    t.DTTRADE, t.DTBUSINESS, ti.DTSETTLT, @DATE1 as DTPOS, ti.IDASSET, ti.ASSETCATEGORY,                 
    ti.IDA_DEALER as IDA_DEALERORCLEARER, ti.IDB_DEALER as IDB_DEALERORCLEARER, 
    t.IDT, case ti.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
    ti.QTY as QTY_INITIAL, ti.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) as QTY_POS, ti.IDM                
    from dbo.TRADE t                                
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = t.IDT) and (ti.INSTRUMENTNO = 1)
    %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
    inner join dbo.VW_INSTR_PRODUCT ns on (ns.IDI=t.IDI) and (ns.GPRODUCT in ('FX','OTC','SEC'))
    inner join dbo.TRADESTSYS tsys on (tsys.IDT = t.IDT) and (tsys.IDSTACTIVATION = 'REGULAR') and (tsys.IDSTBUSINESS = 'ALLOC')
    inner join dbo.BOOK b on b.IDB = ti.IDB_DEALER
    inner join dbo.BOOK b2 on b2.IDB = ti.IDB_CLEARER
    %%SR:TRADEALLOC_JOIN%%(t.IDT,ti,b)

    /* Position en DTBUSINESS   : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTBUSINESS &lt;= DTPOS */ 
    /* Position en DTSETTLEMENT : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) &lt;= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_BUY as IDT,
      <choose>
        <when test="{POSDATETYPE}=0">
        sum(isnull(pad.QTY,0)) as QTY
        </when>
        <when test="{POSDATETYPE}=1">
        sum(case when (isnull(tib.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(tis.DTSETTLT,@DATE1) &lt;= @DATE1) then isnull(pad.QTY,0) else 0 end) as QTY
        </when>
      </choose>
      from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
		  /* Join: Pour lecture des DTSETTLT du couple IDT_BUY/IDT_SELL */ 
		  left outer join dbo.TRADEINSTRUMENT tib on (tib.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADEINSTRUMENT tis on (tis.IDT = pad.IDT_SELL) 
		  where (pa.DTBUSINESS &lt;= @DATE1) and ((pad.DTCAN is null) or (@DATE1 &lt; pad.DTCAN))
      group by pad.IDT_BUY 
      
    ) pab on (pab.IDT=t.IDT)                  

    /* Position en DTBUSINESS   : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTBUSINESS &lt;= DTPOS */ 
    /* Position en DTSETTLEMENT : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) &lt;= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_SELL as IDT,
      <choose>
        <when test="{POSDATETYPE}=0">
        sum(isnull(pad.QTY,0)) as QTY
        </when>
        <when test="{POSDATETYPE}=1">
        sum(case when (isnull(tib.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(tis.DTSETTLT,@DATE1) &lt;= @DATE1) then isnull(pad.QTY,0) else 0 end) as QTY
        </when>
      </choose>
      
      from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
		  /* Join: Pour lecture des DTSETTLT du couple IDT_BUY/IDT_SELL */ 
		  left outer join dbo.TRADEINSTRUMENT tib on (tib.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADEINSTRUMENT tis on (tis.IDT = pad.IDT_SELL) 
		  where (pa.DTBUSINESS &lt;= @DATE1) and ((pad.DTCAN is null) or (@DATE1 &lt; pad.DTCAN))
		  group by pad.IDT_SELL
      
    ) pas on (pas.IDT = t.IDT)                  

	  /* SI DTBUSINESS : DTBUSINESS (ou DTTRADE si LateTrade) &lt;= @DATE1 */
	  /* SI DTSETTLT   : DTSETTLT &lt;= DTPOSITION */
    
    where (case when @POSDATETYPE = 0 then case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end 
	      else isnull(ti.DTSETTLT, case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end) end &lt;= @DATE1) and 
        (ti.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) > 0) and (b.ISPOSKEEPING = 1) and

    (%%SR:TRADEALLOC_WHERE_PREDICATE%%) and 
    (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
    </when>
    </choose>
    
    <choose>
    <when test="{POSTYPE}=0">
    -- ============================================================================================================================================================                
    union all                
    -- ============================================================================================================================================================                
    </when>
    </choose>
    
    <choose>
    <when test="{POSTYPE}=2 or {POSTYPE}=0">
    select 2 as POSTYPE, @POSDATETYPE as POSDATETYPE,            
    '2' || '|' || '@POSDATETYPE' || '|' || convert(varchar, ti.IDASSET)   || '|' ||  convert(varchar, ti.IDB_CLEARER) as DATAKEYFIELD,            
    t.DTTRADE, t.DTBUSINESS, ti.DTSETTLT, @DATE1 as DTPOS, ti.IDASSET, ti.ASSETCATEGORY,                 
    ti.IDA_CLEARER as IDA_DEALERORCLEARER, ti.IDB_CLEARER as IDB_DEALERORCLEARER,           
    t.IDT, case ti.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
    ti.QTY as QTY_INITIAL, ti.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) as QTY_POS, ti.IDM                
    from dbo.TRADE t                                
    inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = t.IDT) and (ti.INSTRUMENTNO = 1)
    %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
    inner join dbo.VW_INSTR_PRODUCT ns on (ns.IDI=t.IDI) and (ns.GPRODUCT in ('FX','OTC','SEC'))
    inner join dbo.TRADESTSYS tsys on (tsys.IDT = t.IDT) and (tsys.IDSTACTIVATION = 'REGULAR') and (tsys.IDSTBUSINESS = 'ALLOC')
    inner join dbo.BOOK b on b.IDB = ti.IDB_DEALER
    inner join dbo.BOOK b2 on b2.IDB = ti.IDB_CLEARER
    %%SR:TRADEALLOC_JOIN%%(tr.IDT,ti,b)
  
    /* Position en DTBUSINESS   : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTBUSINESS &lt;= DTPOS */ 
    /* Position en DTSETTLEMENT : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) &lt;= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_BUY as IDT,
		  sum(case when (isnull(tib.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(tis.DTSETTLT,@DATE1) &lt;= @DATE1) or (@POSDATETYPE = 0) then isnull(pad.QTY,0) else 0 end) as QTY
		  from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
		  /* Join: Pour lecture des DTSETTLT du couple ID_BUY/IDT_SELL */ 
		  left outer join dbo.TRADEINSTRUMENT tib on (tib.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADEINSTRUMENT tis on (tis.IDT = pad.IDT_SELL) 
		  where (pa.DTBUSINESS &lt;= @DATE1) and ((pad.DTCAN is null) or (@DATE1 &lt; pad.DTCAN))
      group by pad.IDT_BUY 
      
    ) pab on (pab.IDT=t.IDT)                  

    /* Position en DTBUSINESS   : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTBUSINESS &lt;= DTPOS */ 
    /* Position en DTSETTLEMENT : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) &lt;= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_SELL as IDT,
		  sum(case when (isnull(tib.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(tis.DTSETTLT,@DATE1) &lt;= @DATE1) or (@POSDATETYPE = 0) then isnull(pad.QTY,0) else 0 end) as QTY
		  from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
		  /* Join: Pour lecture des DTSETTLT du couple ID_BUY/IDT_SELL */ 
		  left outer join dbo.TRADEINSTRUMENT tib on (tib.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADEINSTRUMENT tis on (tis.IDT = pad.IDT_SELL) 
		  where (pa.DTBUSINESS &lt;= @DATE1) and ((pad.DTCAN is null) or (@DATE1 &lt; pad.DTCAN))
		  group by pad.IDT_SELL
      
    ) pas on (pas.IDT = t.IDT)                  

	  /* SI DTBUSINESS : DTBUSINESS (ou DTTRADE si LateTrade) &lt;= @DATE1 */
	  /* SI DTSETTLT   : DTSETTLT &lt;= DTPOSITION */

    where (case when @POSDATETYPE = 0 then case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end 
	              else isnull(ti.DTSETTLT, case when @ISWITHLATETRADE = 1 then t.DTTRADE else t.DTBUSINESS end) end &lt;= @DATE1) 
    and (ti.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) > 0) 
    and (b.ISPOSKEEPING = 1) 
    and (%%SR:TRADEALLOC_WHERE_PREDICATE%%) 
    and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
  -- ************************************************************************************************************************************************************                
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
   </when>
   </choose>
  ) rs     
  
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=rs.IDA_DEALERORCLEARER)
  
  where (rs.DATAKEYFIELD = case when 'N/A' = @FK then rs.DATAKEYFIELD else @FK end);
    ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="FLOWSBYASSET_SELECT">
    <sqlCommand>
      <ConditionDynamicArg  grp="AGGREGATEDATETYPE">
        <DynamicArgValue name="AGGREGATEDATETYPE">1</DynamicArgValue>
      </ConditionDynamicArg>
      <!--
      PM 20141010 [18685] Exclude TrdType 'OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003)' from "Qty Traded" 
      PM 20150212 [20793] Add amount of events RMV in disabled date with inverted payer and receiver and always show disabled events 
      -->
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
		    NULL as DTBUSINESS,
        ar.IDA as arCLIENT_IDA, rs.ACTORSIDE, rs.IDASSET,  rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO,
		    isnull(rs.QTY_BUY,0) as QTY_BUY, isnull(rs.QTY_SELL,0) as QTY_SELL,
		    /* rs.SIDE_NET, */
        rs.UNIT, rs.PREMIUMAMOUNT, rs.CASHSETTLEMENT, rs.EQPAMOUNT, rs.VARMARGINAMOUNT, rs.UNREALMARGINAMOUNT, rs.LOVAMOUNT, rs.REALMARGINAMOUNT, 
        /* rs.FEE, */ 
        rs.FEEINCLTAXAMOUNT,rs.TAXAMOUNT,rs.FEEEXCLTAXAMOUNT,
        rs.IDM
		    from
		    (
          select /*+ ordered */
			    result.ACTORSIDE, tr.IDM, tr.IDASSET, result.IDA, result.IDB, 

          /* Exclude : OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003) */
          sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
              else (case when tr.DTBUSINESS between @DATE1 and @DATE2 then case when tr.SIDE = '1' then floor(tr.QTY) else 0 end else 0 end) end) as QTY_BUY,
          sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
              else (case when tr.DTBUSINESS between @DATE1 and @DATE2 then case when tr.SIDE = '2' then floor(tr.QTY) else 0 end else 0 end) end) as QTY_SELL,

          result.UNIT, 
			    sum(result.PREMIUMAMOUNT)      as PREMIUMAMOUNT,      sum(result.CASHSETTLEMENT)     as CASHSETTLEMENT,
			    sum(result.EQPAMOUNT)          as EQPAMOUNT,          sum(result.VARMARGINAMOUNT)    as VARMARGINAMOUNT, 
			    sum(result.UNREALMARGINAMOUNT) as UNREALMARGINAMOUNT, sum(result.LOVAMOUNT)          as LOVAMOUNT,
			    sum(result.REALMARGINAMOUNT)   as REALMARGINAMOUNT,   
          /* sum(result.FEE)                as FEE */
          sum(result.FEEINCLTAXAMOUNT)   as FEEINCLTAXAMOUNT,   sum(result.TAXAMOUNT)          as TAXAMOUNT,
          sum(result.FEEEXCLTAXAMOUNT)   as FEEEXCLTAXAMOUNT
          
			    from dbo.VW_TRADE_POSETD tr
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr,null)
          %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
			    inner join dbo.ASSET_ETD ass_etd   on (ass_etd.IDASSET=tr.IDASSET)
			    inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB=ass_etd.IDDERIVATIVEATTRIB)
			    inner join dbo.MATURITY mat        on (mat.IDMATURITY=da.IDMATURITY)
			    inner join
			    (
				    select  tr.IDM, amt.ACTORSIDE, tr.IDASSET, tr.IDT, amt.IDA, amt.IDB, amt.UNIT,   
				    sum(case amt.EVENTTYPE when 'PRM' then amt.RESULT_SIGNED else 0 end) as PREMIUMAMOUNT,
				    sum(case amt.EVENTTYPE when 'SCU' then amt.RESULT_SIGNED else 0 end) as CASHSETTLEMENT,
				    sum(case amt.EVENTTYPE when 'CSH' then amt.RESULT_SIGNED else 0 end) as EQPAMOUNT,
				    sum(case amt.EVENTTYPE when 'VMG' then amt.RESULT_SIGNED else 0 end) as VARMARGINAMOUNT,
				    sum(case amt.EVENTTYPE when 'UMG' then amt.RESULT_SIGNED else 0 end) as UNREALMARGINAMOUNT,
				    sum(case amt.EVENTTYPE when 'LOV' then amt.RESULT_SIGNED else 0 end) as LOVAMOUNT,
				    sum(case amt.EVENTTYPE when 'RMG' then amt.RESULT_SIGNED else 0 end) as REALMARGINAMOUNT,
				    /* sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) as FEE */ 
            ( sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) + sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) ) as FEEINCLTAXAMOUNT,
            sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) as TAXAMOUNT,
            sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end)  as FEEEXCLTAXAMOUNT
				    from dbo.VW_TRADE_POSETD tr
            %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
				    inner join dbo.ASSET_ETD ass_etd   on (ass_etd.IDASSET=tr.IDASSET)
				    inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB=ass_etd.IDDERIVATIVEATTRIB)
				    inner join dbo.MATURITY mat        on (mat.IDMATURITY=da.IDMATURITY)
				    left outer join
				    (
				      /* -- Type:      Dealer / Clearer */
				      /* -- Montants : OPP-xxx / STA-NOM / xxx-LOV / xxx-PRM / xxx-RMG / xxx-UMG / xxx-VMG */
					    select case ta.FIXPARTYROLE when '27' then 1 else 2 end as ACTORSIDE, ev.IDT, 
					    case ev.EVENTCODE when 'LPI' then ev.EVENTCODE when 'OPP' then 'OPP' when 'STA' then 'STA' else 'EOD' end as EVENTCODE, 
					    /* case ev.EVENTCODE when 'OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE, */
              case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE,
              ta.IDA, ta.IDB, ev.UNIT, 
					    sum(case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
                  case when ev.IDA_PAY=ta.IDA then (case ta.FIXPARTYROLE when '27' then -1 else 1 end)
							     when ev.IDA_REC=ta.IDA then (case ta.FIXPARTYROLE when '27' then 1 else -1 end)
							     else 0 end * ev.VALORISATION) as RESULT_SIGNED
					    from dbo.EVENT ev
					    inner join dbo.TRADEACTOR ta       on (ta.IDT=ev.IDT)  and (ta.IDROLEACTOR='COUNTERPARTY') and (ta.FIXPARTYROLE in ('4','21','27'))
					    inner join dbo.EVENTCLASS ec       on (ec.IDE=ev.IDE)  and ((ec.EVENTCLASS='VAL') or (ec.EVENTCLASS='RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
					    left outer join dbo.EVENTCLASS ec2 on (ec2.IDE=ec.IDE) and (ec2.EVENTCLASS='STL') and (ec2.ISPAYMENT=1)
					    left outer join dbo.EVENTPOSACTIONDET ep on (ep.IDE=ev.IDE)
					    left outer join dbo.POSACTIONDET      pa on (pa.IDPADET=ep.IDPADET) and (pa.IDT_CLOSING=ev.IDT)
					    where (
							        (ev.EVENTTYPE in ('PRM', 'VMG') and (ec2.IDE is not null)) or 
							        (ev.EVENTTYPE in ('SCU', 'CSH', 'UMG', 'LOV')) or 
							        ((ev.EVENTTYPE = 'RMG') and (pa.IDPADET is not null)) or 
							        (ev.EVENTCODE = 'OPP') 
                    )
					    group by ev.IDT, ev.UNIT, ta.IDA, ta.IDB, case ta.FIXPARTYROLE when '27' then 1 else 2 end, 
					    case ev.EVENTCODE when 'LPI' then ev.EVENTCODE when 'OPP' then 'OPP' when 'STA' then 'STA' else 'EOD' end, 
					    /* case ev.EVENTCODE when 'OPP' then 'FEE' else ev.EVENTTYPE end */
    		  		case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' 
              else ev.EVENTTYPE end
              
					    UNION ALL
    					
					    /* -- Type:      Exec */
					    /* -- Montants : OPP-xxx */
					    select 3 as ACTORSIDE, ev.IDT, 'OPP', 
              /* 'FEE', */
              case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' 
              else ev.EVENTTYPE end as EVENTTYPE,
              taexec.IDA, taexec.IDB, ev.UNIT, 
					    sum(case when (ec.EVENTCLASS='RMV') then -1 else 1 end * case when (ev.IDA_PAY=taexec.IDA) then -1 when (ev.IDA_REC=taexec.IDA) then 1 else 0 end * ev.VALORISATION) as RESULT_SIGNED
					    from dbo.EVENT ev
              inner join dbo.TRADEACTOR ta     on (ta.IDT=ev.IDT)     and (ta.IDROLEACTOR='COUNTERPARTY') and (ta.FIXPARTYROLE in ('4','21'))
              inner join dbo.TRADEACTOR taexec on (taexec.IDT=ta.IDT) and (taexec.IDROLEACTOR='BROKER')   and (taexec.IDA_ACTOR=ta.IDA)
              inner join dbo.EVENTCLASS ec     on (ec.IDE=ev.IDE)     and ((ec.EVENTCLASS='VAL') or (ec.EVENTCLASS='RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
					    where (ev.EVENTCODE = 'OPP')
    					
					    /* group by ev.IDT, ev.UNIT, taexec.IDA, taexec.IDB */
              group by ev.IDT, ev.UNIT, taexec.IDA, taexec.IDB,
              case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' 
              else ev.EVENTTYPE end
    				
				    ) amt on (amt.IDT = tr.IDT)

				    where ( (mat.MATURITYDATE>=@DATE1) or (mat.MATURITYDATE is null))
            and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
				    group by tr.IDM, tr.IDASSET, amt.IDA, amt.IDB, amt.ACTORSIDE, amt.UNIT, tr.IDT 
                			
			    ) result on (result.IDT = tr.IDT)	
    		
			    where ( (mat.MATURITYDATE>=@DATE1) or (mat.MATURITYDATE is null)) 
          and (result.ACTORSIDE = case when @ACTORSIDE = 0 then result.ACTORSIDE else @ACTORSIDE end)
          and (tr.POSKEEPBOOK_DEALER=1)
          and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
          and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
			    group by tr.IDM, tr.IDASSET, result.IDA, result.IDB, result.ACTORSIDE, result.UNIT
		    ) rs
    		
		    left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')        
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <ConditionDynamicArg  grp="AGGREGATEDATETYPE">
        <DynamicArgValue name="AGGREGATEDATETYPE">2</DynamicArgValue>
      </ConditionDynamicArg>
      <!--PM 20150212 [20793] Add amount of events RMV in disabled date with inverted payer and receiver and always show disabled events -->
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
        rs.DTBUSINESS,
        ar.IDA as arCLIENT_IDA, rs.ACTORSIDE, rs.IDASSET,  rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO,
        isnull(rs.QTY_BUY,0) as QTY_BUY, isnull(rs.QTY_SELL,0) as QTY_SELL,
        /* rs.SIDE_NET, */
        rs.UNIT, rs.PREMIUMAMOUNT, rs.CASHSETTLEMENT, rs.EQPAMOUNT, rs.VARMARGINAMOUNT, rs.UNREALMARGINAMOUNT, rs.LOVAMOUNT, rs.REALMARGINAMOUNT, 
        /* rs.FEE, */ 
        rs.FEEINCLTAXAMOUNT,rs.TAXAMOUNT,rs.FEEEXCLTAXAMOUNT,
        rs.IDM
        from
         (
          select /*+ ordered */
          result.DTBUSINESS,
          result.ACTORSIDE, tr.IDM, tr.IDASSET, result.IDA, result.IDB, 
          /* Exclude : OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003) */
          sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
          else (case when tr.DTBUSINESS between @DATE1 and @DATE2 then case when tr.SIDE = '1' then floor(tr.QTY) else 0 end else 0 end) end) as QTY_BUY,
          sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0          
          else (case when tr.DTBUSINESS between @DATE1 and @DATE2 then case when tr.SIDE = '2' then floor(tr.QTY) else 0 end else 0 end) end) as QTY_SELL,
          result.UNIT, 
          sum(result.PREMIUMAMOUNT)      as PREMIUMAMOUNT,      sum(result.CASHSETTLEMENT)     as CASHSETTLEMENT,
          sum(result.EQPAMOUNT)          as EQPAMOUNT,          sum(result.VARMARGINAMOUNT)    as VARMARGINAMOUNT, 
          sum(result.UNREALMARGINAMOUNT) as UNREALMARGINAMOUNT, sum(result.LOVAMOUNT)          as LOVAMOUNT,
          sum(result.REALMARGINAMOUNT)   as REALMARGINAMOUNT,   
          /* sum(result.FEE)                as FEE */
          sum(result.FEEINCLTAXAMOUNT)   as FEEINCLTAXAMOUNT,   sum(result.TAXAMOUNT)          as TAXAMOUNT,
          sum(result.FEEEXCLTAXAMOUNT)   as FEEEXCLTAXAMOUNT
          
          from dbo.VW_TRADE_POSETD tr
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr,null)
          %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
          
          inner join dbo.ASSET_ETD ass_etd   on (ass_etd.IDASSET=tr.IDASSET)
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB=ass_etd.IDDERIVATIVEATTRIB)
          inner join dbo.MATURITY mat        on (mat.IDMATURITY=da.IDMATURITY)
          inner join
            (
              select  
              amt.DTEVENT as DTBUSINESS,
              tr.IDM, amt.ACTORSIDE, tr.IDASSET, tr.IDT, amt.IDA, amt.IDB, amt.UNIT,   
              sum(case amt.EVENTTYPE when 'PRM' then amt.RESULT_SIGNED else 0 end) as PREMIUMAMOUNT,
              sum(case amt.EVENTTYPE when 'SCU' then amt.RESULT_SIGNED else 0 end) as CASHSETTLEMENT,
              sum(case amt.EVENTTYPE when 'CSH' then amt.RESULT_SIGNED else 0 end) as EQPAMOUNT,
              sum(case amt.EVENTTYPE when 'VMG' then amt.RESULT_SIGNED else 0 end) as VARMARGINAMOUNT,
              sum(case amt.EVENTTYPE when 'UMG' then amt.RESULT_SIGNED else 0 end) as UNREALMARGINAMOUNT,
              sum(case amt.EVENTTYPE when 'LOV' then amt.RESULT_SIGNED else 0 end) as LOVAMOUNT,
              sum(case amt.EVENTTYPE when 'RMG' then amt.RESULT_SIGNED else 0 end) as REALMARGINAMOUNT,
              /* sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) as FEE */ 
              ( sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) + sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) ) as FEEINCLTAXAMOUNT,
              sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) as TAXAMOUNT,
              sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end)  as FEEEXCLTAXAMOUNT
              from dbo.VW_TRADE_POSETD tr
              %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
              inner join dbo.ASSET_ETD ass_etd   on (ass_etd.IDASSET=tr.IDASSET)
              inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB=ass_etd.IDDERIVATIVEATTRIB)
              inner join dbo.MATURITY mat        on (mat.IDMATURITY=da.IDMATURITY)
              left outer join
                (
                  /*  Type:      Dealer / Clearer */
                  /*  Montants : OPP-xxx / STA-NOM / xxx-LOV / xxx-PRM / xxx-RMG / xxx-UMG / xxx-VMG */
                  select 
                  ec.DTEVENT, 
                  case ta.FIXPARTYROLE when '27' then 1 else 2 end as ACTORSIDE, ev.IDT, 
                  case ev.EVENTCODE when 'LPI' then ev.EVENTCODE when 'OPP' then 'OPP' when 'STA' then 'STA' else 'EOD' end as EVENTCODE, 
                  /* case ev.EVENTCODE when 'OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE, */
                  case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE,
                  ta.IDA, ta.IDB, ev.UNIT, 
                  sum(case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
                      case when (ev.IDA_PAY=ta.IDA) then (case ta.FIXPARTYROLE when '27' then -1 else 1 end)
                           when (ev.IDA_REC=ta.IDA) then (case ta.FIXPARTYROLE when '27' then 1 else -1 end)
                           else 0 end * ev.VALORISATION) as RESULT_SIGNED
                  from dbo.EVENT ev
                  inner join dbo.TRADEACTOR ta on (ta.IDT=ev.IDT) and (ta.IDROLEACTOR='COUNTERPARTY') and (ta.FIXPARTYROLE in ('4','21','27'))
                  inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (((ec.EVENTCLASS='VAL') or (ec.EVENTCLASS='RMV')) and (ec.DTEVENT between @DATE1 and @DATE2))
                  left outer join dbo.EVENTCLASS ec2       on (ec2.IDE=ec.IDE) and (ec2.EVENTCLASS='STL') and (ec2.ISPAYMENT=1)
                  left outer join dbo.EVENTPOSACTIONDET ep on (ep.IDE=ev.IDE)
                  left outer join dbo.POSACTIONDET      pa on (pa.IDPADET=ep.IDPADET) and (pa.IDT_CLOSING=ev.IDT)
                  where   (
                               (ev.EVENTTYPE in ('PRM', 'VMG') and (ec2.IDE is not null)) or 
                               (ev.EVENTTYPE in ('SCU', 'CSH', 'UMG', 'LOV')) or 
                               ((ev.EVENTTYPE = 'RMG') and (pa.IDPADET is not null)) or 
                               (ev.EVENTCODE = 'OPP') 
                          )
                                               
                  group by 
                  ec.DTEVENT,
                  ev.IDT, ev.UNIT, ta.IDA, ta.IDB, case ta.FIXPARTYROLE when '27' then 1 else 2 end, 
                  case ev.EVENTCODE when 'LPI' then ev.EVENTCODE when 'OPP' then 'OPP' when 'STA' then 'STA' else 'EOD' end, 
                  /* case ev.EVENTCODE when 'OPP' then 'FEE' else ev.EVENTTYPE end */
                  case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' 
                  else ev.EVENTTYPE end
              
                  UNION ALL
                                  
                  /*  Type:      Exec */
                  /*  Montants : OPP-xxx */
                  select 
                  ec.DTEVENT,
                  3 as ACTORSIDE, ev.IDT, 'OPP', 
                  /* 'FEE', */
                  case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' 
                  else ev.EVENTTYPE end as EVENTTYPE,
                  taexec.IDA, taexec.IDB, ev.UNIT, 
                  sum(case when ((ev.IDA_PAY=taexec.IDA) and (ec.EVENTCLASS='VAL')) or ((ev.IDA_REC=taexec.IDA) and (ec.EVENTCLASS='RMV')) then -1
                           when ((ev.IDA_REC=taexec.IDA) and (ec.EVENTCLASS='VAL')) or ((ev.IDA_PAY=taexec.IDA) and (ec.EVENTCLASS='RMV')) then 1
                           else 0 end * ev.VALORISATION) as RESULT_SIGNED
                  from dbo.EVENT ev
                  inner join dbo.TRADEACTOR ta        on (ta.IDT=ev.IDT)         and (ta.IDROLEACTOR='COUNTERPARTY') and (ta.FIXPARTYROLE in ('4','21'))
                  inner join dbo.TRADEACTOR taexec    on (taexec.IDT=ta.IDT)     and (taexec.IDROLEACTOR='BROKER')   and (taexec.IDA_ACTOR=ta.IDA)
                  inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (((ec.EVENTCLASS='VAL') or (ec.EVENTCLASS='RMV')) and (ec.DTEVENT between @DATE1 and @DATE2))
                  where (ev.EVENTCODE = 'OPP')

                  group by 
                  ec.DTEVENT,
                  ev.IDT, ev.UNIT, taexec.IDA, taexec.IDB,
                  case when ev.EVENTTYPE='TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' 
                  else ev.EVENTTYPE end
                           
                  ) amt on (amt.IDT = tr.IDT)

                 where ( (mat.MATURITYDATE>=@DATE1) or (mat.MATURITYDATE is null))
                 and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
                 group by amt.DTEVENT, tr.IDM, tr.IDASSET, amt.IDA, amt.IDB, amt.ACTORSIDE, amt.UNIT, tr.IDT 
            
          ) result on (result.IDT = tr.IDT)   
             
          where ( (mat.MATURITYDATE>=@DATE1) or (mat.MATURITYDATE is null)) 
          and (result.ACTORSIDE = case when @ACTORSIDE = 0 then result.ACTORSIDE else @ACTORSIDE end)
          and (tr.POSKEEPBOOK_DEALER=1)
          and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
          and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
          group by result.DTBUSINESS, tr.IDM, tr.IDASSET, result.IDA, result.IDB, result.ACTORSIDE, result.UNIT
      ) rs
             
      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')        
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="FLOWSBYASSETOTC_SELECT">
    <sqlCommand>
      <!-- 
      AGGREGATEDATETYPE = 1 = Displays flows on period 
      AGGREGATEDATETYPE = 2 = Displays flows day by day 
      le detail des Funding (Rate, Spread, etc.) sont affichés uniquement en mode day by day 
      Il est de plus supposé que pour une position donnée et à une date donnée x les caractérisques sont identiques (=> Usage de l'opérateur max)
      -->
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
        <choose>
          <when test ="{AGGREGATEDATETYPE}=1" >    
          NULL as DTBUSINESS, 
          </when>
          <when test ="{AGGREGATEDATETYPE}=2" >
          rs.DTEVENT as DTBUSINESS,
          </when>
        </choose>
        ar.IDA as arCLIENT_IDA, rs.POSTYPE,rs.IDM, rs.IDASSET,  rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO, rs.IDI, rs.ASSETCATEGORY,
        isnull(rs.QTY_BUY,0) as QTY_BUY, isnull(rs.QTY_SELL,0) as QTY_SELL, 
        rs.UNIT, 
        rs.FUNDINGAMOUNT, 
        <choose>
          <when test ="{AGGREGATEDATETYPE}=1" >    
               null as RATE, null as RATE_SPREAD, null as RATE_MULTIPLIER, null as RATE_ASSET_IDENT, null as RATE_ASSET_CATEGORY,
          </when>
          <when test ="{AGGREGATEDATETYPE}=2" >    
              rs.RATE, rs.RATE_SPREAD, rs.RATE_MULTIPLIER, rs.RATE_ASSET_IDENT, rs.RATE_ASSET_CATEGORY,
          </when>
        </choose>
        rs.BORROWINGAMOUNT, rs.VARMARGINAMOUNT, rs.UNREALMARGINAMOUNT, rs.REALMARGINAMOUNT, 
        rs.PRINCIPALAMOUNT, rs.ACCRUEDINTAMOUNT,rs.GROSSAMOUNT, rs.FULLCOUPONAMOUNT, 
        rs.MARKETVALUEAMOUNT,rs.MKVPRINCIPALAMOUNT,rs.MKVACCRUEDINTAMOUNT,
        rs.SAFEKEEPAMOUNT, rs.FEEINCLTAXAMOUNT,rs.TAXAMOUNT,rs.FEEEXCLTAXAMOUNT
        from
	        (
		        select /*+ ordered */
            <choose>
              <when test ="{AGGREGATEDATETYPE}=2" >
              result.DTEVENT,
              </when>
            </choose>
            result.POSTYPE, tr.IDM, tr.IDASSET, result.IDA, result.IDB, tr.IDI, tr.ASSETCATEGORY,
            
		        /* Exclude : OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003) */
		        sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
		        else (case when tr.DTBUSINESS between @DATE1 and @DATE2 then case when tr.SIDE = '1' then tr.QTY else 0 end else 0 end) end) as QTY_BUY,
		        sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
		        else (case when tr.DTBUSINESS between @DATE1 and @DATE2 then case when tr.SIDE = '2' then tr.QTY else 0 end else 0 end) end) as QTY_SELL,
		        result.UNIT, 
		        sum(result.FUNDINGAMOUNT)  as FUNDINGAMOUNT,    
            max(result.RATE) as RATE, max(result.RATE_SPREAD) as RATE_SPREAD, max(result.RATE_MULTIPLIER) as RATE_MULTIPLIER, 
            max(result.RATE_ASSET_IDENT) as RATE_ASSET_IDENT, max(result.RATE_ASSET_CATEGORY) as RATE_ASSET_CATEGORY,
            sum(result.BORROWINGAMOUNT)    as BORROWINGAMOUNT,
		        sum(result.VARMARGINAMOUNT)    as VARMARGINAMOUNT,  
            sum(result.UNREALMARGINAMOUNT) as UNREALMARGINAMOUNT,
            sum(result.MARKETVALUEAMOUNT)  as MARKETVALUEAMOUNT,
            sum(result.MKVPRINCIPALAMOUNT)  as MKVPRINCIPALAMOUNT,
            sum(result.MKVACCRUEDINTAMOUNT)  as MKVACCRUEDINTAMOUNT,
            sum(result.REALMARGINAMOUNT)   as REALMARGINAMOUNT, 
            sum(result.PRINCIPALAMOUNT)    as PRINCIPALAMOUNT, sum(result.ACCRUEDINTAMOUNT) as ACCRUEDINTAMOUNT, 
            sum(result.GROSSAMOUNT)		     as GROSSAMOUNT,
            sum(result.FULLCOUPONAMOUNT)   as FULLCOUPONAMOUNT,
            sum(result.SAFEKEEPAMOUNT)	   as SAFEKEEPAMOUNT,
		        sum(result.FEEINCLTAXAMOUNT)   as FEEINCLTAXAMOUNT, sum(result.TAXAMOUNT) as TAXAMOUNT,
		        sum(result.FEEEXCLTAXAMOUNT)   as FEEEXCLTAXAMOUNT
            from dbo.VW_TRADE_POSOTC tr
		        inner join
			            (
				            select  
                    <choose>
                      <when test ="{AGGREGATEDATETYPE}=2" >
                      amt.DTEVENT as DTEVENT,
                      </when>
                    </choose>
                    tr.IDM, amt.POSTYPE, tr.IDASSET, tr.IDT, amt.IDA, amt.IDB, tr.IDI, amt.UNIT,   
                    
                    sum(case amt.EVENTTYPE when 'FDA' then amt.RESULT_SIGNED else 0 end) as FUNDINGAMOUNT,
                    max(isnull(amt.RATE,0)) as RATE, max(isnull(amt.RATE_SPREAD,0)) as RATE_SPREAD, max(isnull(amt.RATE_MULTIPLIER,0)) as RATE_MULTIPLIER, 
                    max(isnull(amt.RATE_ASSET_IDENT,' ')) as RATE_ASSET_IDENT, max(isnull(amt.RATE_ASSET_CATEGORY,' ')) as RATE_ASSET_CATEGORY,
				            sum(case amt.EVENTTYPE when 'BWA' then amt.RESULT_SIGNED else 0 end) as BORROWINGAMOUNT,
				            sum(case amt.EVENTTYPE when 'VMG' then amt.RESULT_SIGNED else 0 end) as VARMARGINAMOUNT,
                    sum(case amt.EVENTTYPE when 'UMG' then amt.RESULT_SIGNED else 0 end) as UNREALMARGINAMOUNT,
                    sum(case amt.EVENTTYPE when 'MKV' then amt.RESULT_SIGNED else 0 end) as MARKETVALUEAMOUNT,
                    sum(case amt.EVENTTYPE when 'MKP' then amt.RESULT_SIGNED else 0 end) as MKVPRINCIPALAMOUNT,
                    sum(case amt.EVENTTYPE when 'MKA' then amt.RESULT_SIGNED else 0 end) as MKVACCRUEDINTAMOUNT,
                    sum(case amt.EVENTTYPE when 'RMG' then amt.RESULT_SIGNED else 0 end) as REALMARGINAMOUNT,
					          sum(case amt.EVENTTYPE when 'PAM' then amt.RESULT_SIGNED else 0 end) as PRINCIPALAMOUNT,
                    sum(case amt.EVENTTYPE when 'AIN' then amt.RESULT_SIGNED else 0 end) as ACCRUEDINTAMOUNT,
                    sum(case amt.EVENTTYPE when 'GAM' then amt.RESULT_SIGNED else 0 end) as GROSSAMOUNT,
                    sum(case amt.EVENTTYPE when 'INT' then amt.RESULT_SIGNED else 0 end) as FULLCOUPONAMOUNT,
					          sum(case amt.EVENTTYPE when 'SKP' then amt.RESULT_SIGNED else 0 end) as SAFEKEEPAMOUNT,
					          ( sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) + 
                      sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) ) as FEEINCLTAXAMOUNT,
					          sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) as TAXAMOUNT,
					          sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end)  as FEEEXCLTAXAMOUNT
				            from dbo.VW_TRADE_POSOTC tr
                    %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr,null)
                    %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
                    
					          left outer join
						        (
							        select 
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                        ec.DTEVENT, 
                        </when>
                      </choose>
                      case ta.FIXPARTYROLE when '27' then 1 else 2 end as POSTYPE, ev.IDT,   
                      case  when ev.EVENTCODE in ('OPP', 'STA') then  ev.EVENTCODE 
                            else 'EOD' 
                      end as EVENTCODE,
                      case  when ev.EVENTCODE='OPP' then 'FEE' 
                            else ev.EVENTTYPE 
                      end as EVENTTYPE,
                      ta.IDA, ta.IDB,
                      ev.UNIT, 
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=1" >
                          sum(
                          case when ev.EVENTTYPE in ('UMG','MKV','MKP','MKA') then
                               case when ec.DTEVENT = @DATE2 then
                                case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
					                        case when ((ev.IDA_PAY=ta.IDA) and (ta.FIXPARTYROLE='27')) then -1 else 1 end  * ev.VALORISATION
                              else 0 
                              end
                          else 
                            case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
					                        case when ((ev.IDA_PAY=ta.IDA) and (ta.FIXPARTYROLE='27')) then -1 else 1 end  * ev.VALORISATION
                          end ) as RESULT_SIGNED, 
                        </when>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                            sum(
                              case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
					                    case when ((ev.IDA_PAY=ta.IDA) and (ta.FIXPARTYROLE='27')) then -1 else 1 end  * ev.VALORISATION ) as RESULT_SIGNED, 
                        </when>
                      </choose>
                      
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=1" >
                          null as RATE, null as RATE_SPREAD, null as RATE_MULTIPLIER, 
                          null as RATE_ASSET_IDENT, null as RATE_ASSET_CATEGORY
							          </when>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                          max(isnull(fdadet.RATE,0)) as RATE, max(isnull(fdadet.SPREAD,0)) as RATE_SPREAD, max(isnull(fdadet.MULTIPLIER,0)) as RATE_MULTIPLIER, 
                          max(isnull(asset.IDENTIFIER,' ')) as RATE_ASSET_IDENT, max(isnull(asset.ASSETCATEGORY, ' ')) as RATE_ASSET_CATEGORY
							          </when>
                      </choose>
                      
                      from dbo.EVENT ev
							        inner join dbo.TRADEACTOR ta  on (ta.IDT=ev.IDT)  and (ta.IDROLEACTOR='COUNTERPARTY') 
                      <choose>
                         <when test="{POSTYPE}=1">   
                            and (ta.FIXPARTYROLE in ('27'))
                         </when>
                         <when test="{POSTYPE}=2">   
                            and (ta.FIXPARTYROLE in ('28'))
                         </when>
                         <otherwise>
                            and (ta.FIXPARTYROLE in ('27','28'))
                         </otherwise>
                      </choose>
							        inner join dbo.EVENTCLASS ec  on (ec.IDE=ev.IDE)  and ((ec.EVENTCLASS='VAL') or (ec.EVENTCLASS='RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
                      
                      left outer join dbo.EVENTPOSACTIONDET ep on (ep.IDE=ev.IDE)
							        left outer join dbo.POSACTIONDET      pa on (pa.IDPADET=ep.IDPADET) and (pa.IDT_CLOSING=ev.IDT)
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                          left outer join dbo.EVENTDET fdadet on (fdadet.IDE=ev.IDE) and (ev.EVENTTYPE='FDA')
					                left outer join dbo.EVENTASSET fdaasset on (fdaasset.IDE=fdadet.IDE) 
					                left outer join dbo.VW_ASSET asset on (asset.IDASSET=fdaasset.IDASSET) and (asset.ASSETCATEGORY=fdaasset.ASSETCATEGORY)
                        </when>
                      </choose>
                      
                      where (
							                (ev.EVENTTYPE in ('FDA', 'BWA', 'VMG', 'RMG', 'SKP','PAM','AIN','GAM','UMG','MKV','MKP','MKA')) or 
                              ((ev.EVENTTYPE = 'RMG') and (pa.IDPADET is not null)) or  /* RMG only on closing Trade */
                              ((ev.EVENTCODE = 'INT') and (ev.EVENTTYPE = 'INT')) or    /* FullCoupon for DebtSecurityTransaction */
							                (ev.EVENTCODE = 'OPP') 
						                )
                      group by     
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                        ec.DTEVENT, 
                        </when>
                      </choose>
                      ev.IDT, ev.UNIT, ta.IDA, ta.IDB, case ta.FIXPARTYROLE when '27' then 1 else 2 end, 
                      case  when ev.EVENTCODE in ('OPP', 'STA') then  ev.EVENTCODE 
                            else 'EOD' 
                      end,
                      case when ev.EVENTCODE='OPP' then 'FEE' 
                      else ev.EVENTTYPE end
			        ) amt on (amt.IDT = tr.IDT)
              where 
              (tr.POSKEEPBOOK_DEALER=1)
              and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
              and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
              group by
               <choose>
                  <when test ="{AGGREGATEDATETYPE}=2" >
                  amt.DTEVENT,
                  </when>
                </choose>
                tr.IDT, tr.IDI, tr.IDM, tr.IDASSET, tr.ASSETCATEGORY, amt.IDA, amt.IDB, amt.POSTYPE, amt.UNIT
            ) result on (result.IDT = tr.IDT)	
            
            group by
			      <choose>
              <when test ="{AGGREGATEDATETYPE}=2" >
                result.DTEVENT,
              </when>
            </choose>
            result.IDA, result.IDB, result.POSTYPE, result.UNIT, tr.IDI, tr.IDM, tr.IDASSET, tr.ASSETCATEGORY
		      ) rs
      		
		      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')        
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--EG 20130916 Réécriture -->
  <item name="FLOWSBYCURRENCY_SELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
        ar.IDA as arCLIENT_IDA, rs.ACTORSIDE, rs.DTBUSINESS, rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO, rs.UNIT, 
        
        rs.VARMARGINAMOUNT, rs.PREMIUMAMOUNT, rs.CASHSETTLEMENT, 
        rs.EQPAMOUNT, rs.INTERESTS, 
        rs.FEE, rs.MARGINCALL, rs.MARGINREQ, 
        rs.DAILYBALANCE, rs.PREVCASHBALANCE, rs.CASHTRANSFER, 
        rs.CASHBALANCE, rs.CASHFLOW, 
        rs.COLLATERAL_A, rs.COLLATERAL_U, 
        rs.PREVCASHB_CASHT,
        
        rs.MARGINREQ_PREV,
        rs.COLLATERAL_A_PREV, 
        rs.COLLATERAL_U_PREV
        
        from
        (              
          /*************************************************************************************************************************************************************
          Affichage des flux par Devise côté Dealer (Client, Maison) & Clearer
          ************************************************************************************************************************************************************ */
          select /*+ ordered */
          tr.DTBUSINESS,
          e_mgr.ACTORSIDE, e_mgr.IDA, e_mgr.IDB, e_mgr.UNIT, 

          sum(VARMARGINAMOUNT) as VARMARGINAMOUNT, sum(PREMIUMAMOUNT) as PREMIUMAMOUNT, sum(CASHSETTLEMENT) as CASHSETTLEMENT,
          sum(EQPAMOUNT) as EQPAMOUNT, sum(INTERESTS) as INTERESTS, 
          sum(FEE) as FEE, sum(MARGINCALL) as MARGINCALL, sum(MARGINREQ) as MARGINREQ, 
          sum(DAILYBALANCE) as DAILYBALANCE, sum(PREVCASHBALANCE) as PREVCASHBALANCE, sum(CASHTRANSFER) as CASHTRANSFER,
          sum(CASHBALANCE) as CASHBALANCE, sum(CASHFLOW) as CASHFLOW, 
          sum(COLLATERAL_A) as COLLATERAL_A, sum(COLLATERAL_U) as COLLATERAL_U, 
          sum(PREVCASHB_CASHT) as PREVCASHB_CASHT,
          
          sum(MARGINREQ_PREV) as MARGINREQ_PREV,
          sum(COLLATERAL_A_PREV) as COLLATERAL_A_PREV, 
          sum(COLLATERAL_U_PREV) as COLLATERAL_U_PREV

          from dbo.TRADE tr
          %%SR:TRADERISK_JOIN%%(tr.IDT,null)
          inner join dbo.INSTRUMENT i on (i.IDI=tr.IDI)
          inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashBalance')
          inner join dbo.TRADESTSYS tsys on (tsys.IDT=tr.IDT) and (tsys.IDSTACTIVATION='REGULAR')
          inner join 
          ( 
            
            <choose>
            <when test="{ACTORSIDE}=0 or {ACTORSIDE}=1 or {ACTORSIDE}=2">
          
            /* Affichage des flux par Devise côté Dealer/Clearer */ 
            select ev.IDT, ev.UNIT,
            case when ev.IDA_PAY = ti.IDA_RISK then 1 else 2 end as ACTORSIDE,
            case when ev.IDA_PAY = ti.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end as IDA,
            case when ev.IDA_PAY = ti.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end as IDB,

            sum(case amt.EVENTTYPE when 'VMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as VARMARGINAMOUNT,
            sum(case amt.EVENTTYPE when 'PRM' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREMIUMAMOUNT,
            sum(case amt.EVENTTYPE when 'SCU' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHSETTLEMENT,
            0 as EQPAMOUNT,
            0 as INTERESTS,
            sum(case amt.EVENTTYPE when 'FEE' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FEE,
            sum(case amt.EVENTTYPE when 'MGC' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARGINCALL,
            sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ,
            sum(case when amt.EVENTTYPE in ('FEE','MGC','PRM','SCU','VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as DAILYBALANCE,
            sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHBALANCE,
            sum(case amt.EVENTTYPE when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then  1 else -1 end) * amt.VALORISATION else 0 end) as CASHTRANSFER,
            sum(case amt.EVENTTYPE when 'CSB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHBALANCE,
            sum(case when amt.EVENTTYPE in ('FEE', 'PRM', 'SCU', 'VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHFLOW,
            sum(case amt.EVENTTYPE when 'CLA' then amt.VALORISATION else 0 end) as COLLATERAL_A,
            sum(case amt.EVENTTYPE when 'CLU' then amt.VALORISATION else 0 end) as COLLATERAL_U,
            sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION
                                   when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHB_CASHT,
                                   
            0 as MARGINREQ_PREV,
            0 as COLLATERAL_A_PREV,
            0 as COLLATERAL_U_PREV
            
            from dbo.EVENT ev  
            inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = ev.IDT) and (ti.INSTRUMENTNO=1)
            inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='CBS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
            left outer join
            (
              /* -- Montants : OPP-xxx / LPC-VMG / LPC-PRM / LPC-SCU / LPC-MGC / LPC-PCB / LPC-CBP / LPC-CSB / LPC-CLA / LPC-CLU */
              select ev.IDT, case ev.EVENTCODE when 'OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE, 
              ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO 
              from dbo.EVENT ev
              where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS)) 
                and (
                         (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('CBP','CLA','CLU','CSB','MGC','MGR','PCB','PRM','SCU','VMG'))
                      or (ev.EVENTCODE = 'OPP')
                     )
            ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
            where (ev.EVENTCODE='LPC') and (ev.EVENTTYPE='MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS))
            <choose>  
              <when test="{ACTORSIDE}=1">and (ev.IDA_PAY=ti.IDA_RISK)</when>
              <when test="{ACTORSIDE}=2">and (ev.IDA_REC=ti.IDA_RISK)</when>
            </choose> 
            group by ev.IDT, ev.UNIT,
                 case when ev.IDA_PAY = ti.IDA_RISK then 1 else 2 end,
                 case when ev.IDA_PAY = ti.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ti.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end
              
            union all                

            /* Affichage des flux par Devise côté Dealer/Clearer (uniquement les flux issus du trade CB précédent)*/ 
            select ev.IDT, ev.UNIT,
            case when ev.IDA_PAY = ti.IDA_RISK then 1 else 2 end as ACTORSIDE,
            case when ev.IDA_PAY = ti.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end as IDA,
            case when ev.IDA_PAY = ti.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end as IDB,

            0 as VARMARGINAMOUNT,
            0 as PREMIUMAMOUNT,
            0 as CASHSETTLEMENT,
            0 as EQPAMOUNT,
            0 as INTERESTS,
            0 as FEE,
            0 as MARGINCALL,
            0 as MARGINREQ,
            0 as DAILYBALANCE,
            0 as PREVCASHBALANCE,
            0 as CASHTRANSFER,
            0 as CASHBALANCE,
            0 as CASHFLOW,
            0 as COLLATERAL_A,
            0 as COLLATERAL_U,
            0 as PREVCASHB_CASHT,
            sum(case pamt.EVENTTYPE when 'MGR' then pamt.VALORISATION else 0 end) as MARGINREQ_PREV,
            sum(case pamt.EVENTTYPE when 'CLA' then pamt.VALORISATION else 0 end) as COLLATERAL_A_PREV,
            sum(case pamt.EVENTTYPE when 'CLU' then pamt.VALORISATION else 0 end) as COLLATERAL_U_PREV
            from dbo.EVENT ev  
            inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = ev.IDT) and (ti.INSTRUMENTNO=1)
            inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='CBS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
            left outer join 
            ( 
              /* -- Montants : LPC-MGR / LPC-CLA / LPC-CLU */
              select tlink.IDT_A as IDT, ev.EVENTTYPE, 
              ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION, 0) as VALORISATION, ev.STREAMNO 
              from dbo.EVENT ev
              inner join dbo.TRADELINK tlink on (tlink.IDT_B = ev.IDT) and (tlink.LINK = 'PrevCashBalance')
              where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS) ) 
                and (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('MGR','CLA','CLU'))
            ) pamt on (pamt.IDT = ev.IDT) and (pamt.UNIT = ev.UNIT) and (pamt.STREAMNO = ev.STREAMNO)
            where (ev.EVENTCODE='LPC') and (ev.EVENTTYPE='MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS))
            <choose>  
              <when test="{ACTORSIDE}=1"> and (ev.IDA_PAY=ti.IDA_RISK)</when>
              <when test="{ACTORSIDE}=2"> and (ev.IDA_REC=ti.IDA_RISK)</when>
            </choose>
            group by ev.IDT, ev.UNIT,
                 case when ev.IDA_PAY = ti.IDA_RISK then 1 else 2 end,
                 case when ev.IDA_PAY = ti.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ti.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end
            </when>
            </choose>
            
            <choose>
              <when test="{ACTORSIDE}=0">
              -- ============================================================================================================================================================                
              union all                
              -- ============================================================================================================================================================                
              </when>
            </choose>

            <choose>
            <when test="{ACTORSIDE}=0 or {ACTORSIDE}=3">
            /* Affichage des flux par Devise côté Executing (uniquement les flux de type OPP) */ 
            select ev.IDT, ev.UNIT, 3 as ACTORSIDE, taexec.IDA, taexec.IDB, 
            
            0 as VARMARGINAMOUNT, 
            0 as PREMIUMAMOUNT, 
            0 as CASHSETTLEMENT, 
            0 as EQPAMOUNT, 
            0 as INTERESTS,
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as FEE, 
            0 as MARGINCALL, 
            0 as MARGINREQ,
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as DAILYBALANCE, 
            0 as PREVCASHBALANCE, 
            0 as CASHTRANSFER,
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as CASHBALANCE, 
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as CASHFLOW, 
            0 as COLLATERAL_A,
            0 as COLLATERAL_U,
            0 as PREVCASHB_CASHT,            
              
            0 as MARGINREQ_PREV,
            0 as COLLATERAL_A_PREV,
            0 as COLLATERAL_U_PREV
            
            from dbo.EVENT ev  
            inner join dbo.TRADEACTOR ta        on (ta.IDT=ev.IDT)         and (ta.IDROLEACTOR='COUNTERPARTY') and (ta.FIXPARTYROLE in ('4','21'))
            inner join dbo.TRADEACTOR taexec    on (taexec.IDT=ta.IDT)     and (taexec.IDROLEACTOR='BROKER')   and (taexec.IDA_ACTOR=ta.IDA)
            inner join dbo.EVENTCLASS ec        on (ec.IDE=ev.IDE)         and (ec.EVENTCLASS='VAL')           and (ec.DTEVENT=@DTBUSINESS)

            where (ev.EVENTCODE = 'OPP') and ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS))
                
            group by ev.IDT, ev.UNIT, taexec.IDA, taexec.IDB
            
            </when>
            </choose>

          ) e_mgr on (e_mgr.IDT = tr.IDT)
        	
          where (tr.DTBUSINESS = @DTBUSINESS) 
          and (e_mgr.ACTORSIDE = case when @ACTORSIDE = 0 then e_mgr.ACTORSIDE else @ACTORSIDE end)
          and (%%SR:TRADERISK_WHERE_PREDICATE%%)
          group by tr.DTBUSINESS, e_mgr.ACTORSIDE, e_mgr.UNIT, e_mgr.IDA, e_mgr.IDB
        ) rs
        left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')    
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="RISKPERFORMANCE_SELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,            
  case when e_mgr.IDA_PAY= ti.IDA_RISK then 1 else 2  end as ACTORSIDE,            
  t.IDI,t.IDT, t.DTBUSINESS, t.DTTIMESTAMP, t.IDENTIFIER,            
  ti.IDA_RISK as IDA_MRO, ti.IDB_RISK as IDB_MRO,            
  e_mgr.VALORISATION as MARGINAMOUNT, e_mgr.UNIT as MARGINCURRENCY,            
  e_mgr.VALORISATIONSYS as MARGINAMOUNTSYS, e_mgr.UNITSYS as MARGINCURRENCYSYS,            
  case t.TIMING when 'EOD' then 'EndOfDay' else 'Intra-day' end as TIMING,             
  ta_css.IDA as IDA_CSS, ta_ent.IDA as IDA_ENTITY            
  from dbo.TRADE t 
  inner join dbo.TRADEINSTRUMENT ti on ( ti.IDT = t.IDT ) and ( ti.INSTRUMENTNO=1 )  
  inner join dbo.INSTRUMENT i on ( i.IDI=t.IDI )            
  inner join dbo.PRODUCT p on ( p.IDP=i.IDP ) and ( p.IDENTIFIER='marginRequirement' )            
  inner join dbo.TRADESTSYS tsys on ( tsys.IDT=t.IDT ) and (tsys.IDSTACTIVATION='REGULAR')            
  inner join dbo.EVENT e_mgr on e_mgr.IDT=t.IDT and e_mgr.EVENTTYPE='MGR' and e_mgr.IDSTACTIVATION = 'REGULAR'            
  inner join dbo.EVENTCLASS ec_mgr on ec_mgr.IDE=e_mgr.IDE and ec_mgr.EVENTCLASS='REC'            
  <choose>
    <when test ="{POSITIONSIDE}=1" >
      and ti.IDA_RISK = e_mgr.IDA_PAY and ti.IDB_RISK = e_mgr.IDB_PAY
    </when>
    <when test ="{POSITIONSIDE}=2" >
    and ti.IDA_RISK = e_mgr.IDA_REC and ti.IDB_RISK = e_mgr.IDB_REC
    </when>
  </choose>
  inner join dbo.TRADEACTOR ta_css on ta_css.IDROLEACTOR='CSS' and ta_css.IDT=t.IDT             
  inner join dbo.TRADEACTOR ta_ent on ta_ent.IDROLEACTOR='ENTITY' and ta_ent.IDT=t.IDT             
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ti.IDA_RISK)
  
  %%SR:TRADERISK_JOIN%%(t.IDT,ti)
  where (%%SR:TRADERISK_WHERE_PREDICATE%%)
  ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--EG 20131120 [19215] Réécriture -->
  <item name="CASHBALANCE_SELECT">
    <sqlCommand>
      <!-- Flows from ExchangeCashBalanceStream (on countervalue currency) AND CashBalanceStream (on original currency flow) -->
      <ConditionDynamicArg  grp="RESULTSTYPE">
        <DynamicArgValue name="RESULTSTYPE">0</DynamicArgValue>
      </ConditionDynamicArg>
      <Command rdbms = "all">
        <![CDATA[
  select /*+ ordered */
  ar.IDA as arCLIENT_IDA, tr.IDT, tr.IDENTIFIER, tr.DTBUSINESS, 
  rs.IDA_ENTITY,            
  rs.ACTORSIDE, rs.RESULTSTYPE,
  rs.IDA as IDA_CBO, rs.IDB as IDB_CBO, rs.UNIT, 
  rs.CASH_A, rs.CASH_U, rs.CASHBALANCE, rs.CASHFLOW, rs.CASHTRANSFER, 
  rs.COLLATERAL_A, rs.COLLATERAL_U, rs.DAILYBALANCE, rs.MARGINCALL, rs.MARGINREQ, 
  rs.PREVCASHBALANCE, rs.UNCOVERMARGINREQ, rs.FEE,rs.PREMIUM,rs.CASHSETTLEMENT,
  rs.FUNDINGAMOUNT, rs.BORROWINGAMOUNT, rs.SAFEKEEPING, 
  rs.EQUITYBALANCE, rs.FWDCASHPAYMENT, rs.EQUITYBALFWDCASH, rs.EXCESSDEFICIT, 
  rs.EXCESSDEFFWDCASH, rs.CASHDEPOSIT, rs.CASHWITHDRAWAL, rs.LONGOPTIONVALUE, rs.SHORTOPTIONVALUE,
  rs.MARKETVALUE, rs.TOTALACCOUNTVALUE, 
  rs.REALMARGIN, rs.FUTREALMARGIN, rs.OPTREALMARGIN, rs.FSOPTREALMARGIN, rs.PSOPTREALMARGIN,
  rs.UNREALMARGIN, rs.FUTUNREALMARGIN, rs.OPTUNREALMARGIN, rs.FSOPTUNREALMARGIN, rs.PSOPTUNREALMARGIN,
  rs.UNSETTLEDTRANSAC,
  rs.MARGINREQ_PREV
    
  from dbo.TRADE tr    
  %%SR:TRADERISK_JOIN%%(tr.IDT,null)
  inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)            
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.IDENTIFIER = 'cashBalance')            
  inner join dbo.TRADESTSYS tsys on (tsys.IDT = tr.IDT) and (tsys.IDSTACTIVATION = 'REGULAR')            
  
  inner join 
  ( 
      select e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB,
      
      sum(CASH_A) as CASH_A, sum(CASH_U) as CASH_U, sum(CASHBALANCE) as CASHBALANCE, sum(CASHFLOW) as CASHFLOW, sum(CASHTRANSFER) as CASHTRANSFER, 
      sum(COLLATERAL_A) as COLLATERAL_A, sum(COLLATERAL_U) as COLLATERAL_U, sum(DAILYBALANCE) as DAILYBALANCE, sum(MARGINCALL) as MARGINCALL, sum(MARGINREQ) as MARGINREQ, 
      sum(PREVCASHBALANCE) as PREVCASHBALANCE, sum(UNCOVERMARGINREQ) as UNCOVERMARGINREQ, sum(FEE) as FEE, sum(PREMIUM) as PREMIUM, sum(CASHSETTLEMENT) as CASHSETTLEMENT,
      sum(FUNDINGAMOUNT) as FUNDINGAMOUNT, sum(BORROWINGAMOUNT) as BORROWINGAMOUNT, sum(SAFEKEEPING) as SAFEKEEPING, sum(EQUITYBALANCE) as EQUITYBALANCE, sum(FWDCASHPAYMENT) as FWDCASHPAYMENT, sum(EQUITYBALFWDCASH) as EQUITYBALFWDCASH, sum(EXCESSDEFICIT) as EXCESSDEFICIT,
      sum(EXCESSDEFFWDCASH) as EXCESSDEFFWDCASH, sum(CASHDEPOSIT) as CASHDEPOSIT, sum(CASHWITHDRAWAL) as CASHWITHDRAWAL, sum(LONGOPTIONVALUE) as LONGOPTIONVALUE, sum(SHORTOPTIONVALUE) as SHORTOPTIONVALUE,
      sum(MARKETVALUE) as MARKETVALUE, sum(TOTALACCOUNTVALUE) as TOTALACCOUNTVALUE,
      sum(REALMARGIN) as REALMARGIN, sum(FUTREALMARGIN) as FUTREALMARGIN, sum(OPTREALMARGIN) as OPTREALMARGIN, sum(FSOPTREALMARGIN) as FSOPTREALMARGIN, sum(PSOPTREALMARGIN) as PSOPTREALMARGIN,
	    sum(UNREALMARGIN) as UNREALMARGIN, sum(FUTUNREALMARGIN) as FUTUNREALMARGIN, sum(OPTUNREALMARGIN) as OPTUNREALMARGIN, sum(FSOPTUNREALMARGIN) as FSOPTUNREALMARGIN, sum(PSOPTUNREALMARGIN) as PSOPTUNREALMARGIN,
      sum(UNSETTLEDTRANSAC) as UNSETTLEDTRANSAC,
	    sum(MARGINREQ_PREV) as MARGINREQ_PREV
      
      from (
        /* 
        -- Type     : Dealer / Clearer 
        -- Montants : Du Cash Balance du jour 
        */
        select ev.IDT, 
        case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end as UNIT, 
        case when ev.IDA_PAY = ta.IDA then 1 else 2 end as ACTORSIDE,
        case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end as RESULTSTYPE,
        ta_ent.IDA as IDA_ENTITY,
        case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end as IDA,
        case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
        sum(case amt.EVENTTYPE when 'CSA' then amt.VALORISATION else 0 end) as CASH_A,
        sum(case amt.EVENTTYPE when 'CSU' then amt.VALORISATION else 0 end) as CASH_U,
        sum(case amt.EVENTTYPE when 'CSB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHBALANCE,
        sum(case when amt.EVENTTYPE in ('ALLFEE', 'PRM', 'SCU', 'VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHFLOW,
        sum(case amt.EVENTTYPE when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then  1 else -1 end) * amt.VALORISATION else 0 end) as CASHTRANSFER,
        sum(case amt.EVENTTYPE when 'CLA' then amt.VALORISATION else 0 end) as COLLATERAL_A,
        sum(case amt.EVENTTYPE when 'CLU' then amt.VALORISATION else 0 end) as COLLATERAL_U,      
        sum(case when amt.EVENTTYPE in ('ALLFEE','MGC','PRM','SCU','VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as DAILYBALANCE,
        sum(case amt.EVENTTYPE when 'MGC' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARGINCALL,
        sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ,      
        sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHBALANCE,
        sum(case amt.EVENTTYPE when 'UMR' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNCOVERMARGINREQ,                                   
        sum(case amt.EVENTTYPE when 'ALLFEE' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FEE,
        sum(case amt.EVENTTYPE when 'PRM' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREMIUM,
        sum(case amt.EVENTTYPE when 'SCU' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHSETTLEMENT,
        sum(case amt.EVENTTYPE when 'FDA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUNDINGAMOUNT,
        sum(case amt.EVENTTYPE when 'BWA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as BORROWINGAMOUNT,
        sum(case amt.EVENTTYPE when 'SKP' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SAFEKEEPING,
        sum(case amt.EVENTTYPE when 'E_B' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALANCE,
        sum(case amt.EVENTTYPE when 'FCP' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as FWDCASHPAYMENT,
        sum(case amt.EVENTTYPE when 'EBF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALFWDCASH,
        sum(case amt.EVENTTYPE when 'E_D' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFICIT,
        sum(case amt.EVENTTYPE when 'EDF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFFWDCASH,
        sum(case amt.EVENTTYPE when 'CSD' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHDEPOSIT,
        sum(case amt.EVENTTYPE when 'CSW' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHWITHDRAWAL,
        sum(case amt.EVENTTYPE when 'OVL' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as LONGOPTIONVALUE,
        sum(case amt.EVENTTYPE when 'OVS' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SHORTOPTIONVALUE,
        sum(case amt.EVENTTYPE when 'MKV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARKETVALUE,
        sum(case amt.EVENTTYPE when 'TAV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as TOTALACCOUNTVALUE,
        --RMG total sans disctinction sur la CATEGORY (Future/Option) 
        sum(case amt.EVENTTYPE when 'RMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as REALMARGIN,
        --RMG sur Future uniquement
        sum(case amt.EVENTTYPE when 'FUTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTREALMARGIN,
        --RMG sur Option uniquement
        sum(case amt.EVENTTYPE when 'OPTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTREALMARGIN,
        --RMG sur Futures Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTREALMARGIN,        
        --RMG sur Premium Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTREALMARGIN,
        --UMG total sans disctinction sur la CATEGORY (Future/Option) 
        sum(case amt.EVENTTYPE when 'UMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNREALMARGIN,
        --UMG sur Future uniquement
        sum(case amt.EVENTTYPE when 'FUTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTUNREALMARGIN,
        --UMG sur Option uniquement
        sum(case amt.EVENTTYPE when 'OPTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTUNREALMARGIN,
        --UMG sur Futures Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTUNREALMARGIN,
        --UMG sur Premium Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTUNREALMARGIN,
        sum(case amt.EVENTTYPE when 'UST' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNSETTLEDTRANSAC,
        0 as MARGINREQ_PREV
        
        from dbo.EVENT ev  
        inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')		
        inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT = ev.IDT) and (ta_ent.IDROLEACTOR = 'ENTITY') 
        inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE in('CBS','ECS')) and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
        
        left outer join
        (
            select ev.IDT, 
            case when ev.EVENTCODE='OPP' then 'ALLFEE' 
                 when ev.EVENTCODE='SKP' then 'SKP' 
                 when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='RMG') then 'RMG'
                 when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='RMG') then 'FUTRMG' 	
                 when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='RMG') then 'OPTRMG' 	
                 when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='UMG') then 'UMG' 	
                 when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='UMG') then 'FUTUMG' 	
                 when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='UMG') then 'OPTUMG' 	
                 else ev.EVENTTYPE
            end as EVENTTYPE, 
            ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO,
            e_parent.EVENTCODE as EVENT_PARENT
            from dbo.EVENT ev
            inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')
            inner join dbo.EVENT e_parent on (e_parent.IDT = ev.IDT) and (e_parent.IDE=ev.IDE_EVENT)
            where ((ev.IDSTACTIVATION = 'REGULAR') or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2)) 
              and (
                       (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('CBP','CLA','CLU','CSA','CSB','CSD','CSU','CSW','E_B','E_D','EBF','EDF','FCP','FDA','BWA','MGC','MGR','MKV','OVL','OVS','PCB','PRM','RMG','SCU','TAV','UMG','UMR','UST','VMG')) 
                    or (ev.EVENTCODE in ('LFC','LOC') and ev.EVENTTYPE in ('RMG','UMG')) 
                    or (ev.EVENTCODE = 'OPP')
                    or (ev.EVENTCODE = 'SKP')
                   )
         ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2))
        group by ev.IDT, 
                 case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end,
                 case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end,
	               case when ev.IDA_PAY = ta.IDA then 1 else 2 end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end,
                 ta_ent.IDA
               
        union all
        
        /* 
        -- Type     : Dealer / Clearer 
        -- Montants : Du Cash Balance précédent 
        */
        select ev.IDT, 
        case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end as UNIT, 
        case when ev.IDA_PAY = ta.IDA then 1 else 2 end as ACTORSIDE,
        case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end as RESULTSTYPE,
        ta_ent.IDA as IDA_ENTITY,
        case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end as IDA,
        case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
        0 as CASH_A, 0 as CASH_U, 0 as CASHBALANCE, 0 as CASHFLOW, 0 as CASHTRANSFER,
        0 as COLLATERAL_A, 0 as COLLATERAL_U, 0 as DAILYBALANCE, 0 as MARGINCALL, 0 as MARGINREQ,      
        0 as PREVCASHBALANCE, 0 as UNCOVERMARGINREQ, 0 as FEE, 0 as PREMIUM, 0 as CASHSETTLEMENT,
        0 as FUNDINGAMOUNT, 0 as BORROWINGAMOUNT, 0 as SAFEKEEPING, 0 as EQUITYBALANCE, 0 as FWDCASHPAYMENT, 0 as EQUITYBALFWDCASH, 0 as EXCESSDEFICIT,
		    0 as EXCESSDEFFWDCASH, 0 as CASHDEPOSIT, 0 as CASHWITHDRAWAL, 0 as LONGOPTIONVALUE, 0 as SHORTOPTIONVALUE,
        0 as MARKETVALUE, 0 as TOTALACCOUNTVALUE,
        0 as REALMARGIN, 0 as FUTREALMARGIN, 0 as OPTREALMARGIN, 0 as FSOPTREALMARGIN, 0 as PSOPTREALMARGIN,
	      0 as UNREALMARGIN, 0 as FUTUNREALMARGIN, 0 as OPTUNREALMARGIN, 0 as FSOPTUNREALMARGIN, 0 as PSOPTUNREALMARGIN,
        0 as UNSETTLEDTRANSAC,
        sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ_PREV
        
        from dbo.EVENT ev  
        inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')		
        inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT = ev.IDT) and (ta_ent.IDROLEACTOR = 'ENTITY') 
        inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE in('CBS','ECS')) and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
        
        left outer join
        (
            /* -- Previous amount : LPC-MGR */
            select tlink.IDT_A as IDT, ev.EVENTTYPE, 
            ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT , isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO
            from dbo.EVENT ev
            inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')
            inner join dbo.TRADELINK tlink on (tlink.IDT_B = ev.IDT) and (tlink.LINK = 'PrevCashBalance')
            where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DATE2) ) 
            and (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE = 'MGR')
            
        ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        
        where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2))
        group by ev.IDT, 
                 case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end,
                 case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end,
                 case when ev.IDA_PAY = ta.IDA then 1 else 2 end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end,
                 ta_ent.IDA
    ) e_mgr
    group by e_mgr.IDT, e_mgr.RESULTSTYPE, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB
      
  ) rs on (rs.IDT = tr.IDT)    
  
  left outer join dbo.ACTORROLE ar on (ar.IDA = rs.IDA) and (ar.IDROLEACTOR='CLIENT')    
  where (rs.ACTORSIDE = case when @ACTORSIDE = 0 then rs.ACTORSIDE else @ACTORSIDE end) 
  and (tr.DTBUSINESS between @DATE1 and @DATE2) and (%%SR:TRADERISK_WHERE_PREDICATE%%)
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <!-- Flows from CashBalanceStream (on original currency flow) -->
      <ConditionDynamicArg  grp="RESULTSTYPE">
        <DynamicArgValue name="RESULTSTYPE">1</DynamicArgValue>
      </ConditionDynamicArg>
      <Command rdbms = "all">
        <![CDATA[
  select /*+ ordered */
  ar.IDA as arCLIENT_IDA, tr.IDT, tr.IDENTIFIER, tr.DTBUSINESS, 
  rs.IDA_ENTITY,            
  rs.ACTORSIDE, rs.RESULTSTYPE,
  rs.IDA as IDA_CBO, rs.IDB as IDB_CBO, rs.UNIT, 
  rs.CASH_A, rs.CASH_U, rs.CASHBALANCE, rs.CASHFLOW, rs.CASHTRANSFER, 
  rs.COLLATERAL_A, rs.COLLATERAL_U, rs.DAILYBALANCE, rs.MARGINCALL, rs.MARGINREQ, 
  rs.PREVCASHBALANCE, rs.UNCOVERMARGINREQ, rs.FEE,rs.PREMIUM,rs.CASHSETTLEMENT,
  rs.FUNDINGAMOUNT, rs.BORROWINGAMOUNT, rs.SAFEKEEPING, rs.EQUITYBALANCE, rs.FWDCASHPAYMENT, rs.EQUITYBALFWDCASH, rs.EXCESSDEFICIT, 
  rs.EXCESSDEFFWDCASH, rs.CASHDEPOSIT, rs.CASHWITHDRAWAL, rs.LONGOPTIONVALUE, rs.SHORTOPTIONVALUE, 
  rs.MARKETVALUE, rs.TOTALACCOUNTVALUE, 
  rs.REALMARGIN, rs.FUTREALMARGIN, rs.OPTREALMARGIN, rs.FSOPTREALMARGIN, rs.PSOPTREALMARGIN,
  rs.UNREALMARGIN, rs.FUTUNREALMARGIN, rs.OPTUNREALMARGIN, rs.FSOPTUNREALMARGIN, rs.PSOPTUNREALMARGIN,
  rs.UNSETTLEDTRANSAC,
  rs.MARGINREQ_PREV
    
  from dbo.TRADE tr    
  %%SR:TRADERISK_JOIN%%(tr.IDT,null)
  inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)            
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.IDENTIFIER = 'cashBalance')            
  inner join dbo.TRADESTSYS tsys on (tsys.IDT = tr.IDT) and (tsys.IDSTACTIVATION = 'REGULAR')            
  
  inner join 
  ( 
      select e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB,
      
      sum(CASH_A) as CASH_A, sum(CASH_U) as CASH_U, sum(CASHBALANCE) as CASHBALANCE, sum(CASHFLOW) as CASHFLOW, sum(CASHTRANSFER) as CASHTRANSFER,
      sum(COLLATERAL_A) as COLLATERAL_A, sum(COLLATERAL_U) as COLLATERAL_U, sum(DAILYBALANCE) as DAILYBALANCE, sum(MARGINCALL) as MARGINCALL, sum(MARGINREQ) as MARGINREQ,      
      sum(PREVCASHBALANCE) as PREVCASHBALANCE, sum(UNCOVERMARGINREQ) as UNCOVERMARGINREQ, sum(FEE) as FEE, sum(PREMIUM) as PREMIUM, sum(CASHSETTLEMENT) as CASHSETTLEMENT,
      sum(FUNDINGAMOUNT) as FUNDINGAMOUNT, sum(BORROWINGAMOUNT) as BORROWINGAMOUNT, sum(SAFEKEEPING) as SAFEKEEPING, sum(EQUITYBALANCE) as EQUITYBALANCE, sum(FWDCASHPAYMENT) as FWDCASHPAYMENT, sum(EQUITYBALFWDCASH) as EQUITYBALFWDCASH, sum(EXCESSDEFICIT) as EXCESSDEFICIT,
      sum(EXCESSDEFFWDCASH) as EXCESSDEFFWDCASH, sum(CASHDEPOSIT) as CASHDEPOSIT, sum(CASHWITHDRAWAL) as CASHWITHDRAWAL, sum(LONGOPTIONVALUE) as LONGOPTIONVALUE, sum(SHORTOPTIONVALUE) as SHORTOPTIONVALUE,
      sum(MARKETVALUE) as MARKETVALUE, sum(TOTALACCOUNTVALUE) as TOTALACCOUNTVALUE,
      sum(REALMARGIN) as REALMARGIN, sum(FUTREALMARGIN) as FUTREALMARGIN, sum(OPTREALMARGIN) as OPTREALMARGIN, sum(FSOPTREALMARGIN) as FSOPTREALMARGIN, sum(PSOPTREALMARGIN) as PSOPTREALMARGIN,
	    sum(UNREALMARGIN) as UNREALMARGIN, sum(FUTUNREALMARGIN) as FUTUNREALMARGIN, sum(OPTUNREALMARGIN) as OPTUNREALMARGIN, sum(FSOPTUNREALMARGIN) as FSOPTUNREALMARGIN, sum(PSOPTUNREALMARGIN) as PSOPTUNREALMARGIN,
      sum(UNSETTLEDTRANSAC) as UNSETTLEDTRANSAC,
	    sum(MARGINREQ_PREV) as MARGINREQ_PREV
      
      from (
        /* 
        -- Type     : Dealer / Clearer 
        -- Montants : Du Cash Balance du jour 
        */
        select ev.IDT, ev.UNIT, 
        case when ev.IDA_PAY = ta.IDA then 1 else 2 end as ACTORSIDE,
        case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end as RESULTSTYPE,
        ta_ent.IDA as IDA_ENTITY,
        case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end as IDA,
        case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
        sum(case amt.EVENTTYPE when 'CSA' then amt.VALORISATION else 0 end) as CASH_A,
        sum(case amt.EVENTTYPE when 'CSU' then amt.VALORISATION else 0 end) as CASH_U,
        sum(case amt.EVENTTYPE when 'CSB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHBALANCE,
        sum(case when amt.EVENTTYPE in ('ALLFEE', 'PRM', 'SCU', 'VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHFLOW,
        sum(case amt.EVENTTYPE when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then  1 else -1 end) * amt.VALORISATION else 0 end) as CASHTRANSFER,
        sum(case amt.EVENTTYPE when 'CLA' then amt.VALORISATION else 0 end) as COLLATERAL_A,
        sum(case amt.EVENTTYPE when 'CLU' then amt.VALORISATION else 0 end) as COLLATERAL_U,      
        sum(case when amt.EVENTTYPE in ('ALLFEE','MGC','PRM','SCU','VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as DAILYBALANCE,
        sum(case amt.EVENTTYPE when 'MGC' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARGINCALL,
        sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ,      
        sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHBALANCE,
        sum(case amt.EVENTTYPE when 'UMR' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNCOVERMARGINREQ,                                   
        sum(case amt.EVENTTYPE when 'ALLFEE' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FEE,
        sum(case amt.EVENTTYPE when 'PRM' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREMIUM,
        sum(case amt.EVENTTYPE when 'SCU' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHSETTLEMENT,
        sum(case amt.EVENTTYPE when 'FDA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUNDINGAMOUNT,
        sum(case amt.EVENTTYPE when 'BWA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as BORROWINGAMOUNT,
        sum(case amt.EVENTTYPE when 'SKP' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SAFEKEEPING,
        sum(case amt.EVENTTYPE when 'E_B' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALANCE,
        sum(case amt.EVENTTYPE when 'FCP' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as FWDCASHPAYMENT,
        sum(case amt.EVENTTYPE when 'EBF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALFWDCASH,
        sum(case amt.EVENTTYPE when 'E_D' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFICIT,
        sum(case amt.EVENTTYPE when 'EDF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFFWDCASH,
        sum(case amt.EVENTTYPE when 'CSD' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHDEPOSIT,
        sum(case amt.EVENTTYPE when 'CSW' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHWITHDRAWAL,
        sum(case amt.EVENTTYPE when 'OVL' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as LONGOPTIONVALUE,
        sum(case amt.EVENTTYPE when 'OVS' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SHORTOPTIONVALUE,
        sum(case amt.EVENTTYPE when 'MKV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARKETVALUE,
        sum(case amt.EVENTTYPE when 'TAV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as TOTALACCOUNTVALUE,
        --RMG total sans disctinction sur la CATEGORY (Future/Option) 
        sum(case amt.EVENTTYPE when 'RMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as REALMARGIN,
        --RMG sur Future uniquement
        sum(case amt.EVENTTYPE when 'FUTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTREALMARGIN,
        --RMG sur Option uniquement
        sum(case amt.EVENTTYPE when 'OPTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTREALMARGIN,
        --RMG sur Futures Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTREALMARGIN,        
        --RMG sur Premium Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTREALMARGIN,
        --UMG total sans disctinction sur la CATEGORY (Future/Option) 
        sum(case amt.EVENTTYPE when 'UMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNREALMARGIN,
        --UMG sur Future uniquement
        sum(case amt.EVENTTYPE when 'FUTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTUNREALMARGIN,
        --UMG sur Option uniquement
        sum(case amt.EVENTTYPE when 'OPTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTUNREALMARGIN,
        --UMG sur Futures Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTUNREALMARGIN,
        --UMG sur Premium Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTUNREALMARGIN,
        sum(case amt.EVENTTYPE when 'UST' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNSETTLEDTRANSAC,
        0 as MARGINREQ_PREV
        
        from dbo.EVENT ev  
        inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')		
        inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT = ev.IDT) and (ta_ent.IDROLEACTOR = 'ENTITY') 
        inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='CBS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
        
        left outer join
        (
            select ev.IDT, 
            case when ev.EVENTCODE='OPP' then 'ALLFEE' 
                 when ev.EVENTCODE='SKP' then 'SKP' 
                 when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='RMG') then 'RMG'
                 when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='RMG') then 'FUTRMG' 	
                 when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='RMG') then 'OPTRMG' 	
                 when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='UMG') then 'UMG' 	
                 when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='UMG') then 'FUTUMG' 	
                 when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='UMG') then 'OPTUMG' 	
                 else ev.EVENTTYPE
            end as EVENTTYPE, 
            ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO, e_parent.EVENTCODE as EVENT_PARENT
            from dbo.EVENT ev
            inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')
            inner join dbo.EVENT e_parent on (e_parent.IDT = ev.IDT) and (e_parent.IDE=ev.IDE_EVENT)
            where ((ev.IDSTACTIVATION = 'REGULAR') or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2)) 
              and (
                       (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('CBP','CLA','CLU','CSA','CSB','CSD','CSU','CSW','E_B','E_D','EBF','EDF','FCP','FDA','BWA','MGC','MGR','MKV','OVL','OVS','PCB','PRM','RMG','SCU','TAV','UMG','UMR','UST','VMG')) 
                    or (ev.EVENTCODE in ('LFC','LOC') and ev.EVENTTYPE in ('RMG','UMG')) 
                    or (ev.EVENTCODE = 'OPP')
                    or (ev.EVENTCODE = 'SKP')
                   )
         ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2))
        group by ev.IDT, ev.UNIT,
	               case when ev.IDA_PAY = ta.IDA then 1 else 2 end,
                 case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end,
	               case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end,
                 ta_ent.IDA
               
        union all
        
         /* 
        -- Type     : Dealer / Clearer 
        -- Montants : Du Cash Balance précédent 
        */
        select ev.IDT, ev.UNIT, 
        case when ev.IDA_PAY = ta.IDA then 1 else 2 end as ACTORSIDE,
        case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end as RESULTSTYPE,
        ta_ent.IDA as IDA_ENTITY,
        case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end as IDA,
        case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
        0 as CASH_A, 0 as CASH_U, 0 as CASHBALANCE, 0 as CASHFLOW, 0 as CASHTRANSFER,
        0 as COLLATERAL_A, 0 as COLLATERAL_U, 0 as DAILYBALANCE, 0 as MARGINCALL, 0 as MARGINREQ,      
        0 as PREVCASHBALANCE, 0 as UNCOVERMARGINREQ, 0 as FEE, 0 as PREMIUM, 0 as CASHSETTLEMENT,
        0 as FUNDINGAMOUNT, 0 as BORROWINGAMOUNT, 0 as SAFEKEEPING, 0 as EQUITYBALANCE, 0 as FWDCASHPAYMENT, 0 as EQUITYBALFWDCASH, 0 as EXCESSDEFICIT,
		    0 as EXCESSDEFFWDCASH, 0 as CASHDEPOSIT, 0 as CASHWITHDRAWAL, 0 as LONGOPTIONVALUE, 0 as SHORTOPTIONVALUE,
        0 as MARKETVALUE, 0 as TOTALACCOUNTVALUE,
        0 as REALMARGIN, 0 as FUTREALMARGIN, 0 as OPTREALMARGIN, 0 as FSOPTREALMARGIN, 0 as PSOPTREALMARGIN,
	      0 as UNREALMARGIN, 0 as FUTUNREALMARGIN, 0 as OPTUNREALMARGIN, 0 as FSOPTUNREALMARGIN, 0 as PSOPTUNREALMARGIN,
        0 as UNSETTLEDTRANSAC,
        sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ_PREV
        
        from dbo.EVENT ev  
        inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')		
        inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT = ev.IDT) and (ta_ent.IDROLEACTOR = 'ENTITY') 
        inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='CBS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
        
        left outer join
        (
            /* -- Previous amount : LPC-MGR */
            select tlink.IDT_A as IDT, ev.EVENTTYPE, 
            ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT , isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO
            from dbo.EVENT ev
            inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')
            inner join dbo.TRADELINK tlink on (tlink.IDT_B = ev.IDT) and (tlink.LINK = 'PrevCashBalance')
            where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DATE2) ) 
            and (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE = 'MGR')
            
        ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        
        where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2))
        group by ev.IDT, ev.UNIT,
	               case when ev.IDA_PAY = ta.IDA then 1 else 2 end,
                 case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end,
	               case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end,
                 ta_ent.IDA
    ) e_mgr
    group by e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB
      
  ) rs on (rs.IDT = tr.IDT)    
  
  left outer join dbo.ACTORROLE ar on (ar.IDA = rs.IDA) and (ar.IDROLEACTOR='CLIENT')    
  where (rs.ACTORSIDE = case when @ACTORSIDE = 0 then rs.ACTORSIDE else @ACTORSIDE end) 
  and (tr.DTBUSINESS between @DATE1 and @DATE2) and (%%SR:TRADERISK_WHERE_PREDICATE%%)
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <!-- Flows from ExchangeCashBalanceStream (on countervalue currency) -->
      <ConditionDynamicArg  grp="RESULTSTYPE">
        <DynamicArgValue name="RESULTSTYPE">2</DynamicArgValue>
      </ConditionDynamicArg>
      <Command rdbms = "all">
        <![CDATA[
  select /*+ ordered */
  ar.IDA as arCLIENT_IDA, tr.IDT, tr.IDENTIFIER, tr.DTBUSINESS, 
  rs.IDA_ENTITY,            
  rs.ACTORSIDE, rs.RESULTSTYPE,
  rs.IDA as IDA_CBO, rs.IDB as IDB_CBO, rs.UNIT, 
  rs.CASH_A, rs.CASH_U, rs.CASHBALANCE, rs.CASHFLOW, rs.CASHTRANSFER, 
  rs.COLLATERAL_A, rs.COLLATERAL_U, rs.DAILYBALANCE, rs.MARGINCALL, rs.MARGINREQ, 
  rs.PREVCASHBALANCE, rs.UNCOVERMARGINREQ, rs.FEE,rs.PREMIUM,rs.CASHSETTLEMENT,
  rs.FUNDINGAMOUNT, rs.BORROWINGAMOUNT, rs.SAFEKEEPING, rs.EQUITYBALANCE, rs.FWDCASHPAYMENT, rs.EQUITYBALFWDCASH, rs.EXCESSDEFICIT, 
  rs.EXCESSDEFFWDCASH, rs.CASHDEPOSIT, rs.CASHWITHDRAWAL, rs.LONGOPTIONVALUE, rs.SHORTOPTIONVALUE,
  rs.MARKETVALUE, rs.TOTALACCOUNTVALUE, 
  rs.REALMARGIN, rs.FUTREALMARGIN, rs.OPTREALMARGIN, rs.FSOPTREALMARGIN, rs.PSOPTREALMARGIN,
  rs.UNREALMARGIN, rs.FUTUNREALMARGIN, rs.OPTUNREALMARGIN, rs.FSOPTUNREALMARGIN, rs.PSOPTUNREALMARGIN,
  rs.UNSETTLEDTRANSAC,
  rs.MARGINREQ_PREV
    
  from dbo.TRADE tr    
  %%SR:TRADERISK_JOIN%%(tr.IDT,null)
  inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)            
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.IDENTIFIER = 'cashBalance')            
  inner join dbo.TRADESTSYS tsys on (tsys.IDT = tr.IDT) and (tsys.IDSTACTIVATION = 'REGULAR')            
  
  inner join 
  ( 
      select e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB,
      
      sum(CASH_A) as CASH_A, sum(CASH_U) as CASH_U, sum(CASHBALANCE) as CASHBALANCE, sum(CASHFLOW) as CASHFLOW, sum(CASHTRANSFER) as CASHTRANSFER,
      sum(COLLATERAL_A) as COLLATERAL_A, sum(COLLATERAL_U) as COLLATERAL_U, sum(DAILYBALANCE) as DAILYBALANCE, sum(MARGINCALL) as MARGINCALL, sum(MARGINREQ) as MARGINREQ,      
      sum(PREVCASHBALANCE) as PREVCASHBALANCE, sum(UNCOVERMARGINREQ) as UNCOVERMARGINREQ, sum(FEE) as FEE, sum(PREMIUM) as PREMIUM, sum(CASHSETTLEMENT) as CASHSETTLEMENT,
      sum(FUNDINGAMOUNT) as FUNDINGAMOUNT, sum(BORROWINGAMOUNT) as BORROWINGAMOUNT, sum(SAFEKEEPING) as SAFEKEEPING, sum(EQUITYBALANCE) as EQUITYBALANCE, sum(FWDCASHPAYMENT) as FWDCASHPAYMENT, sum(EQUITYBALFWDCASH) as EQUITYBALFWDCASH, sum(EXCESSDEFICIT) as EXCESSDEFICIT,
      sum(EXCESSDEFFWDCASH) as EXCESSDEFFWDCASH, sum(CASHDEPOSIT) as CASHDEPOSIT, sum(CASHWITHDRAWAL) as CASHWITHDRAWAL, sum(LONGOPTIONVALUE) as LONGOPTIONVALUE, sum(SHORTOPTIONVALUE) as SHORTOPTIONVALUE,
      sum(MARKETVALUE) as MARKETVALUE, sum(TOTALACCOUNTVALUE) as TOTALACCOUNTVALUE,
      sum(REALMARGIN) as REALMARGIN, sum(FUTREALMARGIN) as FUTREALMARGIN, sum(OPTREALMARGIN) as OPTREALMARGIN, sum(FSOPTREALMARGIN) as FSOPTREALMARGIN, sum(PSOPTREALMARGIN) as PSOPTREALMARGIN,
	    sum(UNREALMARGIN) as UNREALMARGIN, sum(FUTUNREALMARGIN) as FUTUNREALMARGIN, sum(OPTUNREALMARGIN) as OPTUNREALMARGIN, sum(FSOPTUNREALMARGIN) as FSOPTUNREALMARGIN, sum(PSOPTUNREALMARGIN) as PSOPTUNREALMARGIN,
      sum(UNSETTLEDTRANSAC) as UNSETTLEDTRANSAC,
	    sum(MARGINREQ_PREV) as MARGINREQ_PREV
      
      from (
        /* 
        -- Type     : Dealer / Clearer 
        -- Montants : Du Cash Balance du jour 
        */
        select ev.IDT, 
        case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end as UNIT,
        case when ev.IDA_PAY = ta.IDA then 1 else 2 end as ACTORSIDE,
        case when e_stream.EVENTCODE = 'ECS' then 2 else 1 end as RESULTSTYPE,
        ta_ent.IDA as IDA_ENTITY,
        case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end as IDA,
        case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
        sum(case amt.EVENTTYPE when 'CSA' then amt.VALORISATION else 0 end) as CASH_A,
        sum(case amt.EVENTTYPE when 'CSU' then amt.VALORISATION else 0 end) as CASH_U,
        sum(case amt.EVENTTYPE when 'CSB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHBALANCE,
        sum(case when amt.EVENTTYPE in ('ALLFEE', 'PRM', 'SCU', 'VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHFLOW,
        sum(case amt.EVENTTYPE when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then  1 else -1 end) * amt.VALORISATION else 0 end) as CASHTRANSFER,
        sum(case amt.EVENTTYPE when 'CLA' then amt.VALORISATION else 0 end) as COLLATERAL_A,
        sum(case amt.EVENTTYPE when 'CLU' then amt.VALORISATION else 0 end) as COLLATERAL_U,      
        sum(case when amt.EVENTTYPE in ('ALLFEE','MGC','PRM','SCU','VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as DAILYBALANCE,
        sum(case amt.EVENTTYPE when 'MGC' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARGINCALL,
        sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ,      
        sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHBALANCE,
        sum(case amt.EVENTTYPE when 'UMR' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNCOVERMARGINREQ,                                   
        sum(case amt.EVENTTYPE when 'ALLFEE' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FEE,
        sum(case amt.EVENTTYPE when 'PRM' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREMIUM,
        sum(case amt.EVENTTYPE when 'SCU' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHSETTLEMENT,
        sum(case amt.EVENTTYPE when 'FDA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUNDINGAMOUNT,
        sum(case amt.EVENTTYPE when 'BWA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as BORROWINGAMOUNT,
        sum(case amt.EVENTTYPE when 'SKP' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SAFEKEEPING,
        sum(case amt.EVENTTYPE when 'E_B' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALANCE,
        sum(case amt.EVENTTYPE when 'FCP' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as FWDCASHPAYMENT,
        sum(case amt.EVENTTYPE when 'EBF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALFWDCASH,
        sum(case amt.EVENTTYPE when 'E_D' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFICIT,
        sum(case amt.EVENTTYPE when 'EDF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFFWDCASH,
        sum(case amt.EVENTTYPE when 'CSD' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHDEPOSIT,
        sum(case amt.EVENTTYPE when 'CSW' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHWITHDRAWAL,
        sum(case amt.EVENTTYPE when 'OVL' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as LONGOPTIONVALUE,
        sum(case amt.EVENTTYPE when 'OVS' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SHORTOPTIONVALUE,
        sum(case amt.EVENTTYPE when 'MKV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARKETVALUE,
        sum(case amt.EVENTTYPE when 'TAV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as TOTALACCOUNTVALUE,
        --RMG total sans disctinction sur la CATEGORY (Future/Option) 
        sum(case amt.EVENTTYPE when 'RMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as REALMARGIN,
        --RMG sur Future uniquement
        sum(case amt.EVENTTYPE when 'FUTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTREALMARGIN,
        --RMG sur Option uniquement
        sum(case amt.EVENTTYPE when 'OPTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTREALMARGIN,
        --RMG sur Futures Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTREALMARGIN,        
        --RMG sur Premium Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTREALMARGIN,
        --UMG total sans disctinction sur la CATEGORY (Future/Option) 
        sum(case amt.EVENTTYPE when 'UMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNREALMARGIN,
        --UMG sur Future uniquement
        sum(case amt.EVENTTYPE when 'FUTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTUNREALMARGIN,
        --UMG sur Option uniquement
        sum(case amt.EVENTTYPE when 'OPTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTUNREALMARGIN,
        --UMG sur Futures Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTUNREALMARGIN,
        --UMG sur Premium Style Option uniquement
        sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTUNREALMARGIN,
        sum(case amt.EVENTTYPE when 'UST' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNSETTLEDTRANSAC,
        0 as MARGINREQ_PREV
        
        from dbo.EVENT ev  
        inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')		
        inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT = ev.IDT) and (ta_ent.IDROLEACTOR = 'ENTITY') 
        inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='ECS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
        
        left outer join 
        (
            select ev.IDT, 
            case when ev.EVENTCODE='OPP' then 'ALLFEE' 
                 when ev.EVENTCODE='SKP' then 'SKP' 
                 when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='RMG') then 'RMG'
                 when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='RMG') then 'FUTRMG' 	
                 when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='RMG') then 'OPTRMG' 	
                 when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='UMG') then 'UMG' 	
                 when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='UMG') then 'FUTUMG' 	
                 when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='UMG') then 'OPTUMG' 	
                 else ev.EVENTTYPE
            end as EVENTTYPE, 
            ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO, e_parent.EVENTCODE as EVENT_PARENT
            from dbo.EVENT ev
            inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')
            inner join dbo.EVENT e_parent on (e_parent.IDT = ev.IDT) and (e_parent.IDE=ev.IDE_EVENT)
            where ((ev.IDSTACTIVATION = 'REGULAR') or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2)) 
              and (
                       (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('CBP','CLA','CLU','CSA','CSB','CSD','CSU','CSW','E_B','E_D','EBF','EDF','FCP','FDA','BWA','MGC','MGR','MKV','OVL','OVS','PCB','PRM','RMG','SCU','TAV','UMG','UMR','UST','VMG')) 
                    or (ev.EVENTCODE in ('LFC','LOC') and ev.EVENTTYPE in ('RMG','UMG')) 
                    or (ev.EVENTCODE = 'OPP')
                    or (ev.EVENTCODE = 'SKP')
                   )
         ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2))
        group by ev.IDT, 
                 case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end,
	               case when ev.IDA_PAY = ta.IDA then 1 else 2 end,
                 case when e_stream.EVENTCODE = 'ECS' then 2 else 1 end,
	               case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end,
                 ta_ent.IDA
               
        union all
        
         /* 
        -- Type     : Dealer / Clearer 
        -- Montants : Du Cash Balance précédent 
        */
        select ev.IDT, 
        case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end as UNIT, 
        case when ev.IDA_PAY = ta.IDA then 1 else 2 end as ACTORSIDE,
        case when e_stream.EVENTCODE = 'ECS' then 2 else 1 end as RESULTSTYPE,
        ta_ent.IDA as IDA_ENTITY,
        case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end as IDA,
        case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
        0 as CASH_A, 0 as CASH_U, 0 as CASHBALANCE, 0 as CASHFLOW, 0 as CASHTRANSFER,
        0 as COLLATERAL_A, 0 as COLLATERAL_U, 0 as DAILYBALANCE, 0 as MARGINCALL, 0 as MARGINREQ,      
        0 as PREVCASHBALANCE, 0 as UNCOVERMARGINREQ, 0 as FEE, 0 as PREMIUM, 0 as CASHSETTLEMENT,
        0 as FUNDINGAMOUNT, 0 as BORROWINGAMOUNT, 0 as SAFEKEEPING, 0 as EQUITYBALANCE, 0 as FWDCASHPAYMENT, 0 as EQUITYBALFWDCASH, 0 as EXCESSDEFICIT,
		    0 as EXCESSDEFFWDCASH, 0 as CASHDEPOSIT, 0 as CASHWITHDRAWAL, 0 as LONGOPTIONVALUE, 0 as SHORTOPTIONVALUE,
        0 as MARKETVALUE, 0 as TOTALACCOUNTVALUE,
        0 as REALMARGIN, 0 as FUTREALMARGIN, 0 as OPTREALMARGIN, 0 as FSOPTREALMARGIN, 0 as PSOPTREALMARGIN,
	      0 as UNREALMARGIN, 0 as FUTUNREALMARGIN, 0 as OPTUNREALMARGIN, 0 as FSOPTUNREALMARGIN, 0 as PSOPTUNREALMARGIN,
        0 as UNSETTLEDTRANSAC,
        sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ_PREV
        
        from dbo.EVENT ev  
        inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')		
        inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT = ev.IDT) and (ta_ent.IDROLEACTOR = 'ENTITY') 
        inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='ECS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
        
        left outer join
        (
            /* -- Previous amount : LPC-MGR */
            select tlink.IDT_A as IDT, ev.EVENTTYPE, 
            ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT , isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO
            from dbo.EVENT ev
            inner join dbo.TRADEACTOR ta on (ta.IDT = ev.IDT) and (ta.IDROLEACTOR = 'CSHBALANCEOFFICE')
            inner join dbo.TRADELINK tlink on (tlink.IDT_B = ev.IDT) and (tlink.LINK = 'PrevCashBalance')
            where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DATE2) ) 
            and (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE = 'MGR')
            
        ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        
        where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2))
        group by ev.IDT, 
                 case e_stream.EVENTCODE when 'ECS' then ev.UNIT || ' ' || '(Basis)' else ev.UNIT end,
	               case when ev.IDA_PAY = ta.IDA then 1 else 2 end,
                 case when e_stream.EVENTCODE = 'ECS' then 2 else 1 end,
	               case when ev.IDA_PAY = ta.IDA then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = ta.IDA then ev.IDB_PAY else ev.IDB_REC end,
                 ta_ent.IDA
    ) e_mgr
    group by e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB
      
  ) rs on (rs.IDT = tr.IDT)    
  
  left outer join dbo.ACTORROLE ar on (ar.IDA = rs.IDA) and (ar.IDROLEACTOR='CLIENT')    
  where (rs.ACTORSIDE = case when @ACTORSIDE = 0 then rs.ACTORSIDE else @ACTORSIDE end) 
  and (tr.DTBUSINESS between @DATE1 and @DATE2) and (%%SR:TRADERISK_WHERE_PREDICATE%%)
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="CASHPAYMENT_SELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,
  case when arCLEARER.IDA is null then 1 else 2 end as ACTORSIDE,
  t.IDT, t.IDENTIFIER, t.DTTRADE, t.DTTIMESTAMP, t.DISPLAYNAME, t.DESCRIPTION, t.EXTLLINK, t.SOURCE,
  ti.TRDTYPE,
  case when e.IDA_PAY = ta_cp.IDA then e.IDA_PAY else e.IDA_REC end as IDA,            
  case when e.IDA_PAY = ta_cp.IDA then e.IDB_PAY else e.IDB_REC end as IDB,            
  ta_ent.IDA as IDA_ENTITY,            
  e.EVENTTYPE, e.UNIT,            
  case when arCLEARER.IDA is null then isnull(case when e.IDA_PAY = ta_cp.IDA then +1 else -1 end * e.VALORISATION, 0)
       else isnull(case when e.IDA_PAY = arCLEARER.IDA then -1 else +1 end * e.VALORISATION, 0) end 
  as VALORISATION, 
  ec.DTEVENT
  from dbo.TRADE t    
  %%SR:TRADERISK_JOIN%%(t.IDT,null)
  inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=t.IDT)
  inner join dbo.INSTRUMENT i on (i.IDI=t.IDI)            
  inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashPayment')            
  inner join dbo.TRADESTSYS tsys on (tsys.IDT=t.IDT) and (tsys.IDSTACTIVATION='REGULAR')
  inner join dbo.EVENT e on (e.IDT=t.IDT) and (e.EVENTCODE='STA') and (e.IDSTACTIVATION='REGULAR')
  inner join dbo.EVENTCLASS ec on (ec.IDE=e.IDE) and (ec.EVENTCLASS='STL')
  inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT=t.IDT) and (ta_ent.IDROLEACTOR='ENTITY')
  inner join dbo.TRADEACTOR ta_cp on (ta_cp.IDT=t.IDT) and (ta_cp.IDROLEACTOR='COUNTERPARTY') and (ta_cp.IDA!=ta_ent.IDA) 
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ta_cp.IDA)
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR in ('CLEARER','CCLEARINGCOMPART','HCLEARINGCOMPART','MCLEARINGCOMPART'))) arCLEARER on arCLEARER.IDA=ta_cp.IDA
  
  where (1=1)
  <choose>
    <when test ="{POSITIONSIDE}=1"> 
     and (arCLEARER.IDA is null)
    </when>
    <when test ="{POSITIONSIDE}=2"> 
     and (arCLEARER.IDA is not null)
    </when>
  </choose>
  and (%%SR:TRADERISK_WHERE_PREDICATE%%)  
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- CC 20120927 Query used by consultation of cash interests trades -->
  <!-- Distinct query for sqlserver and oracle due to reading data in the XML of trade -->
  <item name="CASHINTEREST_SELECT">
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,
  t.IDT, t.IDENTIFIER,            
  e_startper.DTSTARTUNADJ as DTSTARTPERIOD, 
  t.DTTRADE as DTENDPERIOD, 
  ta_ci.IDA as IDA,            
  ta_ci.IDB as IDB,            
  ta_ent.IDA as IDA_ENTITY, 
  -- lecture du type de flux sur lequel sont calculés les intérêts
  case when t.TRADEXML.value('declare default element namespace "http://www.fpml.org/2007/FpML-4-4"; 
  declare namespace efs="http://www.efs.org/2007/EFSmL-3-0"; declare namespace fixml="http://www.fixprotocol.org/FIXML-5-0-SP1";            
  (efs:EfsML/trade/efs:cashBalanceInterest/efs:interestAmountType/text()) [1]','varchar(64)')='CashBalance' 
       then 'DebitCreditCashBalance' 
       else 'CashCoveredInitialMargin'
  end as AMOUNTTYPE,
  case when e_ci_d.UNIT is null then e_ci_c.UNIT else e_ci_d.UNIT end as UNIT,
  isnull(e_ci_d.VALORISATION,0) as D_INTEREST,
  isnull(e_ci_c.VALORISATION,0) as C_INTEREST
  --abs(isnull(e_ci_d.VALORISATION,0) - isnull(e_ci_c.VALORISATION,0)) as TOTAL_INTEREST
  from dbo.TRADE t    
  %%SR:TRADE_JOIN%%(t.IDT)
  inner join dbo.INSTRUMENT i on (i.IDI=t.IDI)            
  inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashBalanceInterest')            
  inner join dbo.TRADESTSYS tsys on (tsys.IDT=t.IDT) and (tsys.IDSTACTIVATION='REGULAR')
  inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT=t.IDT) and (ta_ent.IDROLEACTOR='ENTITY')
  inner join dbo.TRADEACTOR ta_ci on (ta_ci.IDT=t.IDT) and (ta_ci.IDROLEACTOR='COUNTERPARTY') and (ta_ci.IDA!=ta_ent.IDA) 
  -- lecture de l''événement TRD/DAT pour récupérer la date de début de période non ajustée du calcul d''intérêts
  -- la date de fin de période étant lue sur la colonne DTTRADE de la table TRADE
  inner join dbo.EVENT e_startper on e_startper.IDT=t.IDT and e_startper.EVENTCODE='TRD' and e_startper.EVENTTYPE='DAT'
  -- lecture de l''événement TER/INT où IDA_PAY = TRADEACTOR.IDA pour récupérer le montant total des intérêts débiteurs
  left outer join dbo.EVENT e_ci_d on (e_ci_d.IDT=t.IDT) and (e_ci_d.EVENTCODE='TER') and (e_ci_d.EVENTTYPE='INT') 
  and (e_ci_d.IDA_PAY=ta_ci.IDA) and (e_ci_d.IDSTACTIVATION='REGULAR')
  -- lecture de l''événement TER/INT où IDA_REC = TRADEACTOR.IDA pour récupérer le montant total des intérêts créditeurs
  left outer join dbo.EVENT e_ci_c on (e_ci_c.IDT=t.IDT) and (e_ci_c.EVENTCODE='TER') and (e_ci_c.EVENTTYPE='INT') 
  and (e_ci_c.IDA_REC=ta_ci.IDA) and (e_ci_c.IDSTACTIVATION='REGULAR')
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ta_ci.IDA)
  
  where             
  (%%SR:TRADE_WHERE_PREDICATE%%)  
        ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,
  t.IDT, t.IDENTIFIER,            
  e_startper.DTSTARTUNADJ as DTSTARTPERIOD, 
  t.DTTRADE as DTENDPERIOD, 
  ta_ci.IDA as IDA,            
  ta_ci.IDB as IDB,            
  ta_ent.IDA as IDA_ENTITY, 
  -- lecture du type de flux sur lequel sont calculés les intérêts
  case when extractvalue(t.TRADEXML,'(efs:EfsML/trade/efs:cashBalanceInterest/efs:interestAmountType/text()) [1]',
  'xmlns:efs="http://www.efs.org/2007/EFSmL-3-0", xmlns:fixml="http://www.fixprotocol.org/FIXML-5-0-SP1", 
  xmlns="http://www.fpml.org/2007/FpML-4-4"')='CashBalance' 
       then 'DebitCreditCashBalance' 
       else 'CashCoveredInitialMargin'
  end as AMOUNTTYPE,
  case when e_ci_d.UNIT is null then e_ci_c.UNIT else e_ci_d.UNIT end as UNIT,
  nvl(e_ci_d.VALORISATION,0) as D_INTEREST,
  nvl(e_ci_c.VALORISATION,0) as C_INTEREST
  --abs(nvl(e_ci_c.VALORISATION,0) - nvl(e_ci_d.VALORISATION,0)) as TOTAL_INTEREST
  from dbo.TRADE t    
  %%SR:TRADE_JOIN%%(t.IDT)
  inner join dbo.INSTRUMENT i on (i.IDI=t.IDI)            
  inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashBalanceInterest')            
  inner join dbo.TRADESTSYS tsys on (tsys.IDT=t.IDT) and (tsys.IDSTACTIVATION='REGULAR')
  inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT=t.IDT) and (ta_ent.IDROLEACTOR='ENTITY')
  inner join dbo.TRADEACTOR ta_ci on (ta_ci.IDT=t.IDT) and (ta_ci.IDROLEACTOR='COUNTERPARTY') and (ta_ci.IDA!=ta_ent.IDA) 
  -- lecture de l''événement TRD/DAT pour récupérer la date de début de période non ajustée du calcul d''intérêts
  -- la date de fin de période étant lue sur la colonne DTTRADE de la table TRADE
  inner join dbo.EVENT e_startper on e_startper.IDT=t.IDT and e_startper.EVENTCODE='TRD' and e_startper.EVENTTYPE='DAT'
  -- lecture de l''événement TER/INT où IDA_PAY = TRADEACTOR.IDA pour récupérer le montant total des intérêts débiteurs
  left outer join dbo.EVENT e_ci_d on (e_ci_d.IDT=t.IDT) and (e_ci_d.EVENTCODE='TER') and (e_ci_d.EVENTTYPE='INT') 
  and (e_ci_d.IDA_PAY=ta_ci.IDA) and (e_ci_d.IDSTACTIVATION='REGULAR')
  -- lecture de l''événement TER/INT où IDA_REC = TRADEACTOR.IDA pour récupérer le montant total des intérêts créditeurs
  left outer join dbo.EVENT e_ci_c on (e_ci_c.IDT=t.IDT) and (e_ci_c.EVENTCODE='TER') and (e_ci_c.EVENTTYPE='INT') 
  and (e_ci_c.IDA_REC=ta_ci.IDA) and (e_ci_c.IDSTACTIVATION='REGULAR')
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ta_ci.IDA)
  where             
  (%%SR:TRADE_WHERE_PREDICATE%%)  
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="MCO_RPT_SELECT">
    <sqlCommand>
      <Command rdbms="sqlserver">
        <![CDATA[
        select mco.IDMCO,
        case when mco.DTUPD is not null then mco.DTUPD else mco.DTINS end as DTMSG,
        mco.DTMCO,mco.DTMCOFORCED,mco.DTMCO2,
        mco.IDA_SENDBYPARTY, mco.IDA_SENDBYOFFICE,
        mco.IDA_SENDTOPARTY, mco.IDA_SENDTOOFFICE, mco.IDB_SENDTOPARTY,
        mco.CNFMSGXML,
        mco.DOCTYPEMSGTXT,mco.LOCNFMSGTXT,
        mco.DOCTYPEMSGBIN,mco.LOCNFMSGBIN,
        mco.DOCNAME, mco.SCOPE, mco.DTOBSOLETE
        from dbo.VW_MCO_MULTITRADES mco
        inner join dbo.CNFMESSAGE cnfmsg on cnfmsg.IDCNFMESSAGE = mco.IDCNFMESSAGE
        and cnfmsg.CNFTYPE in ('ALLOCATION','FINANCIAL','FINANCIALPERIODIC','POSITION','POSSYNTHETIC','POSACTION','SYNTHESIS')
        where 
        <choose>
        <when test ="{PERIODREPORTTYPE}=1"> 
          -- Daily Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is null)
        </when>
        <when test ="{PERIODREPORTTYPE}=2"> 
          -- Weekly Period
           (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) and 
           ((((datepart(weekday,mco.DTMCO) + @@DATEFIRST -1 -1) % 7) +1)=1) and ( datediff(day,mco.DTMCO,mco.DTMCO2)=6 or datediff(day,mco.DTMCO,mco.DTMCO2)=4 ) 
        </when>
        <when test ="{PERIODREPORTTYPE}=3"> 
          -- Monthly Period
           (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
           and (day(mco.DTMCO)=1) and (mco.DTMCO2=dateadd(d,-1,dateadd(m,1,DTMCO))) 
        </when>
        <when test ="{PERIODREPORTTYPE}=4"> 
        --Yealy Period
         (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
         and (day(mco.DTMCO)=1) and (month(mco.DTMCO)=1) and (day(mco.DTMCO2)=31) and (month(mco.DTMCO2)=12) 
        </when>
        <otherwise>
          -- Daily Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null)
        </otherwise>
        </choose>
        ]]>
      </Command>
      <Command rdbms="oracle">
        <![CDATA[
        select mco.IDMCO,
        case when mco.DTUPD is not null then mco.DTUPD else mco.DTINS end as DTMSG,
        mco.DTMCO,mco.DTMCOFORCED,mco.DTMCO2,
        mco.IDA_SENDBYPARTY, mco.IDA_SENDBYOFFICE,
        mco.IDA_SENDTOPARTY, mco.IDA_SENDTOOFFICE, mco.IDB_SENDTOPARTY,
        mco.CNFMSGXML,
        mco.DOCTYPEMSGTXT,mco.LOCNFMSGTXT,
        mco.DOCTYPEMSGBIN,mco.LOCNFMSGBIN,
        mco.DOCNAME, mco.SCOPE, mco.DTOBSOLETE
        from dbo.VW_MCO_MULTITRADES mco
        inner join dbo.CNFMESSAGE cnfmsg on cnfmsg.IDCNFMESSAGE = mco.IDCNFMESSAGE
        and cnfmsg.CNFTYPE in ('ALLOCATION','FINANCIAL','FINANCIALPERIODIC','POSITION','POSSYNTHETIC','POSACTION','SYNTHESIS')
        where 
        <choose>
        <when test ="{PERIODREPORTTYPE}=1"> 
          -- Daily Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is null)
        </when>
        <when test ="{PERIODREPORTTYPE}=2"> 
          -- Weekly Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
          and (mod( mco.DTMCO - date '1000-01-01', 7) + 1)=1
          and ( (mco.DTMCO2 - mco.DTMCO)=6 or (mco.DTMCO2 - mco.DTMCO)=4 ) 
        </when>
        <when test ="{PERIODREPORTTYPE}=3"> 
          -- Monthly Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
          and (extract(day from mco.DTMCO)=1) and (mco.DTMCO2=last_day(mco.DTMCO)) 
        </when>
        <when test ="{PERIODREPORTTYPE}=4"> 
        --Yealy Period
        (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
        and (extract(day from mco.DTMCO)=1) and (extract(month from mco.DTMCO)=1) 
        and (extract(day from mco.DTMCO2)=31) and (extract(month from mco.DTMCO2)=12) 
        </when>
        <otherwise>
          -- Daily Period
          (mco.DTMCO=@DATE1)  and (mco.DTMCO2 is not null)
        </otherwise>
        </choose>
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  CC/PL 20130919 Ticket 18971 - Correction sur signe du montant pour le flux SCU                 
  POSACTIONDET_PRESELECT utilisé par la consultation des 'Actions opérées sur positions',        
  consultation accessible via le menu Consultations\Exchange (Bourse)\Positions                  
  Le PRESELECT alimente une table temporaire avec le jeu de résultats                            
  POSACTIONDET_PRESELECT (étape 1) est associé au POSACTIONDET_SELECT (étape 2)                  
  
  EG 20141208 Add POSITIONEFFECT      
  FI 20160229 Modfy
      => add 'AUTOEXE','AUTOASS','AUTOABN'
      => add restriction (price.QUOTEPRICE100 is not null) sur colonne ITM_OTM
      => si MOF lecture du prix sur l'EVENTDET rattaché à l'évènement MOF
  -->
  <item name="POSACTIONDET_PRESELECT">
    <sqlCommand>
      <!-- 
      Remarques
      - Pour optimiser les temps de réponses les sous select font des lecture dans la table EVENT,EVENTCLASS en date de traitement
      Ceci n'est pas effectué pour la requête qui charge les décompensations car il est impossible de connaître la date de la compensation initiale
      
      - Une compensation décompensée le même jour donne lieu à 2 enregistrements
      -->

      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      delete from POSACTIONDET_%%SHORTSESSIONID%%_W;
      
      insert into POSACTIONDET_%%SHORTSESSIONID%%_W
      (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
      DTSYS, PRICE, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, SCU_IDA_PAY, SCU_IDA_REC, SCU, SCU_IDC, ITM_OTM, DEACTIV, POSITIONEFFECT)

      select     
          pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
          pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, 
          pad.DTINS as DTSYS, price.QUOTEPRICE100 as PRICE,
          rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC,
          scu.IDA_PAY as SCU_IDA_PAY, scu.IDA_REC as SCU_IDA_REC, scu.VALORISATION as SCU, scu.UNIT as SCU_IDC,
          
          case when pad.REQUESTTYPE in ('EXE','ASS','ABN', 'AUTOEXE','AUTOASS','AUTOABN') 
                    and (price.IDT = pad.TRADE_IDT) and (price.QUOTEPRICE100 is not null) then
            case  
            -- 1 = Call
            when asset.PUTCALL='1' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'Out the money'
            when asset.PUTCALL='1' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'In the money' 
            when asset.PUTCALL='1' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money' 
            -- 0 = Put
            when asset.PUTCALL='0' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'In the money'
            when asset.PUTCALL='0' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'Out the money'
            when asset.PUTCALL='0' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money'
            else 'N/A' end 
          else 'N/A' end as ITM_OTM,
          0 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=pad.TRADE_IDT) and (ti.INSTRUMENTNO=1)
      %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,ti,null)
      inner join dbo.ASSET_ETD asset on (asset.IDASSET=ti.IDASSET)
      
      left outer join 
      (
          select ev.IDT,  case ev.EVENTCODE  
                               when 'MOF' then evdet.CLOSINGPRICE100 
                                          else evdet.SETTLTPRICE100 
                          end as QUOTEPRICE100, epad.IDPADET 
          from dbo.EVENT ev
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS in ('PHY','CSH')) and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE=ev.IDE)
          left outer join dbo.EVENTDET evdet on (evdet.IDE=ev.IDE)
          where ev.EVENTCODE in ('EXE', 'AEX', 'ABN', 'AAB', 'ASS', 'AAS', 'MOF') 
      ) price  on (price.IDPADET=pad.IDPADET) and (price.IDT=pad.TRADE_IDT)

      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE = 'RMG')
      ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT)
      
      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE = 'SCU')
      ) scu  on (scu.IDPADET = pad.IDPADET) and (scu.IDT = pad.TRADE_IDT)
      where (pad.DTBUSINESS between @DATE1 and @DATE2 )
      and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
      
      union all
  
      select     
      pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
      pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS, null as PRICE, rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, 
      rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, null as SCU_IDA_PAY, null as SCU_IDA_REC, null as SCU, null as SCU_IDC, 
      'N/A' as ITM_OTM, 1 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=pad.TRADE_IDT) and (ti.INSTRUMENTNO=1)
      %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,ti,null)
      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS='VAL')
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE ='RMG')
      ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT=pad.TRADE_IDT)
      where (pad.DTUNCLEARING between @DATE1 and @DATE2)
      and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
			]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20141208 Add POSITIONEFFECT  -->
  <item name="POSACTIONDET_SELECT">
    <!--
     Remarques
     - Lorsque Type de position vaut "Client,Maison, Teneur de Marché"
       Les transferts sont affichés uniquement s'il ont lieu côté Dealer  (FIXPARTYROLE = 27)
     
     - Lorsque Type de position vaut "Compensateurs"
       Les transferts sont affichés uniquement s'il ont lieu côté Compensation  (FIXPARTYROLE != 27)
     
     - Lorsque Type de position vaut <Tous>
       Chaque transfert n'apparaît qu'une seule fois
     
     - Les Transferts sont affichés comme Transfert uniquement si TRDTYPE = PositionTransfert (42) et TRDSUBTYPE vaut Internal transfer or adjustment(1)
       Les Transferts sont affichés comme Correction dans les autres cas, Le trade résultat du transfert est non accessible depuis le grid 
    -->
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      select ar.IDA as arCLIENT_IDA, rs.POSTYPE, rs.IDPR, 
      case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then 
                                                           case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then 'POT' else 'POC' end
                                                           else rs.REQUESTTYPE end end as REQUESTTYPE,
      case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then 
                                                           case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then 'POT' else 'POC' end
                                                           else rs.REQUESTTYPE end end as REQUESTTYPE_VALUE,
      rs.IDPA, rs.IDPADET, rs.POSITIONEFFECT, rs.IDT, 
      rs.IDA as IDA_DEALERORCLEARER, rs.IDB as IDB_DEALERORCLEARER, 
      case when rs.REQUESTTYPE = 'POT' then case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then rs.IDT2 else null end else rs.IDT2 end as IDT2,
      rs.DTBUSINESS, rs.DTUNCLEARING, rs.QUANTITY, rs.DEACTIV, rs.DTSYS, rs.IDASSET, rs.IDM, rs.IDA_CSSCUSTODIAN, rs.PRICE, 
      case when rs.IDA = rs.RMG_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
										else case when rs.DEACTIV=0 then  1 else -1 end end * rs.RMG as RMG, rs.RMG_IDC,
      case when rs.IDA = rs.SCU_IDA_PAY then -1 else 1 end * rs.SCU as SCU, rs.SCU_IDC,
      rs.ITM_OTM, en.EXTVALUE As REQUESTTYPEENUM, en.EXTVALUE As REQUESTTYPE_EXTVALUE
     
      from 
      (
          select posact.POSTYPE, posact.IDPR, posact.REQUESTTYPE, posact.IDPA, posact.IDPADET, posact.IDT, posact.IDT2, 
          posact.DTBUSINESS, posact.DTUNCLEARING, posact.QTY as QUANTITY, posact.DTSYS, posact.PRICE, 
          posact.RMG_IDA_PAY, posact.RMG_IDA_REC, posact.RMG, posact.RMG_IDC, 
          posact.SCU_IDA_PAY, posact.SCU_IDA_REC, posact.SCU, posact.SCU_IDC, 
          posact.ITM_OTM, posact.DEACTIV, posact.POSITIONEFFECT, posact.IDA, posact.IDB, tr.IDASSET, tr.IDM, tr.IDA_CSSCUSTODIAN    
          from 
          (
              select case ta.FIXPARTYROLE when '27' then 1 else 2 end as POSTYPE, ta.IDA, ta.IDB,
              pad.IDPR, pad.IDPA, pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.IDT, pad.IDT2, 
              pad.DTSYS, pad.PRICE, 
              pad.RMG_IDA_PAY, pad.RMG_IDA_REC, pad.RMG, pad.RMG_IDC, 
			        pad.SCU_IDA_PAY, pad.SCU_IDA_REC, pad.SCU, pad.SCU_IDC, pad.ITM_OTM, pad.DEACTIV, pad.POSITIONEFFECT
              from POSACTIONDET_%%SHORTSESSIONID%%_W pad
              inner join dbo.TRADE tr on (tr.IDT = pad.IDT)
              inner join dbo.TRADEACTOR ta on (ta.IDT = tr.IDT) and (ta.IDROLEACTOR='COUNTERPARTY')
              <choose>
               <when test="{POSTYPE}=1">   
                  and (ta.FIXPARTYROLE in ('27'))
               </when>
               <when test="{POSTYPE}=2">   
                  and (ta.FIXPARTYROLE in ('4','21'))
               </when>
               <otherwise>
                  and (ta.FIXPARTYROLE in ('27','4','21'))
                </otherwise>
              </choose>
              left outer join dbo.TRADE tr2 on (tr2.IDT = pad.IDT2)
              <choose> 
                <when test="{POSTYPE}=0">   
                where 
                (
                  tr.IDT = case when pad.REQUESTTYPE = 'POT' then  
					                      case ta.FIXPARTYROLE when '27' then tr.IDT else -1
                                end 
					                 else tr.IDT end
                )
                </when>
              </choose>
        ) posact
        inner join dbo.VW_TRADE_FUNGIBLE_LIGHT_ETD tr on (tr.IDT=posact.IDT)
        
      ) rs
      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')
      left outer join dbo.TRADEINSTRUMENT ti2 on ti2.IDT = rs.IDT2
      inner join dbo.ENUM en on (en.CODE='PosRequestTypeEnum') and (en.VALUE=
                case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then 'POT' else 'POC' end else rs.REQUESTTYPE end end)
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20141208 Add POSITIONEFFECT  -->
  <item name="POSACTIONDET_OTC_PRESELECT">
    <sqlCommand>
      <!-- 
      Remarques
      - Pour optimiser les temps de réponses les sous select font des lecture dans la table EVENT,EVENTCLASS en date de traitement
      Ceci n'est pas effectué pour la requête qui charge les décompensations car il est impossible de connaître la date de la compensation initiale
      - Une compensation décompensée le même jour donne lieu à 2 enregistrements
      -->
      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      delete from POSACTIONDET_OTC_%%SHORTSESSIONID%%_W;
      
      insert into POSACTIONDET_OTC_%%SHORTSESSIONID%%_W
      (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
      DTSYS, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, 
      AIN_IDA_PAY, AIN_IDA_REC, AIN, AIN_IDC,
      GAM_IDA_PAY, GAM_IDA_REC, GAM, GAM_IDC,
      DEACTIV, POSITIONEFFECT)
      select     
      pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
      pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, pad.DTINS as DTSYS, 
      rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 
      ain.IDA_PAY as AIN_IDA_PAY, ain.IDA_REC as AIN_IDA_REC, ain.VALORISATION as AIN, ain.UNIT as AIN_IDC, 
      gam.IDA_PAY as GAM_IDA_PAY, gam.IDA_REC as GAM_IDA_REC, gam.VALORISATION as GAM, gam.UNIT as GAM_IDC, 
      0 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=pad.TRADE_IDT) and (ti.INSTRUMENTNO=1)
      inner join dbo.VW_INSTR_PRODUCT pr on ( pr.IDI = ti.IDI) and (pr.FUNGIBILITYMODE != 'NONE') and (pr.GPRODUCT in ('OTC','SEC'))
      %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,ti,null)
      
      left outer join 
      (
          select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
          from dbo.EVENT ev 
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
          where (ev.EVENTTYPE = 'RMG')
      ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT)
      
      left outer join 
      (    /* Flux LPC/AIN = rétrocession de coupon couru en cas de transfert, de correction */
          select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
          from dbo.EVENT ev 
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
          where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'AIN')
      ) ain  on (ain.IDPADET = pad.IDPADET) and (ain.IDT = pad.TRADE_IDT)
      
      left outer join 
      (    /* Flux LPC/GAM = rétrocession de gross amount en cas de transfert, de correction */
          select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
          from dbo.EVENT ev 
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
          where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'GAM')
      ) gam  on (gam.IDPADET = pad.IDPADET) and (gam.IDT = pad.TRADE_IDT)
      
      where (pad.DTBUSINESS between @DATE1 and @DATE2 )
      and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
      
      union all
  
      select     
      pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
      pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS,
      rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 
      /* Columns below set null - Only RMG on UNCLEARING*/
      null as AIN_IDA_PAY, null as AIN_IDA_REC, null as AIN, null as AIN_IDC, 
      null as GAM_IDA_PAY, null as GAM_IDA_REC, null as GAM, null as GAM_IDC, 
      1 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=pad.TRADE_IDT) and (ti.INSTRUMENTNO=1)
      inner join dbo.VW_INSTR_PRODUCT pr on ( pr.IDI = ti.IDI) and (pr.FUNGIBILITYMODE != 'NONE') and (pr.GPRODUCT in ('OTC','SEC'))
      %%CC:ITRADEINSTRUMENT_JOIN%%(ti)
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,ti,null)
      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS='VAL')
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE ='RMG')
      ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT=pad.TRADE_IDT)
      
      where (pad.DTUNCLEARING between @DATE1 and @DATE2)
      and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
			]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  CC/EG 20150304 Add ASSETCATEGORY
  EG 20141208 Add POSITIONEFFECT  
  -->
  <item name="POSACTIONDET_OTC_SELECT">
    <!--
     Remarques
     - Lorsque Type de position vaut "Client,Maison, Teneur de Marché"
       Les transferts sont affichés uniquement s'il ont lieu côté Dealer  (FIXPARTYROLE = 27)
     
     - Lorsque Type de position vaut "Custodian"
       Les transferts sont affichés uniquement s'il ont lieu côté Custodian  (FIXPARTYROLE != 27)
     
     - Lorsque Type de position vaut <Tous>
       Chaque transfert n'apparaît qu'une seule fois
     
       Les Transferts sont affichés comme Correction dans les autres cas, Le trade résultat du transfert n'est pas accessible depuis le grid 
    -->

    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      select ar.IDA as arCLIENT_IDA, rs.POSTYPE, rs.IDPR, 
      case when rs.DEACTIV = 1 then 'UNCLEARING' else 
                                                 case rs.REQUESTTYPE when 'POT' then 
                                                                    case when rs.FAMILY='ESE' then case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then 'POT' else 'POC' end
                                                                                              else 'POT'
                                                                                              end                                      
                                                                    else rs.REQUESTTYPE 
                                                                    end 
                                                 end as REQUESTTYPE,
      rs.IDPA, rs.IDPADET, rs.POSITIONEFFECT, rs.IDT, 
      rs.IDA as IDA_DEALERORCLEARER, rs.IDB as IDB_DEALERORCLEARER, 
      case when rs.REQUESTTYPE = 'POT' then case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then rs.IDT2 else null end else rs.IDT2 end as IDT2,
      rs.DTBUSINESS, rs.DTUNCLEARING, rs.QUANTITY, rs.DEACTIV, rs.DTSYS, rs.IDASSET, rs.ASSETCATEGORY, rs.IDM, rs.IDA_CSSCUSTODIAN, 
      case when rs.IDA = rs.RMG_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
										else case when rs.DEACTIV=0 then  1 else -1 end end * rs.RMG as RMG, rs.RMG_IDC,
      
      case when rs.IDA = rs.AIN_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
										else case when rs.DEACTIV=0 then  1 else -1 end end * rs.AIN as AIN, rs.AIN_IDC,
                    
      case when rs.IDA = rs.GAM_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
			              else case when rs.DEACTIV=0 then  1 else -1 end end * rs.GAM as GAM, rs.GAM_IDC,
      en.EXTVALUE As REQUESTTYPEENUM
                    
      from 
      (
          select pa_otc.POSTYPE, pa_otc.IDPR, pa_otc.REQUESTTYPE, pa_otc.IDPA, pa_otc.IDPADET, pa_otc.IDT, pa_otc.IDT2, 
          pa_otc.DTBUSINESS, pa_otc.DTUNCLEARING, pa_otc.QTY as QUANTITY, pa_otc.DTSYS, 
          pa_otc.RMG_IDA_PAY, pa_otc.RMG_IDA_REC, pa_otc.RMG, pa_otc.RMG_IDC, 
          pa_otc.AIN_IDA_PAY, pa_otc.AIN_IDA_REC, pa_otc.AIN, pa_otc.AIN_IDC,
          pa_otc.GAM_IDA_PAY, pa_otc.GAM_IDA_REC, pa_otc.GAM, pa_otc.GAM_IDC,
          pa_otc.DEACTIV, pa_otc.POSITIONEFFECT, pa_otc.IDA, pa_otc.IDB, tr.IDASSET, tr.ASSETCATEGORY, tr.IDM, tr.IDA_CSSCUSTODIAN,
          tr.FAMILY
          from 
          (
              select case ta.FIXPARTYROLE when '27' then 1 else 2 end as POSTYPE, ta.IDA, ta.IDB,
              pad.IDPR, pad.IDPA, pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.IDT, pad.IDT2, 
              pad.DTSYS, 
              pad.RMG_IDA_PAY, pad.RMG_IDA_REC, pad.RMG, pad.RMG_IDC, 
              pad.AIN_IDA_PAY, pad.AIN_IDA_REC, pad.AIN, pad.AIN_IDC,
              pad.GAM_IDA_PAY, pad.GAM_IDA_REC, pad.GAM, pad.GAM_IDC,
              
              pad.DEACTIV, pad.POSITIONEFFECT
              from POSACTIONDET_OTC_%%SHORTSESSIONID%%_W pad
              inner join dbo.TRADE tr on (tr.IDT = pad.IDT)
              inner join dbo.TRADEACTOR ta on (ta.IDT = tr.IDT) and (ta.IDROLEACTOR='COUNTERPARTY')
              <choose>
               <when test="{POSTYPE}=1">   
                  and (ta.FIXPARTYROLE in ('27'))
               </when>
               <when test="{POSTYPE}=2">   
                  and (ta.FIXPARTYROLE in ('28','21'))
               </when>
               <otherwise>
                  and (ta.FIXPARTYROLE in ('27','28','21'))
                </otherwise>
              </choose>
              left outer join dbo.TRADE tr2 on (tr2.IDT = pad.IDT2)
              <choose> 
                <when test="{POSTYPE}=0">   
                where 
                (
                  tr.IDT = case when pad.REQUESTTYPE = 'POT' then  
					                      case ta.FIXPARTYROLE when '27' then tr.IDT else -1
                                end 
					                 else tr.IDT end
                )
                </when>
              </choose>
              
        ) pa_otc
        inner join dbo.VW_TRADE_FUNGIBLE_LIGHT_OTCSEC tr on (tr.IDT=pa_otc.IDT)
      ) rs
      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')
      left outer join dbo.TRADEINSTRUMENT ti2 on ti2.IDT = rs.IDT2
      inner join dbo.ENUM en on (en.CODE='PosRequestTypeEnum') and (en.VALUE=
                case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then case when rs.FAMILY='ESE' then case when ti2.TRDTYPE ='42' and ti2.TRDSUBTYPE = '1' then 'POT' else 'POC' end else 'POT' end else rs.REQUESTTYPE end end)
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  POSACTIONDET_TRADE_PRESELECT utilisé par la consultation des 'Actions opérées sur positions',  
  consultation accessible via le bouton 'POS.ACT' disponible sur le masque de saisie des trades  
  EG 20141208 Add POSITIONEFFECT  
  FI 20160229 Modfy
      => alias PRICE, expression QUOTEPRICE100 lecture de CLOSINGPRICE100 si MOF
      => add restriction (price.QUOTEPRICE100 is not null) sur colonne ITM_OTM
      => suppression des jointures sur EVENTCLASS puisque non utile
  -->
  <item name="POSACTIONDET_TRADE_PRESELECT">
    <sqlCommand>
      <!-- Remarques                                                                       
      Le RMG est lu sur le trade consulté pour optmiser les temps de réponse de la requête 
      Ce trade peut-être le trade clôturant ou le trade clôturé                            
      -->

      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        delete from POSACTIONDET_%%SHORTSESSIONID%%_W;
        
        insert into POSACTIONDET_%%SHORTSESSIONID%%_W
        (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
        DTSYS, PRICE, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, SCU_IDA_PAY, SCU_IDA_REC, SCU, SCU_IDC, ITM_OTM, DEACTIV, POSITIONEFFECT)

        select     
            pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
            pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, 
            pad.DTINS as DTSYS, price.QUOTEPRICE100 as PRICE,
            rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC,
            scu.IDA_PAY as SCU_IDA_PAY, scu.IDA_REC as SCU_IDA_REC, scu.VALORISATION as SCU, scu.UNIT as SCU_IDC,
            
            case when pad.REQUESTTYPE in ('EXE','ASS','ABN', 'AUTOEXE','AUTOASS','AUTOABN') 
                                      and (price.IDT = pad.TRADE_IDT) and (price.QUOTEPRICE100 is not null) then
              case  
              -- 1 = Call
              when asset.PUTCALL='1' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'Out the money'
              when asset.PUTCALL='1' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'In the money' 
              when asset.PUTCALL='1' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money' 
              -- 0 = Put
              when asset.PUTCALL='0' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'In the money'
              when asset.PUTCALL='0' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'Out the money'
              when asset.PUTCALL='0' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money'
              else 'N/A' end 
            else 'N/A' end as ITM_OTM,
            0 as DEACTIV, 
            pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=pad.TRADE_IDT) and (ti.INSTRUMENTNO=1) and (ti.ASSETCATEGORY='ExchangeTradedContract')
        inner join dbo.ASSET_ETD asset on (asset.IDASSET=ti.IDASSET) 
        left outer join 
        (
             select ev.IDT, case ev.EVENTCODE  
                              when 'MOF' then evdet.CLOSINGPRICE100 
                                         else evdet.SETTLTPRICE100 
                            end as QUOTEPRICE100, epad.IDPADET
             from dbo.EVENT ev
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE=ev.IDE)
             left outer join dbo.EVENTDET evdet on (evdet.IDE=ev.IDE)
             where ev.EVENTCODE in ('EXE', 'AEX', 'ABN', 'AAB', 'ASS', 'AAS', 'MOF') and (ev.IDT = @IDT)
        ) price  on (price.IDPADET=pad.IDPADET) and (price.IDT=pad.TRADE_IDT)
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE = 'RMG') and (ev.IDT = @IDT)
        ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE = 'SCU') and (ev.IDT = @IDT)
        ) scu  on (scu.IDPADET = pad.IDPADET) and (scu.IDT = pad.TRADE_IDT)
        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT)
        
        union all
    
        select     
        pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
        pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS, null as PRICE, rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, 
        rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, null as SCU_IDA_PAY, null as SCU_IDA_REC, null as SCU, null as SCU_IDC, 
        'N/A' as ITM_OTM, 1 as DEACTIV, pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE ='RMG') and (ev.IDT = @IDT)
        ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)
        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT) and (pad.DTUNCLEARING is not null);
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  POSACTIONDET_OTC_TRADE_PRESELECT utilisé par la consultation des 'Actions opérées sur positions (OTC/SEC)',  
  consultation accessible via le bouton 'POS.ACT' disponible sur le masque de saisie des trades  
  -->
  <item name="POSACTIONDET_OTC_TRADE_PRESELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        delete from POSACTIONDET_%%SHORTSESSIONID%%_W;
        
        insert into POSACTIONDET_%%SHORTSESSIONID%%_W
        (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
        DTSYS, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, DEACTIV, POSITIONEFFECT)

        select     
            pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
            pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, 
            pad.DTINS as DTSYS, 
            rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 0 as DEACTIV, pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        inner join dbo.TRADEINSTRUMENT ti on (ti.IDT=pad.TRADE_IDT) and (ti.INSTRUMENTNO=1)
        inner join dbo.VW_ASSET asset on (asset.IDASSET = ti.IDASSET) and (asset.ASSETCATEGORY = ti.ASSETCATEGORY)
        
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL')
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE = 'RMG') and (ev.IDT = @IDT)
        ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)

        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT)
        
        union all
    
        select     
        pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
        pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS, rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, 
        rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 1 as DEACTIV, pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS='VAL')
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE ='RMG') and (ev.IDT = @IDT)
        ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)
        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT) and (pad.DTUNCLEARING is not null);
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- FI 20160205 [XXXXX] Modify -->
  <item name="DENBULK_PRESELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
          /* Spheres:Hint ARITHABORT_ON NOPARAMS */
          delete from %%PARAM1%%_%%SHORTSESSIONID%%_W;
        
          insert into %%PARAM1%%_%%SHORTSESSIONID%%_W
          (IDT, DTBUSINESS, IDI, IDM, ASSETCATEGORY, IDASSET, IDA_ENTITY, IDA_CSSCUSTODIAN, 
          IDA_DEALER, IDB_DEALER,  IDA_CLEARER, IDB_CLEARER, IDEM, DTENTITY, DTMARKET, 
          SIDE, INITIALQTY, POSQTY, AVAILABLEQTY, IDPR, REQUESTTYPE, DENQTY, NBIDPR)
          select 
          tr.IDT, tr.DTBUSINESS, tr.IDI, tr.IDM, tr.ASSETCATEGORY, tr.IDASSET, tr.IDA_ENTITY, tr.IDA_CSSCUSTODIAN, 
          tr.IDA_DEALER, tr.IDB_DEALER,  tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDEM, tr.DTENTITY, tr.DTMARKET, tr.SIDE, tr.QTY, 
          tr.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0), 
          tr.QTY - isnull(pab.AVAILABLEQTY,0) - isnull(pas.AVAILABLEQTY,0),
          case when isnull(pr.NBIDPR,0) = 1 then pr.IDPR else null end as IDPR, pr.REQUESTTYPE, isnull(pr.DENQTY, 0), isnull(pr.NBIDPR,0)
          from dbo.VW_TRADE_POSETD tr
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr,null)
          %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
          inner join dbo.ASSET_ETD etd on (etd.IDASSET = tr.IDASSET)
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = etd.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC)
          inner join dbo.MATURITY ma on (ma.IDMATURITY = da.IDMATURITY)
                      
          /* Jointure sur EVT ExerciseDate : Si EUR alors DTMARKET = ev.DTENDADJ (exercice autorisé à l'échéance exclusivement)  */
          inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'EXD') and (ev.DTENDADJ = case ev.EVENTTYPE when 'EUR' then tr.DTMARKET else ev.DTENDADJ end)
                      
          /* On récupère les POSREQUEST des demandes du jours s'il en existe */
          
          <choose>
          <when test="{DENOPTIONACTIONTYPE}='remove'">inner join</when>
          <otherwise>left outer join</otherwise>
          </choose>
          (
            select pr.IDT, pr.DTBUSINESS, pr.REQUESTTYPE, sum(case pr.STATUS when 'SUCCESS' then pr.QTY else 0 end) as DENQTY, max(pr.IDPR) as IDPR, count(pr.IDT) as NBIDPR
            from dbo.POSREQUEST pr
            where (pr.STATUS in ('PENDING', 'WARNING', 'SUCCESS') and (0 < pr.QTY))
            <choose>
              <when test="%%PARAM1%% contains 'ASSEXEBULK'">and (pr.REQUESTTYPE in ('ASS','EXE'))</when>
              <when test="%%PARAM1%% contains 'ABNBULK'">and (pr.REQUESTTYPE = 'ABN')</when>
              <otherwise>and (pr.REQUESTTYPE in ('ABN','ASS','EXE'))</otherwise>
            </choose>
            group by 
            <choose>
            <when test="{DENOPTIONACTIONTYPE}='remove'">pr.IDPR, pr.IDT, pr.DTBUSINESS, pr.REQUESTTYPE</when>
            <otherwise>pr.IDT, pr.DTBUSINESS, pr.REQUESTTYPE</otherwise>
            </choose>
          ) pr on (pr.IDT = tr.IDT) and (pr.DTBUSINESS = tr.DTMARKET) 
          
          left outer join 
          (   
            select pad.IDT_BUY as IDT, sum(pad.QTY) as QTY,
            sum(case when pa.DTBUSINESS = em.DTENTITY  
            <choose>
              <when test="%%PARAM1%% contains 'ASSEXEBULK'">and (pr.REQUESTTYPE in ('ASS','EXE'))</when>
              <when test="%%PARAM1%% contains 'ABNBULK'">and (pr.REQUESTTYPE = 'ABN')</when>
            </choose>
            then 0 else pad.QTY end) as AVAILABLEQTY
            
            from dbo.POSACTION pa
            inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
            inner join dbo.POSACTIONDET pad   on (pad.IDPA = pa.IDPA)
            inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = pad.IDT_BUY)
            inner join dbo.ENTITYMARKET em on ( em.IDM = ti.IDM ) and (em.IDA = ti.IDA_ENTITY) <choose><when test="{MARKET}>-1"> and em.IDM=@MARKET</when></choose> <choose><when test="{ENTITY}>-1"> and em.IDA=@ENTITY</when></choose>
            
            where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY))
            group by pad.IDT_BUY
          ) pab  on (pab.IDT = tr.IDT)

          left outer join 
          (   
            select pad.IDT_SELL as IDT, sum(pad.QTY) as QTY,
            sum(case when pa.DTBUSINESS = em.DTENTITY  
            <choose>
              <when test="%%PARAM1%% contains 'ASSEXEBULK'">and (pr.REQUESTTYPE in ('ASS','EXE'))</when>
              <when test="%%PARAM1%% contains 'ABNBULK'">and (pr.REQUESTTYPE = 'ABN')</when>
            </choose>
            then 0 else pad.QTY end) as AVAILABLEQTY
            from dbo.POSACTION pa
            inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
            inner join dbo.POSACTIONDET pad on (pad.IDPA = pa.IDPA)
            inner join dbo.TRADEINSTRUMENT ti on (ti.IDT = pad.IDT_SELL)
            inner join dbo.ENTITYMARKET em on ( em.IDM = ti.IDM ) and (em.IDA = ti.IDA_ENTITY) <choose><when test="{MARKET}>-1"> and em.IDM=@MARKET</when></choose><choose><when test="{ENTITY}>-1"> and em.IDA=@ENTITY</when></choose>
            where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY))
            group by pad.IDT_SELL
          ) pas  on (pas.IDT = tr.IDT)

          where 
          
          <choose>
            <when test="{DENOPTIONACTIONTYPE}='newRemaining'">(tr.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) &gt; 0 ) and </when>
            <when test="{DENOPTIONACTIONTYPE}='new'">(tr.QTY - isnull(pab.AVAILABLEQTY,0) - isnull(pas.AVAILABLEQTY,0) &gt; 0) and (isnull(pr.NBIDPR,0) &lt;= 1) and </when>
            <otherwise>(tr.QTY - isnull(pab.AVAILABLEQTY,0) - isnull(pas.AVAILABLEQTY,0) &gt; 0) and </otherwise>
          </choose>
          
          (tr.DTBUSINESS <= tr.DTMARKET) and (tr.POSKEEPBOOK_DEALER = 1)
          <choose><when test="{MARKET}>-1"> and tr.IDM=@MARKET</when></choose><choose><when test="{ENTITY}>-1"> and tr.IDA_ENTITYDEALER=@ENTITY</when></choose>
          and (tr.DTMARKET <= isnull(ma.MATURITYDATE, ma.MATURITYDATESYS)) and 
          (%%SR:TRADEALLOC_WHERE_PREDICATE%%) and 
          (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%);
        ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
        delete from Q%%PARAM1%%_%%SHORTSESSIONID%%_W;
        
        insert into Q%%PARAM1%%_%%SHORTSESSIONID%%_W
        (IDASSET, IDASSET_UNL, ASSETCATEGORY_UNL, IDQUOTE_H, VALUE, TIME, QUOTESIDE, QUOTETIMING, SOURCE, ITM_OTM)
        select asset.IDASSET, assetQuoteUnl.IDASSET_UNL, assetQuoteUnl.ASSETCATEGORY_UNL, 
        quote_last.IDQUOTE_H, quote_last.VALUE, quote_last.TIME, quote_last.QUOTESIDE, quote_last.QUOTETIMING, quote_last.SOURCE,
        case when quote_last.IDQUOTE_H is null then 'N/A'
	      when (asset.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE) or (asset.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE) then 'Out the money'
	      when (asset.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE) or (asset.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE) then 'In the money'
	      when assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE then 'At the money' else 'N/A' end as ITM_OTM
        from
        (
          select asset.IDASSET as IDASSET, asset_unl.IDASSET as IDASSET_UNL, 'Future' as ASSETCATEGORY_UNL ,
		      case when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and (dc_unl.INSTRUMENTDEN%100) = 0 then asset.STRIKEPRICE
               else floor(asset.STRIKEPRICE) + ((asset.STRIKEPRICE - floor(asset.STRIKEPRICE)) * 
                    case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
                    (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end)) end as STRIKE_PRICE,
			    (
				    select top 1 IDQUOTE_H
				    from dbo.VW_QUOTE_H quote
				    where (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') and 
                  (quote.ISENABLED=1) and (quote.TIME < (posdet.DTMARKET+1)) and (quote.IDASSET = asset_unl.IDASSET) and (quote.ASSETCATEGORY= 'Future')
						order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc	 				
          ) as IDQUOTE_H_UNL
          from dbo.ASSET_ETD asset
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) and (dc.ASSETCATEGORY = 'Future')
          inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET = da.IDASSET)
          inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
          inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET)
      
          union all 
    
          select asset.IDASSET as IDASSET, vw_asset_unl.IDASSET as IDASSET_UNL, vw_asset_unl.ASSETCATEGORY as ASSETCATEGORY_UNL, 
          asset.STRIKEPRICE as STRIKE_PRICE ,
          (
				    select top 1 IDQUOTE_H
				    from dbo.VW_QUOTE_H quote
				    where (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') and
				          (quote.ISENABLED=1) and quote.TIME < (posdet.DTMARKET+1)  and (quote.IDASSET = vw_asset_unl.IDASSET) and (quote.ASSETCATEGORY= vw_asset_unl.ASSETCATEGORY)
				    order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc	 				
			    ) as IDQUOTE_H_UNL
          from dbo.ASSET_ETD asset
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) and (dc.ASSETCATEGORY != 'Future')
          inner join dbo.VW_ASSET vw_asset_unl on (vw_asset_unl.ASSETCATEGORY = dc.ASSETCATEGORY) and (vw_asset_unl.IDASSET = dc.IDASSET_UNL)
          inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET)
        ) assetQuoteUnl
        inner join dbo.ASSET_ETD asset on (asset.IDASSET = assetQuoteUnl.IDASSET)
        inner join dbo.VW_QUOTE_H quote_last on (quote_last.IDQUOTE_H = assetQuoteUnl.IDQUOTE_H_UNL) and
				                                  			(quote_last.IDASSET = assetQuoteUnl.IDASSET_UNL) and 
                                                (quote_last.ASSETCATEGORY = assetQuoteUnl.ASSETCATEGORY_UNL);
        ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
        delete from Q%%PARAM1%%_%%SHORTSESSIONID%%_W;
        
        insert into Q%%PARAM1%%_%%SHORTSESSIONID%%_W
        (IDASSET, IDASSET_UNL, ASSETCATEGORY_UNL, IDQUOTE_H, VALUE, TIME, QUOTESIDE, QUOTETIMING, SOURCE, ITM_OTM)
        select asset.IDASSET, vw_asset_unl.IDASSET, vw_asset_unl.ASSETCATEGORY, 
        null, null, null, null, null, null, null
        from dbo.ASSET_ETD asset
        inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
        inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) and (dc.ASSETCATEGORY = 'Future')
        inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc.ASSETCATEGORY and
        (
          (dc.ASSETCATEGORY != 'Future' and vw_asset_unl.IDASSET=dc.IDASSET_UNL) or (dc.ASSETCATEGORY = 'Future' and vw_asset_unl.IDASSET=da.IDASSET)
        )
        inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET = da.IDASSET)
        inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
        inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
        inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET);
        ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
        declare quote dbo.VW_QUOTE_H%ROWTYPE;
        found boolean ;  

        cursor c1 is
        select quote_w.IDASSET, quote_w.IDASSET_UNL, quote_w.ASSETCATEGORY_UNL, quote_w.IDQUOTE_H, asset.PUTCALL,
        case when quote_w.ASSETCATEGORY_UNL = 'Future' then
          case when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 then asset.STRIKEPRICE
               else floor(asset.STRIKEPRICE) + ((asset.STRIKEPRICE - floor(asset.STRIKEPRICE)) * 
                    case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
                    (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end)) end
               else asset.STRIKEPRICE end as STRIKE_PRICE
        from Q%%PARAM1%%_%%SHORTSESSIONID%%_W quote_w
        inner join dbo.ASSET_ETD asset on asset.IDASSET = quote_w.IDASSET
        left outer join dbo.ASSET_ETD asset_unl on (quote_w.ASSETCATEGORY_UNL = 'Future' and asset_unl.IDASSET = quote_w.IDASSET_UNL)
        left outer join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
        left outer join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
        order by quote_w.IDASSET_UNL ;

        begin
        for row1 in c1
        loop
          found:= true;
          begin
            select quoteLast.* into quote 
            from
            (
              select quote.*
              from dbo.VW_QUOTE_H quote
              inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = row1.IDASSET)
              where ((quote.QUOTESIDE = 'Mid') or (quote.QUOTESIDE is null) or  (quote.QUOTESIDE = 'OfficialClose') or (quote.QUOTESIDE = 'OfficialSettlement'))
              and (quote.ISENABLED = 1) and (quote.TIME < (posdet.DTMARKET+1)) and (quote.IDASSET = row1.IDASSET_UNL) and (quote.ASSETCATEGORY = row1.ASSETCATEGORY_UNL)
              order by quote.TIME desc, case nvl(quote.QUOTESIDE, 'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc                                     
            ) quoteLast
            where rownum = 1;
            exception when NO_DATA_FOUND then found:= false;
            end;
      
            if (found) then
              update Q%%PARAM1%%_%%SHORTSESSIONID%%_W
              set IDQUOTE_H  = quote.IDQUOTE_H, VALUE = quote.VALUE, TIME = quote.TIME, QUOTESIDE = quote.QUOTESIDE, QUOTETIMING = quote.QUOTETIMING, SOURCE = quote.SOURCE,
              ITM_OTM = 
              ( 
                case
	              when (row1.PUTCALL='1' and row1.STRIKE_PRICE > quote.VALUE) or (row1.PUTCALL='0' and row1.STRIKE_PRICE < quote.VALUE) then 'Out the money'
	              when (row1.PUTCALL='1' and row1.STRIKE_PRICE < quote.VALUE) or (row1.PUTCALL='0' and row1.STRIKE_PRICE > quote.VALUE) then 'In the money'
	              when row1.STRIKE_PRICE = quote.VALUE then 'At the money' else 'N/A' end
              )
                            
              where 
              (IDASSET = row1.IDASSET) and (IDASSET_UNL = row1.IDASSET_UNL) and (ASSETCATEGORY_UNL =row1.ASSETCATEGORY_UNL);
            end if;
        end loop;
      end;
      ]]>
      </Command>
    </sqlCommand>

  </item>

  <item name="CLEARINGBULK_PRESELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
          /* Spheres:Hint ARITHABORT_ON NOPARAMS */
          delete from CLEARINGBULK_%%SHORTSESSIONID%%_W;
        
          insert into CLEARINGBULK_%%SHORTSESSIONID%%_W
          (IDI, IDM, ASSETCATEGORY, IDASSET, IDA_ENTITY, IDA_CSSCUSTODIAN, 
          IDA_DEALER, IDB_DEALER,  IDA_CLEARER, IDB_CLEARER, IDEM, DTENTITY, ISCUSTODIAN,
          QTY_BUY, QTY_SELL)
          select 
          tr.IDI, tr.IDM, tr.ASSETCATEGORY, tr.IDASSET, tr.IDA_ENTITYDEALER as IDA_ENTITY, tr.IDA_CSSCUSTODIAN, 
          tr.IDA_DEALER, tr.IDB_DEALER,  tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDEM, tr.DTENTITY, tr.ISCUSTODIAN,
          sum(case when tr.SIDE = 1 then (tr.QTY - isnull(pab.QTY,0)) else 0 end) as QTY_BUY,
          sum(case when tr.SIDE = 2 then (tr.QTY - isnull(pas.QTY,0)) else 0 end) as QTY_SELL

          from dbo.VW_TRADE_FUNGIBLE tr
          
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr,null)
          %%CC:ITRADEINSTRUMENT_JOIN%%(tr)
          
          left outer join 
          (   
              select pad.IDT_BUY as IDT, sum(pad.QTY) as QTY
              from dbo.POSACTION pa
              inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
              inner join dbo.POSACTIONDET pad   on (pad.IDPA = pa.IDPA)
              inner join dbo.ENTITYMARKET em on (em.IDEM = pr.IDEM)          
              where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY))
              group by pad.IDT_BUY
              
          ) pab  on (pab.IDT = tr.IDT)

          left outer join 
          (   
            select pad.IDT_SELL as IDT, sum(pad.QTY) as QTY
            from dbo.POSACTION pa
            inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
            inner join dbo.POSACTIONDET pad on (pad.IDPA = pa.IDPA)
            inner join dbo.ENTITYMARKET em on (em.IDEM = pr.IDEM)          
            where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY))
            group by pad.IDT_SELL
            
          ) pas  on (pas.IDT = tr.IDT)

          where (tr.DTTRADE <= tr.DTENTITY) and (tr.DTBUSINESS <= tr.DTENTITY) and 
                (tr.IDA_ENTITYDEALER = case when -1=@ENTITY  then tr.IDA_ENTITYDEALER else @ENTITY end) and 
                (tr.IDA_CSSCUSTODIAN = case when (@CSSCUSTODIAN<0) then tr.IDA_CSSCUSTODIAN else @CSSCUSTODIAN end) and 
                (tr.ISCUSTODIAN = case when (@CSSCUSTODIAN=-2) then 0 else tr.ISCUSTODIAN end) and 
                (tr.ISCSS = case when (@CSSCUSTODIAN=-3) then 0 else tr.ISCSS end) and
                (tr.POSKEEPBOOK_DEALER = 1) and (%%SR:TRADEALLOC_WHERE_PREDICATE%%) and (%%CC:ITRADEINSTRUMENT_WHERE_PREDICATE%%)
                
          group by  tr.IDM, tr.DTENTITY, tr.IDI, tr.IDASSET, tr.IDEM, tr.IDA_CSSCUSTODIAN, tr.ASSETCATEGORY,
                    tr.IDA_DEALER, tr.IDB_DEALER, tr.IDA_ENTITYDEALER, 
                    tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDA_ENTITYCLEARER, tr.ISCUSTODIAN
                      
          having  (sum(case when tr.SIDE = 1 then (tr.QTY - isnull(pab.QTY,0)) else 0 end) > 0) and
                  (sum(case when tr.SIDE = 2 then (tr.QTY - isnull(pas.QTY,0)) else 0 end) > 0);
                
        ]]>
      </Command>
    </sqlCommand>
  </item>
</sqlCommands>

