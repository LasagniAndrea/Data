<?xml version="1.0" encoding="utf-8" ?>
<!-- 
FI 20231215 [WI783] DENBULK_PRESELECT : Add table PA%%PARAM1%%_%%SHORTSESSIONID%%_W
FI 20231214 [WI779] DENBULK_PRESELECT : Change in PreselectCommand4
FI 20231213 [WI777] DENBULK_PRESELECT : Change in PreselectCommand2
FI 20231213 [WI776] DENBULK_PRESELECT => join using "or" replaced by an "Union all"
RD 20230601 [26308] POSDET_ALLOC et POSSYNT_ALLOC
- Improvement : Exploitation de tous les prix des SSJ «Certifié» (ISENABLED=1) ou pas
RD 20230529 [26308] POSDET_ALLOC et POSSYNT_ALLOC
- Improvement : Appliquer l'Algorithme de recherche de la cotation du Sous-jacent (voir ci-dessous à la fin des commentaires)
- Improvement : Afficher la valeur attendue pour la colonne Type (QUOTESIDE) si la cotation n'existe pas
- Correction  : Affichage des cotations des SSJ non Future pour Consultation Positions détaillées /Oracle
RD 20230418 [26308] POSDET_ALLOC et POSSYNT_ALLOC : 
- Improvement : Ajout de la colonne quoteOptUnl.QUOTESIDE (Type de cotation du SSJ (OfficialClose ou OfficialSettlement))
- Improvement : Pour les Options avec SSJ Future, déterminer l'indicateur ITM/OTM en utilisant la cotation du type OfficialClose ou OfficialSettlement indiqué sur le DC Option si elle existe
FI 20221207 [XXXXX] FLOWSBYTRADE_SELECT, FLOWSBYTRADEOTC_SELECT Add column TZDLVY
PM 20220202 [XXXXX] RISKPERFORMANCE_SELECT : Ajout trade RISK MISSING et IDSTACTIVATION
FI 20201214 [XXXXX] Gestion de EXISTFKVALUE on POSDET_PRESELECT
FI 20201125 [XXXXX] Introduction de %%CC:ITRADE_JOIN%%(t) (existait en 8.1 sous %%CC:ITRADEINSTRUMENT%%) 
FI 20200820 [25468] Date systèmes en UTC (Usage de .ToUTC())
EG 20191115 [25077] RDBMS : New version of Trades tables architecture (TRADESTSYS merge to TRADE, NEW TABLE TRADEXML)
PL 20181115 [24256] POSSYNT_PRESELECT - Add <choose> on test="{ISWITHLOVUMG}
PL 20181023 PERF Remove (temporarily) ti.DTOUT 
EG 20180906 PERF truncate tables basées sur modèle, DTOUT
FI 20180618 [XXXXX] POSACTIONDET_SELECT Refactoring sous-requête (Abandon de TRADACTOR au profit de TRADEINSTRUMENT)
FI 20180615 [XXXXX] POSSYNT_PRESELECT Refactoring sous-requête Cumul des flux LOV/UMG de manière à s'appuyer sur l'EVENTCLASS RMV (Annulation d'un évènemment)  
FI 20180613 [XXXXX] POSSYNT_PRESELECT, POSDET_PRESELECT Expression Choose sur ISWITHLATETRADE
RD 20180504 [22868] FLOWSBYASSETOTC_SELECT - Gérer SKP comme étant un EVENTCODE et non un EVENTTYPE
RD 20180504 [23119] FLOWSBYASSETOTC_SELECT - Supprimer RMG de la liste des events car il est traité à part pour le prendre uniquement du coté Closing
PM 20171115 [23569] FLOWSBYCURRENCY_SELECT : Add inner join with TRADE in order to add a filter on DTBUSINESS whenever EVENT is used.
CC/PL 20171110 [23533] Consultations timestamp (RISKPERFORMANCE & CASHPAYMENT consultations)
CC/PM 20170925 UPD MPD [23408] - FLOWSBYASSET_SELECT, FLOWSBYCURRENCY_SELECT, CASHBALANCE - Display Equalisation Payment (EventType EQP)
RD 20170629 [23204] CASHBALANCE_SELECT - Ajout "inner join TRADE" pour la table EVENT
CC 20170531 FLOWSBYASSET_SELECT - Add (ar.IDA_ACTOR=rs.IDA_ENTITY) on ACTORROLE join (to avoid duplicates when a client is a client of 2 entities) on query AGGREGATEDATETYPE = 2 (Day to day)
PL 20170523 FLOWSBYASSET_SELECT - Add (ar.IDA_ACTOR=rs.IDA_ENTITY) on ACTORROLE join (to avoid duplicates when a client is a client of 2 entities) on query AGGREGATEDATETYPE = 1 (Period)
PL 20170523 POSACTIONDET_SELECT - Add (ar.IDA_ACTOR=rs.IDA_ENTITY) on ACTORROLE join (to avoid duplicates when a client is a client of 2 entities) 
EG 20170412 [23081] Filtrer les décompensations du jour sur négociations du jour
CC/PL 20170307 [22916] - POSSYNT_PRESELECT, POSDET_PRESELECT & DENBULK_PRESELECT - Prise en compte de DERIVATIVECONTRACT.ITMCONDITION
CC/PL 20170117 [21916] - Rename view VW_TRADE_FUNGIBLE_LIGHT_OTC_SEC to VW_TRADE_FUNGIBLE_LIGHT_OTCSEC (characters limitation ORA)
CC/EG 20170112 [21916] - Replace view for ascending compatibility
                          - VW_TRADE_POSOTC by VW_TRADE_POSOTC_SEC 
                          - VW_TRADE_FUNGIBLE_LIGHT_OTC by VW_TRADE_FUNGIBLE_LIGHT_OTC_SEC
RD 20161031 [22570] DENBULK_PRESELECT (Modify)
FI 20160407 [22064] DENBULK_PRESELECT (Modify)
FI 20160407 [22061] DENBULK_PRESELECT (Modify)
FI 20160229 [21830] POSACTIONDET_PRESELECT, POSACTIONDET_TRADE_PRESELECT (Modify on PRICE Column)
RD 20160215 [21384] POSACTIONDET_OTC_PRESELECT use periode  
RD 20160209 [21384] POSACTIONDET_PRESELECT use periode  
FI 20160205 [XXXXX] DENBULK_PRESELECT ajout <choose> </choose>
FI 20160129 [XXXXX] FLOWSBYASSETOTC_SELECT %%CC:ITRADEINSTRUMENT_JOIN%% utilisé  à un niveau plus bas dans la requête 
CC 20151118 [21489] Add new consultation for flows by asset (OTC) (FLOWSBYASSETOTC_ALLOC)  (using 'choose' functionality)
RD 20150925 [21397] POSDETOTC_ALLOC consultation - Modify POSDETOTC_PRESELECT
FI 20150917 [21312] add choose expression on FLOWSBYCURRENCY_SELECT + usage de TRADEINSTRUMENT à la place de TRADEACTOR
FI 20150917 [21312] add choose expression on RISKPERFORMANCE_SELECT + usage de TRADEINSTRUMENT à la place de TRADEACTOR
FI 20150917 [21312] add choose expression on MCO_RPT_SELECT
FI 20150916 [21312] add choose expression on CASHPAYMENT_SELECT
FI 20150916 [21312] add choose expression on POSACTIONDET_OTC_SELECT et POSACTIONDET_SELECT
FI 20150916 [21312] add choose expression on FLOWSBYCURRENCY_SELECT
FI 20150916 [21312] add choose expression on POSDETOTC_PRESELECT
FI 20150914 [21312] add choose expression on POSDET_PRESELECT et POSSYNT_PRESELECT
CC/PL 20150717 - CASHBALANCE consultation - Add SKP (Safekeeping Payment)
CC/PL/EG/PM 20150616 [21124]  Display flow on new EventClass VAL (ValueDate)
CC/PL 20150515 [20987] Modify MCO_RPT_SELECT
CC/FI 20150513 [XXXXX] Suppression MCO_RPT_FINPER_SELECT et intégration dans MCO_RPT_SELECT
CC/FI 20150513 [20987] Modify MCO_RPT_SELECT
CC/PM 20150330 CASHBALANCE_SELECT - Add LPC/UST (Unsettled Transaction)
PL 20150324 Add BWA
CC 20150323 FLOWSBYCURRENCY_SELECT - Add limitation on EventCode CBS (CashBalanceStream) to display flows on original currency flow
PM 20150212 [20793] Modify FLOWSBYASSET_SELECT : add amount of events RMV in disabled date with inverted payer and receiver and always show disabled events
CC/PL 20150205 [20770] CASHPAYMENT_SELECT  
CC/PL 20150126 CASHPAYMENT_SELECT - Modify join on EVENTENUM to display amount type
CC 20150119 [20689] CASHBALANCE_SELECT - Display flows on ExchangeCashBalanceStream and use ConditionDynamicArg
EG 20150120 [20683] Add DTOBSOLETE to MCO_RPT_SELECT, MCO_RPT_FINPER_SELECT
FI 20150114 [20674] Modify FLOWSBYASSET_SELECT prise en compte des assets tes que mat.MATURITYDATE>=@DATE1
CC 20141215 [20563] use ConditionDynamicArg on FLOWSBYASSET_SELECT
FI 20141215 [20563] use ConditionDynamicArg on POSSYNT_PRESELECT
FI 20141107 [20441] NOPARAMS on POSSYNT_PRESELECT et POSDET_PRESELECT 
FI 20141107 [20441] use %%SR:TRADEALLOC_JOIN%%,%%SR:TRADERISK_JOIN%%  
CC 20141029 POSACTIONDET_OTC_SELECT - End realization
CC 20141016 CASHBALANCE_SELECT - Add new amounts (Fee, Premium, Cash Settlement)
PM 20141010 [18685] Modification of FLOWSBYASSET_SELECT : Exclude TrdType 'OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003)' from "Qty Traded"
PM 20141008 [20405] Add columns LOV_UNIT, LOV_SIGNED, UMG_UNIT, UMG_SIGNED to POSSYNT_PRESELECT
EG 20141002 POSACTIONDET_OTC_SELECT - In progress
CC 20141002 CASHBALANCE_SELECT - Add new amounts (UK method)
FI 20140924 [XXXXX] %%CC:ITRADEINSTRUMENT%% est remplacé par %%CC:ITRADEINSTRUMENT_JOIN%%
CC 20140922 [20351] POSDET_PRESELECT: Add columns IDA_COUNTERPARTY and IDB_COUNTERPARTY
CC 20140922 [20351] POSSYNT_PRESELECT: Add columns IDA_COUNTERPARTY and IDB_COUNTERPARTY
CC 20140819 Add consultation Posting detailed positions (OTC)
FI 20140702 [20161] Modification RISKPERFORMANCE_SELECT considération de la colonne TRADE.TIMING
FI 20140626 [20142] Ajout des mots clés %%CC:ITRADEINSTRUMENT%%
FI 20140428 [19746]
- POSSYNT_PRESELECT : Refactoring dans alimentation des tables temporaires
- POSDET_PRESELECT  : Refactoring dans alimentation des tables temporaires

RD 20140206 [19518] Balances and Movements by currency consultation (FLOWSBYCURRENCY_SELECT)
- Add column COLLATERAL_U (Collateral Used)
- Add column COLLATERAL_U_PREV (Collateral Used(previous amount))
- Rename of column: PREVCOLLATERAL_A to: COLLATERAL_A_PREV

FI 20140122 [] lecture de la colonne EVENTDET_ETD.SETTLTPRICE100
RD 20140121 [19671] Pour les Options avec SSJ Future, déterminer l'indicateur ITM/OTM en tenant compte de la base d'expression du prix de ce SSJ:
-	opérer une conversion si la base diffère de 100 (ex. 32)

CC 20140120 [19510] Flows by asset and Cash Balance consultations
- add column DAILYBALANCE on Cash Balance consultation
- add column CASHFLOW on Flows by asset consultation

RD 20140120 [] Balances and Movements by currency (FLOWSBYCURRENCY_SELECT)
- Rename of columns: INITIALMARGINREQ, MARGINAMOUNT, PREVMARGINAMOUNT
to: MARGINCALL,       MARGINREQ,    MARGINREQ_PREV
Cash balances (CASHBALANCE_SELECT)
- Rename of columns: INITIALMARGINREQ, MARGINAMOUNT
to: MARGINCALL,       MARGINREQ

RD 20140117 [19477] Refactoring of request of Balances and Movements by currency (FLOWSBYCURRENCY_SELECT)
RD 20140106 [19440] Refactoring of request of Balances and Movements by currency (FLOWSBYCURRENCY_SELECT)

RD 20131224 [18679] Financial Statement Member  (FLOWSBYCURRENCY_SELECT)
- Add column COLLATERAL_A (Securities Collateral (available))
- Add column PREVCOLLATERAL_A (Previous Securities Collateral (available))

CC 20131218 [19363] Flows by asset consultation  (FLOWSBYASSET_SELECT)
- rename column FEE to FEEINCLTAXAMOUNT (Fees amount including taxes)
- add column TAXAMOUNT (Taxes amount)
- add column FEEEXCLTAXAMOUNT (Fees amount excluding taxes)

RD 20131007 [18679] Financial Statement Member
EG 20130917 Refactoring complet des requêtes Flux par actifs / Soldes et mouvements par devise
20130704 [18745] MCO_RPT_SELECT add SYNTHESIS

CC 20121106 Add Uncovered initial margin on CASHBALANCE consultation
FI 20120831 [18048]
- add MCO_RPT_FINPER_SELECT => Requête utilisée pour la consultation des messages FINANCIALPERIODIC (extraits de compte)
- mod MCO_RPT_SELECT => La requête n'affiche que les messages ALLOCATION,FINANCIAL,POSITION,POSSYNTHETIC,POSACTION

FI 20120831 [18113] Nouveau Standard, les tables de travail (temporaires) se terminent par _W

FI 20120605
Modification de POSACTIONDET_SELECT, POSACTIONDET_PRESELECT, POSACTIONDET_TRADE_PRESELECT
Ajout de la colonne ITM_OTM

FI 20120601
Modification de POSACTIONDET_SELECT
L'action Transfert s'affiche s'il n'y a aucun changement de book
Côté Client,House
L'action Transfert s'affiche si le book côté dealear a changé
Côté Clearing
L'action Transfert s'affiche si le book côté clearing a changé

FI 20120516 Ajout de POSACTIONDET_TRADE_PRESELECT
utilisé par la consultation 3 boutons enfant de trade

FI 20120515 Refactoring de la consultaion POSACTIONDET
Ajout de POSACTIONDET_PRESELECT
et
Modification de POSACTIONDET_SELECT

FI 20120404 [Refactoring Messagerie Edition]
Reecriture query MCO_RPT_SELECT, utilisation de la colonne MCO.IDB_SENDTOPARTY

FI 20120314 ticket[17721] add prefix dbo. (quote dbo.VW_QUOTE_H%ROWTYPE;)
FI 20120228 Modification ds POSACTIONDET_SELECT (voir le tag concerné)

FI 20111121 Resource xml qui contient une liste de requêtes SQL
de type ReferentialsReferentialSQLSelect (voir cette classe)
Ces requêtes sont susceptibles d'être utilisées par une consultation 3pts ou 5pts

Chaque requête est identifiée via un name
Il existe jusqu'à 4 version d'une même requête (Oracle/sqlServer et SessionRestrict oui/non)
-->

<!-- 
Algorithme de recherche de la cotation du Sous-jacent:

1/ OfficialClose/OfficialSettlement price:
******************************************

  Option AtMaturity
  ..................

  FinalSettltSide Specified
    FinalSettltSide price exists                  : Use FinalSettltSide price
    FinalSettltSide price doesn’t exist           : N/A

  NOT FinalSettltSide Specified
    OfficialSettlement price exists               : Use OfficialSettlement price
    OfficialClose price exists                    : Use OfficialClose price
    else                                          : N/A

  NOT Option AtMaturity
  .....................

    OfficialClose price exists                    : Use OfficialClose price
    else                                          : N/A

2/ Prix des SSJ «Certifié» (ISENABLED=1):
******************************************

  Exploitation de tous les prix des SSJ: «Certifié» (ISENABLED=1) ou pas.


NB: C'est le même algorithme Oracle et SQLServer pour:
- Consultation des Positions détaillées
- Consultation des Positions synthétiques
- Saisie des cours de clôture
-->
<sqlCommands>
  <!--PM 20180704 [XXXXX] Perf: supression LPI et ajout RMV sur Clearer pour les LOV et UMG-->
  <!--EG 20180716 Perf: Implémentation double "WITH" et ajout DTOUT sur TRADE|POSACTION-->

  <!--CC/PL 20180907 Perf: Implémentation choose pour paramètre ISWITHLATETRADE-->
  <!--EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="POSSYNT_PRESELECT">

    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSSYNT_%%SHORTSESSIONID%%_W;
          truncate table POSSYNTQUOTE_%%SHORTSESSIONID%%_W;
        ]]>
      </Command>
      <Command rdbms = "sqlserver">
        <![CDATA[
  /* Spheres:Hint ARITHABORT_ON NOPARAMS */
insert into dbo.POSSYNTTRD_%%SHORTSESSIONID%%_W
(IDT, IDM, IDASSET, IDA_DEALER, IDB_DEALER, IDA_CLEARER, IDB_CLEARER, SIDE, QTY, PRICE)
select t.IDT, t.IDM, t.IDASSET, t.IDA_DEALER, t.IDB_DEALER, t.IDA_CLEARER, t.IDB_CLEARER,
t.SIDE, floor(t.QTY), t.PRICE
from dbo.TRADE t        
%%CC:ITRADE_JOIN%%(t)
inner join dbo.INSTRUMENT ns on (ns.IDI = t.IDI)
inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.GPRODUCT = 'FUT')
inner join dbo.BOOK b on (b.IDB = t.IDB_DEALER)
%%SR:TRADEALLOC_JOIN%%(t.IDT,t,b)
where (t.IDSTACTIVATION = 'REGULAR') and (t.IDSTBUSINESS = 'ALLOC') and
<choose>
	<when test="{ISWITHLATETRADE}=1">
  (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTTRADE &lt;= @DATE1)
	</when>
	<otherwise>
  (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTBUSINESS &lt;= @DATE1)
	</otherwise>
</choose>
and (b.ISPOSKEEPING=1) 
and (%%CC:ITRADE_WHERE_PREDICATE%%)
and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
        
with TRADE_W as 
(
  select * from dbo.POSSYNTTRD_%%SHORTSESSIONID%%_W
),
POSSYNT_W as
(
	select
	tw.IDM, tw.IDASSET, tw.IDA_DEALER, tw.IDB_DEALER, tw.IDA_CLEARER, tw.IDB_CLEARER,
	tw.SIDE, tw.QTY, tw.PRICE,
  isnull(pos.QTY_SELL,0) as QTY_CLEARSELL, isnull(pos.QTY_BUY,0) as QTY_CLEARBUY,
  <choose>
	  <when test="{ISWITHLOVUMG}=1">
	  e_amt.LOV_SIGNED, e_amt.UMG_SIGNED, e_amt.UNIT
	  </when>
	  <otherwise>
    /* choose: LOV and UMG not used */
    convert(int,null) as LOV_SIGNED, convert(int,null) as UMG_SIGNED, null as UNIT
	  </otherwise>
  </choose>
	from TRADE_W tw
  
  left outer join
  (
      select pad.IDT_BUY as IDT, sum(isnull(pad.QTY,0)) as QTY_BUY, 0 as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_BUY = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_BUY

      union all

      select pad.IDT_SELL as IDT, 0 as QTY_BUY, sum(isnull(pad.QTY,0)) as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_SELL = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_SELL
  ) pos on (pos.IDT = tw.IDT)
 
<choose>
 <when test="{ISWITHLOVUMG}=1">
	left outer join
	( 
		select 
		sum(case when ec.EVENTCLASS = 'RMV' then -1 else 1 end * case when e.EVENTTYPE = 'LOV' then case when e.IDA_PAY = alloc.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as LOV_SIGNED,
		sum(case when ec.EVENTCLASS = 'RMV' then -1 else 1 end * case when e.EVENTTYPE = 'UMG' then case when e.IDA_PAY = alloc.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as UMG_SIGNED,
		e.IDT, e.UNIT as UNIT
		from TRADE_W alloc 
		inner join dbo.EVENT e on (e.IDT = alloc.IDT)
		inner join dbo.EVENTCLASS ec on (ec.IDE = e.IDE) and (ec.EVENTCLASS in ('VAL','RMV')) and (ec.DTEVENT = @DATE1)
		where (e.EVENTCODE = 'LPC') and (e.EVENTTYPE in ('LOV','UMG'))
		group by e.IDT, e.UNIT
	) e_amt on (e_amt.IDT = tw.IDT)
  
 </when>
</choose>
	where (tw.QTY - isnull(pos.QTY_BUY,0) - isnull(pos.QTY_SELL,0) > 0)
)
       
insert into POSSYNT_%%SHORTSESSIONID%%_W (
CLIENT_IDA , ACTORSIDE, DATAKEYFIELD, DTBUSINESS, IDASSET,
  IDA_DEALERORCLEARER,IDB_DEALERORCLEARER,
  IDA_COUNTERPARTY, IDB_COUNTERPARTY,
  QTY_BUY,WAVGPRICE_BUY,
  QTY_SELL,WAVGPRICE_SELL,
  SIDE_NET,QTY_NET, IDM,
  LOV_UNIT, LOV_SIGNED, UMG_UNIT, UMG_SIGNED)
  select 
arCLIENT.IDA, rs.ACTORSIDE, rs.DATAKEYFIELD, @DATE1 as DTBUSINESS, rs.IDASSET, 
  rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER,
  rs.IDA_COUNTERPARTY, rs.IDB_COUNTERPARTY,
nullif(rs.QTY_BUY,0) as QTY_BUY, nullif(rs.WAVGPRICE_BUY,0) as WAVGPRICE_BUY, 
nullif(rs.QTY_SELL,0) as QTY_SELL, nullif(rs.WAVGPRICE_SELL,0) as WAVGPRICE_SELL, 
rs.SIDE_NET, rs.QTY_NET, rs.IDM,
rs.LOV_UNIT, rs.LOV_SIGNED,
rs.UMG_UNIT, rs.UMG_SIGNED
  from
  (
  <choose>
  <when test="{ACTORSIDE}=1 or {ACTORSIDE}=0">
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- ************************************************************************************************************************************************************
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  select /*+ ordered */
  1 as ACTORSIDE,
  '1' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' || 
  convert(varchar, po.IDASSET) || '|' || 
  convert(varchar, po.IDB_DEALER) || '|' || 
  convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD, 
  po.IDASSET,
  po.IDA_DEALER as IDA_DEALERORCLEARER,
  po.IDB_DEALER as IDB_DEALERORCLEARER,
  po.IDA_CLEARER as IDA_COUNTERPARTY,
  po.IDB_CLEARER as IDB_COUNTERPARTY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) as QTY_BUY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end),0) as WAVGPRICE_BUY,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) as QTY_SELL,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end),0) as WAVGPRICE_SELL,
  case  when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) > 0 then 'Long'
        when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) &lt; 0 then 'Short'
     else 'Flat' end as SIDE_NET,
  abs(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) as QTY_NET, 
  po.IDM,
  po.UNIT as LOV_UNIT, sum(po.LOV_SIGNED) as LOV_SIGNED,
  po.UNIT as UMG_UNIT, sum(po.UMG_SIGNED) as UMG_SIGNED
  from POSSYNT_W po
  group by po.IDASSET, po.IDA_DEALER, po.IDB_DEALER, po.IDB_CLEARER, po.IDM, po.IDA_CLEARER, po.UNIT
  having 
  (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) > 0)
  or 
  (sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) > 0)
  </when>
  </choose>
  <choose>
  <when test="{ACTORSIDE}=0">
  -- ============================================================================================================================================================                
  union all                
  -- ============================================================================================================================================================                
  </when>
  </choose>
  <choose>
  <when test="{ACTORSIDE}=2 or {ACTORSIDE}=0">
  select /*+ ordered */
  2 as ACTORSIDE,
  '2' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' || 
  convert(varchar, po.IDASSET) || '|' || 
  convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD, 
  po.IDASSET as IDASSET,
  po.IDA_CLEARER as IDA_DEALERORCLEARER,
  po.IDB_CLEARER as IDB_DEALERORCLEARER,
  null as IDA_COUNTERPARTY,
  null as IDB_COUNTERPARTY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) as QTY_BUY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end),0) as WAVGPRICE_BUY,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) as QTY_SELL,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end),0) as WAVGPRICE_SELL,
  case  when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) > 0 then 'Long'
        when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end))  &lt; 0 then 'Short'
     else 'Flat' end as SIDE_NET,
  abs(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) as QTY_NET, 
  po.IDM,
  po.UNIT as LOV_UNIT, sum(po.LOV_SIGNED) as LOV_SIGNED,
  po.UNIT as UMG_UNIT, sum(po.UMG_SIGNED) as UMG_SIGNED
  from POSSYNT_W po
  group by po.IDASSET, po.IDA_CLEARER, po.IDB_CLEARER, po.IDM, po.UNIT
  having 
  (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) > 0)
  or 
  (sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) > 0)
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- ************************************************************************************************************************************************************
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  </when>
  </choose>
  ) rs
left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR = 'CLIENT')) arCLIENT on (arCLIENT.IDA = rs.IDA_DEALERORCLEARER);
			]]>
      </Command>
      <Command rdbms="sqlserver" >
        <![CDATA[
insert into POSSYNTQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL,IDQUOTE_H,VALUE,TIME,QUOTESIDE,QUOTETIMING,SOURCE,ITM_OTM)
select asset_etd.IDASSET,assetQuoteUnl.IDASSET_UNL,assetQuoteUnl.ASSETCATEGORY_UNL,quote_last.IDQUOTE_H,quote_last.VALUE,quote_last.TIME,
isnull(quote_last.QUOTESIDE,case when (assetQuoteUnl.ATMATURITY='1') then assetQuoteUnl.FINALSETTLTSIDE when (assetQuoteUnl.ATMATURITY='0') then 'OfficialClose' else null end) as QUOTESIDE,
quote_last.QUOTETIMING,quote_last.SOURCE,
case  
  -- 1 = Call 
  when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE then 'In the money' 
  when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE then 'Out the money'
  when asset_etd.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE 
    then case when assetQuoteUnl.ITMCONDITION in ('1','2') then 'At the money (ITM)' else 'At the money (OTM)' end
  -- 0 = Put
  when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE then 'In the money'
  when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE then 'Out the money'
  when asset_etd.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE 
    then case when assetQuoteUnl.ITMCONDITION in ('1','3') then 'At the money (ITM)' else 'At the money (OTM)' end
  --
  else 'N/A' 
end as ITM_OTM
from (
  select asset_etd.IDASSET as IDASSET, 
  asset_unl.IDASSET as IDASSET_UNL,'Future' as ASSETCATEGORY_UNL,
  case 
    when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 
      then asset_etd.STRIKEPRICE
    else 
      floor(asset_etd.STRIKEPRICE) + 
      ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE)) * 
      case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
      (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
  end as STRIKE_PRICE, 
  dc_asset.ITMCONDITION as ITMCONDITION,dc_asset.FINALSETTLTSIDE,
  case when isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)= @DATE1 then '1' else '0' end as ATMATURITY,
  (
    select top 1 IDQUOTE_H
    from dbo.VW_QUOTE_H quote
    where (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement')
    and (
      (
        -- AtMaturity :
        -- - FinalSettltSide Specified      :  Use FinalSettltSide price if it exists else N/A
        -- - FinalSettltSide not Specified  :  Use OfficialSettlement price if it exists else use OfficialClose price if it exists else N/A 
        (isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE=isnull(dc_asset.FINALSETTLTSIDE,quote.QUOTESIDE))
      )
      or 
      (
        -- Not AtMaturity :
        -- - Use OfficialClose price if it exists else N/A
        not(isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE='OfficialClose')
      )
    )
    -- and (quote.ISENABLED=1) 
    and quote.TIME < (@DATE1+1)  
    and quote.IDASSET = asset_unl.IDASSET
    and quote.ASSETCATEGORY= 'Future'
    order by quote.TIME desc, 
      case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc
  ) as IDQUOTE_H_UNL
  from dbo.ASSET_ETD asset_etd
  inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
  inner join dbo.MATURITY ma_asset on ma_asset.IDMATURITY=da_asset.IDMATURITY
  inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O' and dc_asset.ASSETCATEGORY='Future'
  inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET = da_asset.IDASSET)
  inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
  inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
  where  exists (select IDASSET from POSSYNT_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET)
    
  union all 
    
  select asset_etd.IDASSET as IDASSET, 
  vw_asset_unl.IDASSET as IDASSET_UNL,vw_asset_unl.ASSETCATEGORY as ASSETCATEGORY_UNL,
  asset_etd.STRIKEPRICE as STRIKE_PRICE, dc_asset.ITMCONDITION as ITMCONDITION,dc_asset.FINALSETTLTSIDE,
  case when (dc_asset.CATEGORY='O') and isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)= @DATE1 then '1' else '0' end as OPT_ATMATURITY,
  (
    select top 1 IDQUOTE_H
    from dbo.VW_QUOTE_H quote
    where (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement')
    and (
      (
        -- AtMaturity :
        -- - FinalSettltSide Specified      :  Use FinalSettltSide price if it exists else N/A
        -- - FinalSettltSide not Specified  :  Use OfficialSettlement price if it exists else use OfficialClose price if it exists else N/A 
        (isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE=isnull(dc_asset.FINALSETTLTSIDE,quote.QUOTESIDE))
      )
      or 
      (
        -- Not AtMaturity :
        -- - Use OfficialClose price if it exists else N/A
        not(isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE='OfficialClose')
      )
    )
    -- and (quote.ISENABLED=1) 
    and quote.TIME < (@DATE1+1)  
    and quote.IDASSET = vw_asset_unl.IDASSET
    and quote.ASSETCATEGORY= vw_asset_unl.ASSETCATEGORY
    order by quote.TIME desc, 
        case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc
  ) as IDQUOTE_H_UNL
  from dbo.ASSET_ETD asset_etd
  inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
  inner join dbo.MATURITY ma_asset on ma_asset.IDMATURITY=da_asset.IDMATURITY
  inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O' and dc_asset.ASSETCATEGORY!='Future'
  inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY and vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL
  where  exists (select IDASSET from POSSYNT_%%SHORTSESSIONID%%_W pos where pos.IDASSET = asset_etd.IDASSET)
) assetQuoteUnl
inner join dbo.ASSET_ETD asset_etd on asset_etd.IDASSET = assetQuoteUnl.IDASSET
left outer join dbo.VW_QUOTE_H quote_last on quote_last.IDQUOTE_H = assetQuoteUnl.IDQUOTE_H_UNL 
and quote_last.IDASSET=assetQuoteUnl.IDASSET_UNL 
and quote_last.ASSETCATEGORY=assetQuoteUnl.ASSETCATEGORY_UNL;      
      ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSSYNT_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSSYNTQUOTE_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
/* Spheres:Hint ARITHABORT_ON NOPARAMS */
insert into POSSYNT_%%SHORTSESSIONID%%_W (
CLIENT_IDA , ACTORSIDE, DATAKEYFIELD, DTBUSINESS, IDASSET,
IDA_DEALERORCLEARER,IDB_DEALERORCLEARER,
IDA_COUNTERPARTY, IDB_COUNTERPARTY,
QTY_BUY,WAVGPRICE_BUY,
QTY_SELL,WAVGPRICE_SELL,
SIDE_NET,QTY_NET, IDM,
LOV_UNIT, LOV_SIGNED, UMG_UNIT, UMG_SIGNED)
with TRADE_W as (
	select 
	t.IDT, t.IDM, t.IDASSET, t.IDA_DEALER, t.IDB_DEALER, t.IDA_CLEARER, t.IDB_CLEARER,
  t.SIDE, floor(t.QTY) as QTY, t.PRICE
	from dbo.TRADE t                                
  %%CC:ITRADE_JOIN%%(t)
	inner join dbo.INSTRUMENT ns on (ns.IDI = t.IDI)
	inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.GPRODUCT = 'FUT')
	inner join dbo.BOOK b on (b.IDB = t.IDB_DEALER)
	%%SR:TRADEALLOC_JOIN%%(t.IDT,t,b)
	where (t.IDSTACTIVATION = 'REGULAR') and (t.IDSTBUSINESS = 'ALLOC') and
	<choose>
	  <when test="{ISWITHLATETRADE}=1">
    (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTTRADE &lt;= @DATE1)
		</when>
		<otherwise>
    (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTBUSINESS &lt;= @DATE1)
		</otherwise>
  </choose>
  and (b.ISPOSKEEPING=1)
  and (%%CC:ITRADE_WHERE_PREDICATE%%)
  and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
),
POSSYNT_W as (
	select
	tw.IDM, tw.IDASSET, tw.IDA_DEALER, tw.IDB_DEALER, tw.IDA_CLEARER, tw.IDB_CLEARER,
	tw.SIDE, tw.QTY, tw.PRICE,
  isnull(pos.QTY_SELL,0) as QTY_CLEARSELL, isnull(pos.QTY_BUY,0) as QTY_CLEARBUY,
  <choose>
	  <when test="{ISWITHLOVUMG}=1">
	  e_amt.LOV_SIGNED, e_amt.UMG_SIGNED, e_amt.UNIT
	  </when>
	  <otherwise>
    /* choose: LOV and UMG not used */
    null as LOV_SIGNED, null as UMG_SIGNED, null as UNIT
	  </otherwise>
  </choose>
	from TRADE_W tw
  
  left outer join
  (
      select pad.IDT_BUY as IDT, sum(isnull(pad.QTY,0)) as QTY_BUY, 0 as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_BUY = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_BUY

      union all

      select pad.IDT_SELL as IDT, 0 as QTY_BUY, sum(isnull(pad.QTY,0)) as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_SELL = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_SELL
  ) pos on (pos.IDT = tw.IDT)
  
<choose>
 <when test="{ISWITHLOVUMG}=1">
	left outer join
	( 
		select 
		sum(case when ec.EVENTCLASS = 'RMV' then -1 else 1 end * case when e.EVENTTYPE = 'LOV' then case when e.IDA_PAY = tw.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as LOV_SIGNED,
		sum(case when ec.EVENTCLASS = 'RMV' then -1 else 1 end * case when e.EVENTTYPE = 'UMG' then case when e.IDA_PAY = tw.IDA_DEALER then -1 else 1 end * e.VALORISATION else 0 end) as UMG_SIGNED,
		e.IDT, e.UNIT as UNIT
    from TRADE_W tw
    inner join dbo.EVENT e on (e.IDT = tw.IDT)
		inner join dbo.EVENTCLASS ec on (ec.IDE = e.IDE) and (ec.EVENTCLASS in ('VAL','RMV')) and (ec.DTEVENT = @DATE1)
		where (e.EVENTCODE = 'LPC') and (e.EVENTTYPE in ('LOV','UMG'))
		group by e.IDT, e.UNIT
	) e_amt on (e_amt.IDT = tw.IDT)

 </when>
</choose>
  where (tw.QTY - isnull(pos.QTY_BUY,0) - isnull(pos.QTY_SELL,0) > 0)
)
select 
arCLIENT.IDA, rs.ACTORSIDE, rs.DATAKEYFIELD, @DATE1 as DTBUSINESS, rs.IDASSET, 
rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER,
rs.IDA_COUNTERPARTY, rs.IDB_COUNTERPARTY,
nullif(rs.QTY_BUY,0) as QTY_BUY, nullif(rs.WAVGPRICE_BUY,0) as WAVGPRICE_BUY, 
nullif(rs.QTY_SELL,0) as QTY_SELL, nullif(rs.WAVGPRICE_SELL,0) as WAVGPRICE_SELL, 
rs.SIDE_NET, rs.QTY_NET, rs.IDM,
rs.LOV_UNIT, rs.LOV_SIGNED,
rs.UMG_UNIT, rs.UMG_SIGNED
from 
(
<choose>
  <when test="{ACTORSIDE}=1 or {ACTORSIDE}=0">
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- ************************************************************************************************************************************************************
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  select /*+ ordered */
  1 as ACTORSIDE,
  '1' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' || 
  convert(varchar, po.IDASSET) || '|' || 
  convert(varchar, po.IDB_DEALER) || '|' || 
  convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD, 
  po.IDASSET,
  po.IDA_DEALER as IDA_DEALERORCLEARER,
  po.IDB_DEALER as IDB_DEALERORCLEARER,
  po.IDA_CLEARER as IDA_COUNTERPARTY,
  po.IDB_CLEARER as IDB_COUNTERPARTY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) as QTY_BUY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end),0) as WAVGPRICE_BUY,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) as QTY_SELL,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end),0) as WAVGPRICE_SELL,
  case  when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) > 0 then 'Long'
        when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) &lt; 0 then 'Short'
        else 'Flat' end as SIDE_NET,
  abs(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) as QTY_NET, 
  po.IDM,
  po.UNIT as LOV_UNIT, sum(po.LOV_SIGNED) as LOV_SIGNED,
  po.UNIT as UMG_UNIT, sum(po.UMG_SIGNED) as UMG_SIGNED
  from POSSYNT_W po
  group by po.IDASSET, po.IDA_DEALER, po.IDB_DEALER, po.IDB_CLEARER, po.IDM, po.IDA_CLEARER, po.UNIT
  having 
  (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) > 0)
  or 
  (sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) > 0)
  </when>
</choose>
<choose>
  <when test="{ACTORSIDE}=0">
  -- ============================================================================================================================================================                
  union all                
  -- ============================================================================================================================================================                
  </when>
</choose>
<choose>
  <when test="{ACTORSIDE}=2 or {ACTORSIDE}=0">
  select /*+ ordered */
  2 as ACTORSIDE,
  '2' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' || 
  convert(varchar, po.IDASSET) || '|' || 
  convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD, 
  po.IDASSET as IDASSET,
  po.IDA_CLEARER as IDA_DEALERORCLEARER,
  po.IDB_CLEARER as IDB_DEALERORCLEARER,
  null as IDA_COUNTERPARTY,
  null as IDB_COUNTERPARTY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) as QTY_BUY,
  sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end),0) as WAVGPRICE_BUY,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) as QTY_SELL,
  sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) * po.PRICE else 0 end)
      / nullif(sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end),0) as WAVGPRICE_SELL,
  case  when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) > 0 then 'Long'
        when (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end))  &lt; 0 then 'Short'
        else 'Flat' end as SIDE_NET,
  abs(sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) - sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end)) as QTY_NET, 
  po.IDM,
  po.UNIT as LOV_UNIT, sum(po.LOV_SIGNED) as LOV_SIGNED,
  po.UNIT as UMG_UNIT, sum(po.UMG_SIGNED) as UMG_SIGNED
  from POSSYNT_W po
  group by po.IDASSET, po.IDA_CLEARER, po.IDB_CLEARER, po.IDM, po.UNIT
  having 
  (sum(case when po.SIDE = '1' then (po.QTY - po.QTY_CLEARBUY) else 0 end) > 0)
  or 
  (sum(case when po.SIDE = '2' then (po.QTY - po.QTY_CLEARSELL) else 0 end) > 0)
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  -- ************************************************************************************************************************************************************
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------
  </when>
</choose>
) rs
left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR = 'CLIENT')) arCLIENT on (arCLIENT.IDA = rs.IDA_DEALERORCLEARER);
			]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
insert into POSSYNTQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL,IDQUOTE_H,VALUE,TIME,QUOTESIDE,QUOTETIMING,SOURCE,ITM_OTM)
select asset_etd.IDASSET as IDASSET,vw_asset_unl.IDASSET,vw_asset_unl.ASSETCATEGORY,null,null,null,null,null,null,null
from dbo.ASSET_ETD asset_etd
inner join dbo.DERIVATIVEATTRIB da_asset on da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB
inner join dbo.DERIVATIVECONTRACT dc_asset on dc_asset.IDDC=da_asset.IDDC and dc_asset.CATEGORY='O'
inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY 
and (
  (dc_asset.ASSETCATEGORY != 'Future' and vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL)
  or
  (dc_asset.ASSETCATEGORY = 'Future' and vw_asset_unl.IDASSET=da_asset.IDASSET)
)
where exists (select 1 from POSSYNT_%%SHORTSESSIONID%%_W pos where (pos.IDASSET=asset_etd.IDASSET));
        ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
declare 
quote dbo.VW_QUOTE_H%ROWTYPE;
found boolean ;  

cursor c1 is
  select possyntquote_w.IDASSET,possyntquote_w.IDASSET_UNL,possyntquote_w.ASSETCATEGORY_UNL,possyntquote_w.IDQUOTE_H,
  asset_etd.PUTCALL,
  case
    when possyntquote_w.ASSETCATEGORY_UNL='Future' then
      case 
        when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 
          then asset_etd.STRIKEPRICE
        else 
          floor(asset_etd.STRIKEPRICE) + 
          ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE)) * 
          case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
          (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
      end
    else 
      asset_etd.STRIKEPRICE 
  end as STRIKE_PRICE,
  dc_asset.ITMCONDITION,dc_asset.FINALSETTLTSIDE,
  case when isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1 then '1' else '0' end as ATMATURITY
  from POSSYNTQUOTE_%%SHORTSESSIONID%%_W possyntquote_w
  inner join dbo.ASSET_ETD asset_etd on (asset_etd.IDASSET=possyntquote_w.IDASSET)
  inner join dbo.DERIVATIVEATTRIB da_asset on (da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB)
  inner join dbo.MATURITY ma_asset on (ma_asset.IDMATURITY=da_asset.IDMATURITY)
  inner join dbo.DERIVATIVECONTRACT dc_asset on (dc_asset.IDDC=da_asset.IDDC) and (dc_asset.CATEGORY='O')
  left outer join dbo.ASSET_ETD asset_unl on ((possyntquote_w.ASSETCATEGORY_UNL='Future') and (asset_unl.IDASSET=possyntquote_w.IDASSET_UNL))
  left outer join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB=asset_unl.IDDERIVATIVEATTRIB)
  left outer join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC=da_unl.IDDC)
  order by possyntquote_w.IDASSET_UNL;

begin
  for row1 in c1
  loop
      found:= true;
        
      begin
        select quoteLast.* into quote 
        from ( 
          select quote.*
          from dbo.VW_QUOTE_H quote
          where ((quote.QUOTESIDE='Mid') or (quote.QUOTESIDE is null) or (quote.QUOTESIDE='OfficialClose') or (quote.QUOTESIDE='OfficialSettlement'))
          and (
            (
              -- AtMaturity :
              -- - FinalSettltSide Specified      :  Use FinalSettltSide price if it exists else N/A
              -- - FinalSettltSide not Specified  :  Use OfficialSettlement price if it exists else use OfficialClose price if it exists else N/A 
              (row1.ATMATURITY='1') and (quote.QUOTESIDE=isnull(row1.FINALSETTLTSIDE,quote.QUOTESIDE))
            )
            or 
            (
              -- Not AtMaturity :
              -- - Use OfficialClose price if it exists else N/A
              (row1.ATMATURITY='0') and (quote.QUOTESIDE='OfficialClose')
            )      
          )
          -- and (quote.ISENABLED=1) 
          and (quote.TIME < ( %%DA:DATE1.GetDataSQLValue()%% +1))
          and (quote.IDASSET=row1.IDASSET_UNL)
          and (quote.ASSETCATEGORY = row1.ASSETCATEGORY_UNL)
          and exists (
            select 1
            from POSSYNTQUOTE_%%SHORTSESSIONID%%_W
            where (IDQUOTE_H is null) and (IDASSET_UNL = row1.IDASSET_UNL) and (ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL)
          )
          order by quote.TIME desc,
            case nvl(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc                                     
        ) quoteLast
        where rownum=1;
      exception
        when NO_DATA_FOUND then
        found:= false;
      end;
  
      if (found) then
        update POSSYNTQUOTE_%%SHORTSESSIONID%%_W
          set IDQUOTE_H  = quote.IDQUOTE_H,
              VALUE = quote.VALUE,
              TIME = quote.TIME,
              QUOTESIDE = quote.QUOTESIDE,
              QUOTETIMING = quote.QUOTETIMING,
              SOURCE = quote.SOURCE,
              ITM_OTM = ( 
                case  
                  -- 1 = Call
                  when row1.PUTCALL='1' and row1.STRIKE_PRICE < quote.VALUE then 'In the money' 
                  when row1.PUTCALL='1' and row1.STRIKE_PRICE > quote.VALUE then 'Out the money'
                  when row1.PUTCALL='1' and row1.STRIKE_PRICE = quote.VALUE 
                    then case when row1.ITMCONDITION in ('1','2') then 'At the money (ITM)' else 'At the money (OTM)' end 
                  -- 0 = Put
                  when row1.PUTCALL='0' and row1.STRIKE_PRICE > quote.VALUE then 'In the money'
                  when row1.PUTCALL='0' and row1.STRIKE_PRICE < quote.VALUE then 'Out the money'
                  when row1.PUTCALL='0' and row1.STRIKE_PRICE = quote.VALUE 
                    then case when row1.ITMCONDITION in ('1','3') then 'At the money (ITM)' else 'At the money (OTM)' end
                  else 'N/A' 
                end
              )
        where (IDASSET=row1.IDASSET)
          and (IDASSET_UNL=row1.IDASSET_UNL)
          and (ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL);
      else
        update POSSYNTQUOTE_%%SHORTSESSIONID%%_W
          set QUOTESIDE = nvl(QUOTESIDE,case when row1.ATMATURITY='1' then row1.FINALSETTLTSIDE when (row1.ATMATURITY='0') then 'OfficialClose' else null end)
        where (IDASSET=row1.IDASSET)
          and (IDASSET_UNL=row1.IDASSET_UNL)
          and (ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL);
      end if;
  end loop;
end;
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--CC/PL 20180907 Perf: Implémentation choose pour paramètre ISWITHLATETRADE-->
  <item name="POSDET_PRESELECT">

    <!-- 
      FI 20140428 [19746] utilisation de la table TRADE à la place de la vue VW_TRADE_POSETD 
      RD 20140717 [20206] Bug: les trades annulés (suite à une CA par exemple) sont chargés dans la consultation des postions
      PM 20180626 [XXXXX] Perf: Refactoring et utilisation instruction WITH pour lire la position détaillée (séparation Oracle SqlServer)
      FI 20140428 [19746] utilisation de union ALL 
      RD 20140606 [19998] Bug: utilisation de "POSDET_" à la place de "POSSYNT_" dans la deuxième requête (union ALL) 
      PM 20180626 [XXXXX] Perf: Refactoring et utilisation instruction WITH pour lire la position détaillée (séparation Oracle SqlServer)
      EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
      -->
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSDET_%%SHORTSESSIONID%%_W;
          truncate table POSDETQUOTE_%%SHORTSESSIONID%%_W;
        ]]>
      </Command>
      <Command rdbms = "sqlserver">
        <![CDATA[
  /* Spheres:Hint ARITHABORT_ON NOPARAMS */
insert into dbo.POSDETTRD_%%SHORTSESSIONID%%_W
(IDT, IDM, IDASSET, IDA_DEALER, IDB_DEALER, IDA_CLEARER, IDB_CLEARER, SIDE, QTY)
select t.IDT, t.IDM, t.IDASSET, t.IDA_DEALER, t.IDB_DEALER, t.IDA_CLEARER, t.IDB_CLEARER,
t.SIDE, floor(t.QTY)
from dbo.TRADE t    
%%CC:ITRADE_JOIN%%(t)
inner join dbo.INSTRUMENT instrument on (instrument.IDI=t.IDI)
inner join dbo.PRODUCT product on (product.IDP=instrument.IDP) and (product.GPRODUCT='FUT')
inner join dbo.BOOK b on (b.IDB=t.IDB_DEALER)
%%SR:TRADEALLOC_JOIN%%(t.IDT,t,b)
where (t.IDSTACTIVATION='REGULAR') and (t.IDSTBUSINESS='ALLOC') and
<choose>
	<when test="{ISWITHLATETRADE}=1">
  (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTTRADE &lt;= @DATE1)
	</when>
	<otherwise>
  (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTBUSINESS &lt;= @DATE1)
	</otherwise>
</choose>
<choose>
	<when test="{EXISTFKVALUE}=1">
    <choose> 
      <when test="{ACTORSIDE_ITEM}=1">
        and (t.IDASSET=@IDASSET) and (t.ASSETCATEGORY='ExchangeTradedContract') and (t.IDB_DEALER=@IDB_DEALER) and (t.IDB_CLEARER=@IDB_CLEARER) 
      </when>  
      <when test="{ACTORSIDE_ITEM}=2">
        and (t.IDASSET=@IDASSET) and (t.ASSETCATEGORY='ExchangeTradedContract') and (t.IDB_CLEARER=@IDB_CLEARER) 
      </when>  
    </choose>  
  </when>
</choose>
and (b.ISPOSKEEPING=1) 
and (%%CC:ITRADE_WHERE_PREDICATE%%)
and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
  
with TRADE_W as 
(
  select * from dbo.POSDETTRD_%%SHORTSESSIONID%%_W
),
POSDET_W as
(
  select tw.IDT, tw.IDM, tw.IDASSET, tw.IDA_DEALER, tw.IDB_DEALER, tw.IDA_CLEARER, tw.IDB_CLEARER,
  tw.SIDE, tw.QTY, tw.QTY - isnull(pos.QTY_SELL, 0) - isnull(pos.QTY_BUY,0) as QTY_POS
  from TRADE_W tw
  left outer join
  (
      select pad.IDT_BUY as IDT, sum(isnull(pad.QTY,0)) as QTY_BUY, 0 as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_BUY = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_BUY

      union all

      select pad.IDT_SELL as IDT, 0 as QTY_BUY, sum(isnull(pad.QTY,0)) as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_SELL = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_SELL
  ) pos on (pos.IDT = tw.IDT)
  
  where (tw.QTY - isnull(pos.QTY_BUY,0) - isnull(pos.QTY_SELL,0) > 0)
)

  insert into POSDET_%%SHORTSESSIONID%%_W
     ( CLIENT_IDA,
       ACTORSIDE,
       DATAKEYFIELD,
       DTBUSINESS,
       IDASSET,
       IDA_DEALERORCLEARER,
       IDB_DEALERORCLEARER,
       IDA_COUNTERPARTY,
       IDB_COUNTERPARTY,
  IDT,
  SIDE,
  QTY_INITIAL,
  QTY_POS, IDM)
select arCLIENT.IDA as CLIENT_IDA,
  rs.ACTORSIDE,           
  rs.DATAKEYFIELD,           
  rs.DTBUSINESS, 
  rs.IDASSET,            
  rs.IDA_DEALERORCLEARER, 
  rs.IDB_DEALERORCLEARER,                
  rs.IDA_COUNTERPARTY, 
  rs.IDB_COUNTERPARTY,
  rs.IDT,                 
  rs.SIDE,                
  rs.QTY_INITIAL, 
  rs.QTY_POS,                
  rs.IDM  
  from                
  (                
    <choose>
    <when test="{ACTORSIDE}=1 or {ACTORSIDE}=0">
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    -- ************************************************************************************************************************************************************                
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------               
    select 1 as ACTORSIDE,           
              '1' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' ||
              convert(varchar, po.IDASSET)   || '|' ||
              convert(varchar, po.IDB_DEALER)|| '|' ||
              convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,
              po.IDASSET,
    @DATE1 as DTBUSINESS,           
              po.IDA_DEALER as IDA_DEALERORCLEARER,
              po.IDB_DEALER as IDB_DEALERORCLEARER,
              po.IDA_CLEARER as IDA_COUNTERPARTY,
              po.IDB_CLEARER as IDB_COUNTERPARTY,
              po.IDT,
              case po.SIDE when '1' then 'Long' else 'Short' end as SIDE, 
              po.QTY as QTY_INITIAL,
              po.QTY_POS,
              po.IDM
         from POSDET_W po
    </when>
    </choose>
    <choose>
    <when test="{ACTORSIDE}=0">
    -- ============================================================================================================================================================                
    union all                
    -- ============================================================================================================================================================                
    </when>
    </choose>
    <choose>
    <when test="{ACTORSIDE}=2 or {ACTORSIDE}=0">
    select 2 as ACTORSIDE,           
              '2' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' ||
              convert(varchar, po.IDASSET) || '|' ||
              convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,
              po.IDASSET,
    @DATE1 as DTBUSINESS,           
              po.IDA_CLEARER as IDA_DEALERORCLEARER,
              po.IDB_CLEARER as IDB_DEALERORCLEARER,
              po.IDA_DEALER as IDA_COUNTERPARTY,
              po.IDB_DEALER as IDB_COUNTERPARTY,
              po.IDT,
              case po.SIDE when '1' then 'Long' else 'Short' end as SIDE, 
              po.QTY as QTY_INITIAL,
              po.QTY_POS,
              po.IDM
         from POSDET_W po
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    -- ************************************************************************************************************************************************************                
    -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
    </when>
    </choose>
  ) rs           
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=rs.IDA_DEALERORCLEARER)
    ]]>
      </Command>
      <Command rdbms = "sqlserver">
        <![CDATA[
insert into POSDETQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL,IDQUOTE_H,VALUE,TIME,QUOTESIDE,QUOTETIMING,SOURCE,ITM_OTM)
select asset_etd.IDASSET,assetQuoteUnl.IDASSET_UNL,assetQuoteUnl.ASSETCATEGORY_UNL,quote_last.IDQUOTE_H,quote_last.VALUE,quote_last.TIME,
isnull(quote_last.QUOTESIDE,case when (assetQuoteUnl.ATMATURITY='1') then assetQuoteUnl.FINALSETTLTSIDE when (assetQuoteUnl.ATMATURITY='0') then 'OfficialClose' else null end) as QUOTESIDE,
quote_last.QUOTETIMING,quote_last.SOURCE,
case  
  -- 1 = Call
  when (asset_etd.PUTCALL='1') and (assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE) then 'Out the money'
  when (asset_etd.PUTCALL='1') and (assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE) then 'In the money' 
  when (asset_etd.PUTCALL='1') and (assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE) 
    then case when (assetQuoteUnl.ITMCONDITION in ('1','2')) then 'At the money (ITM)' else 'At the money (OTM)' end
  -- 0 = Put
  when (asset_etd.PUTCALL='0') and (assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE) then 'In the money'
  when (asset_etd.PUTCALL='0') and (assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE) then 'Out the money'
  when (asset_etd.PUTCALL='0') and (assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE) 
      then case when (assetQuoteUnl.ITMCONDITION in ('1','3')) then 'At the money (ITM)' else 'At the money (OTM)' end
  --
  else 'N/A' 
end as ITM_OTM
from (
  select asset_etd.IDASSET as IDASSET,asset_unl.IDASSET as IDASSET_UNL,'Future' as ASSETCATEGORY_UNL,
  case 
    when ((dc_unl.INSTRUMENTNUM is null) or (dc_unl.INSTRUMENTNUM <= 1)) and (dc_unl.INSTRUMENTDEN >= 100) and (mod(dc_unl.INSTRUMENTDEN,100) = 0)
      then asset_etd.STRIKEPRICE
    else floor(asset_etd.STRIKEPRICE)
        + ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE))
        * case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end
        / (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end))
  end as STRIKE_PRICE, 
  dc_asset.ITMCONDITION as ITMCONDITION,dc_asset.FINALSETTLTSIDE,
  case when isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)= @DATE1 then '1' else '0' end as ATMATURITY,
  ( 
    select top 1 IDQUOTE_H
    from dbo.VW_QUOTE_H quote
    where ((quote.QUOTESIDE is null) or (quote.QUOTESIDE='Mid') or (quote.QUOTESIDE='OfficialClose') or (quote.QUOTESIDE='OfficialSettlement'))    
    and (
      (
        -- AtMaturity :
        -- - FinalSettltSide Specified      :  Use FinalSettltSide price if it exists else N/A
        -- - FinalSettltSide not Specified  :  Use OfficialSettlement price if it exists else use OfficialClose price if it exists else N/A 
        (isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE=isnull(dc_asset.FINALSETTLTSIDE,quote.QUOTESIDE))
      )
      or 
      (
        -- Not AtMaturity :
        -- - Use OfficialClose price if it exists else N/A
        not(isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE='OfficialClose')
      )
    )
    -- and (quote.ISENABLED=1) 
    and (quote.TIME < (@DATE1+1))
    and (quote.IDASSET=asset_unl.IDASSET)
    and (quote.ASSETCATEGORY='Future')
    order by quote.TIME desc, 
      case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc	 				
  ) as IDQUOTE_H_UNL
  from dbo.ASSET_ETD asset_etd
  inner join dbo.DERIVATIVEATTRIB da_asset on (da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB)
  inner join dbo.MATURITY ma_asset on (ma_asset.IDMATURITY=da_asset.IDMATURITY)
  inner join dbo.DERIVATIVECONTRACT dc_asset on (dc_asset.IDDC=da_asset.IDDC) and (dc_asset.CATEGORY='O') and (dc_asset.ASSETCATEGORY='Future')
  inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET=da_asset.IDASSET)
  inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB=asset_unl.IDDERIVATIVEATTRIB)
  inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC=da_unl.IDDC)
  where exists (select IDASSET from POSDET_%%SHORTSESSIONID%%_W pos where (pos.IDASSET=asset_etd.IDASSET))
      
  union all 
    
  select asset_etd.IDASSET as IDASSET,vw_asset_unl.IDASSET as IDASSET_UNL,vw_asset_unl.ASSETCATEGORY as ASSETCATEGORY_UNL,
  asset_etd.STRIKEPRICE as STRIKE_PRICE,dc_asset.ITMCONDITION as ITMCONDITION,dc_asset.FINALSETTLTSIDE,
  case when isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)= @DATE1 then '1' else '0' end as ATMATURITY,
  ( 
    select top 1 IDQUOTE_H
    from dbo.VW_QUOTE_H quote
    where ((quote.QUOTESIDE is null) or (quote.QUOTESIDE='Mid') or (quote.QUOTESIDE='OfficialClose') or (quote.QUOTESIDE='OfficialSettlement'))    
    and (
      (
        -- AtMaturity :
        -- - FinalSettltSide Specified      :  Use FinalSettltSide price if it exists else N/A
        -- - FinalSettltSide not Specified  :  Use OfficialSettlement price if it exists else use OfficialClose price if it exists else N/A 
        (isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE=isnull(dc_asset.FINALSETTLTSIDE,quote.QUOTESIDE))
      )
      or 
      (
        -- Not AtMaturity :
        -- - Use OfficialClose price if it exists else N/A
        not(isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)=@DATE1) and (quote.QUOTESIDE='OfficialClose')
      )
    )
    -- and (quote.ISENABLED=1) 
    and (quote.TIME < (@DATE1+1))
    and (quote.IDASSET=vw_asset_unl.IDASSET)
    and (quote.ASSETCATEGORY=vw_asset_unl.ASSETCATEGORY)
    order by quote.TIME desc, 
      case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc	 				
  ) as IDQUOTE_H_UNL
  from dbo.ASSET_ETD asset_etd
  inner join dbo.DERIVATIVEATTRIB da_asset on (da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB)
  inner join dbo.MATURITY ma_asset on (ma_asset.IDMATURITY=da_asset.IDMATURITY)
  inner join dbo.DERIVATIVECONTRACT dc_asset on (dc_asset.IDDC=da_asset.IDDC) and (dc_asset.CATEGORY='O') and (dc_asset.ASSETCATEGORY!='Future')
  inner join dbo.VW_ASSET vw_asset_unl on (vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY) and (vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL)
  where exists (select IDASSET from POSDET_%%SHORTSESSIONID%%_W pos where (pos.IDASSET=asset_etd.IDASSET))
) assetQuoteUnl
inner join dbo.ASSET_ETD asset_etd on (asset_etd.IDASSET=assetQuoteUnl.IDASSET)
left outer join dbo.VW_QUOTE_H quote_last on (quote_last.IDQUOTE_H=assetQuoteUnl.IDQUOTE_H_UNL)
and (quote_last.IDASSET=assetQuoteUnl.IDASSET_UNL)
and (quote_last.ASSETCATEGORY=assetQuoteUnl.ASSETCATEGORY_UNL);
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSDET_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSDETQUOTE_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
/* Spheres:Hint ARITHABORT_ON NOPARAMS */
insert into POSDET_%%SHORTSESSIONID%%_W
     ( CLIENT_IDA,
       ACTORSIDE,
       DATAKEYFIELD,
       DTBUSINESS,
       IDASSET,
       IDA_DEALERORCLEARER,
       IDB_DEALERORCLEARER,
       IDA_COUNTERPARTY,
       IDB_COUNTERPARTY,
       IDT,
       SIDE,
       QTY_INITIAL,
       QTY_POS, IDM)
with TRADE_W as (
  select t.IDASSET, t.IDA_DEALER, t.IDB_DEALER, t.IDA_CLEARER, t.IDB_CLEARER, t.IDT,
  case t.SIDE when '1' then 'Long' else 'Short' end as SIDE, floor(t.QTY) as QTY_INITIAL, t.IDM
  from dbo.TRADE t    
  %%CC:ITRADE_JOIN%%(t)
  inner join dbo.INSTRUMENT instrument on (instrument.IDI=t.IDI)
  inner join dbo.PRODUCT product on (product.IDP=instrument.IDP) and (product.GPRODUCT='FUT')
  inner join dbo.BOOK b on (b.IDB=t.IDB_DEALER)
  %%SR:TRADEALLOC_JOIN%%(t.IDT,t,b)
  where (t.IDSTACTIVATION='REGULAR') and (t.IDSTBUSINESS='ALLOC') and
  <choose>
    <when test="{ISWITHLATETRADE}=1">
    (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTTRADE &lt;= @DATE1)
    </when>
    <otherwise>
    (t.DTOUT is null or t.DTOUT &gt; @DATE1) and (t.DTBUSINESS &lt;= @DATE1)
    </otherwise>
  </choose>
  <choose>
	  <when test="{EXISTFKVALUE}=1">
      <choose> 
        <when test="{ACTORSIDE_ITEM}=1">
          and (t.IDASSET=@IDASSET) and (t.ASSETCATEGORY='ExchangeTradedContract') and (t.IDB_DEALER=@IDB_DEALER) and (t.IDB_CLEARER=@IDB_CLEARER) 
        </when>  
        <when test="{ACTORSIDE_ITEM}=2">
          and (t.IDASSET=@IDASSET) and (t.ASSETCATEGORY='ExchangeTradedContract') and (t.IDB_CLEARER=@IDB_CLEARER) 
        </when>  
      </choose>  
    </when>
  </choose>
  and (b.ISPOSKEEPING=1)  
  and (%%CC:ITRADE_WHERE_PREDICATE%%)
  and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
),
POSDET_W as (
	select
	tw.IDT, tw.IDM, tw.IDASSET, tw.IDA_DEALER, tw.IDB_DEALER, tw.IDA_CLEARER, tw.IDB_CLEARER,
  tw.SIDE, tw.QTY_INITIAL, tw.QTY_INITIAL - isnull(pos.QTY_SELL, 0) - isnull(pos.QTY_BUY,0) as QTY_POS
	from TRADE_W tw
  left outer join
  (
      select pad.IDT_BUY as IDT, sum(isnull(pad.QTY,0)) as QTY_BUY, 0 as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_BUY = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_BUY

      union all

      select pad.IDT_SELL as IDT, 0 as QTY_BUY, sum(isnull(pad.QTY,0)) as QTY_SELL
      from TRADE_W alloc 
      inner join dbo.POSACTIONDET pad on (pad.IDT_SELL = alloc.IDT)
      inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA)
      where (pa.DTOUT is null or pa.DTOUT > @DATE1) and (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
      group by pad.IDT_SELL
  ) pos on (pos.IDT = tw.IDT)
  
  where (tw.QTY_INITIAL - isnull(pos.QTY_BUY,0) - isnull(pos.QTY_SELL,0) > 0)
 
  )
select arCLIENT.IDA as CLIENT_IDA,
       rs.ACTORSIDE, rs.DATAKEYFIELD, rs.DTBUSINESS, rs.IDASSET,
       rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER,
       rs.IDA_COUNTERPARTY, rs.IDB_COUNTERPARTY,
       rs.IDT, rs.SIDE, rs.QTY_INITIAL, rs.QTY_POS, rs.IDM
from                
(                
<choose>
  <when test="{ACTORSIDE}=1 or {ACTORSIDE}=0">
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
  -- ************************************************************************************************************************************************************                
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------               
  select 1 as ACTORSIDE,           
  '1' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' || convert(varchar, po.IDASSET)   || '|' || 
  convert(varchar, po.IDB_DEALER)|| '|' || convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD, 
  po.IDASSET, @DATE1 as DTBUSINESS,
  po.IDA_DEALER as IDA_DEALERORCLEARER, po.IDB_DEALER as IDB_DEALERORCLEARER,
  po.IDA_CLEARER as IDA_COUNTERPARTY, po.IDB_CLEARER as IDB_COUNTERPARTY,
  po.IDT, po.SIDE, po.QTY_INITIAL, po.QTY_POS, po.IDM
  from POSDET_W po
  </when>
</choose>
<choose>
  <when test="{ACTORSIDE}=0">
  -- ============================================================================================================================================================                
  union all                
  -- ============================================================================================================================================================                
  </when>
</choose>
<choose>
  <when test="{ACTORSIDE}=2 or {ACTORSIDE}=0">
  select 2 as ACTORSIDE,
  '2' || '|' || '%%DA:DATE1.GetDataValue()%%' || '|' || convert(varchar, po.IDASSET) || '|' || convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,
  po.IDASSET, @DATE1 as DTBUSINESS,
  po.IDA_CLEARER as IDA_DEALERORCLEARER, po.IDB_CLEARER as IDB_DEALERORCLEARER,
  po.IDA_DEALER as IDA_COUNTERPARTY, po.IDB_DEALER as IDB_COUNTERPARTY,
  po.IDT, po.SIDE, po.QTY_INITIAL, po.QTY_POS, po.IDM
  from POSDET_W po
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
  -- ************************************************************************************************************************************************************                
  -- ------------------------------------------------------------------------------------------------------------------------------------------------------------                
  </when>
</choose>
) rs           
left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=rs.IDA_DEALERORCLEARER);
 
      ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
insert into POSDETQUOTE_%%SHORTSESSIONID%%_W(IDASSET,IDASSET_UNL,ASSETCATEGORY_UNL,IDQUOTE_H,VALUE,TIME,QUOTESIDE,QUOTETIMING,SOURCE,ITM_OTM)
select asset_etd.IDASSET as IDASSET,vw_asset_unl.IDASSET,vw_asset_unl.ASSETCATEGORY,null,null,null,null,null,null,null
from dbo.ASSET_ETD asset_etd
inner join dbo.DERIVATIVEATTRIB da_asset on (da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB)
inner join dbo.DERIVATIVECONTRACT dc_asset on (dc_asset.IDDC=da_asset.IDDC) and (dc_asset.CATEGORY='O')
inner join dbo.VW_ASSET vw_asset_unl on (vw_asset_unl.ASSETCATEGORY=dc_asset.ASSETCATEGORY)
and (
  ((dc_asset.ASSETCATEGORY!='Future') and (vw_asset_unl.IDASSET=dc_asset.IDASSET_UNL))
  or
  ((dc_asset.ASSETCATEGORY='Future') and (vw_asset_unl.IDASSET=da_asset.IDASSET))
)
where exists (select 1 from POSDET_%%SHORTSESSIONID%%_W pos where (pos.IDASSET=asset_etd.IDASSET));
        ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
declare 
quote dbo.VW_QUOTE_H%ROWTYPE;
found boolean ;  

cursor c1 is
  select posdetquote_w.IDASSET,posdetquote_w.IDASSET_UNL,posdetquote_w.ASSETCATEGORY_UNL,posdetquote_w.IDQUOTE_H,asset_etd.PUTCALL,
  case 
    when posdetquote_w.ASSETCATEGORY_UNL='Future' then
      case 
        when ((dc_unl.INSTRUMENTNUM is null) or (dc_unl.INSTRUMENTNUM <= 1)) and (dc_unl.INSTRUMENTDEN >= 100) and (mod(dc_unl.INSTRUMENTDEN,100) = 0)
          then asset_etd.STRIKEPRICE
        else 
          floor(asset_etd.STRIKEPRICE)
          + ((asset_etd.STRIKEPRICE - floor(asset_etd.STRIKEPRICE))
          * case when (isnull(dc_unl.INSTRUMENTDEN,0) <= 0) then 1 else dc_unl.INSTRUMENTDEN end
          / (100 * case when (isnull(dc_unl.INSTRUMENTNUM,0) = 0) then 1 else dc_unl.INSTRUMENTNUM end))
      end
    else asset_etd.STRIKEPRICE 
  end as STRIKE_PRICE,
  dc_asset.ITMCONDITION,dc_asset.FINALSETTLTSIDE,
  case when isnull(ma_asset.MATURITYDATE,ma_asset.MATURITYDATESYS)= @DATE1 then '1' else '0' end as ATMATURITY
  from POSDETQUOTE_%%SHORTSESSIONID%%_W posdetquote_w
  inner join dbo.ASSET_ETD asset_etd on (asset_etd.IDASSET=posdetquote_w.IDASSET)
  inner join dbo.DERIVATIVEATTRIB da_asset on (da_asset.IDDERIVATIVEATTRIB=asset_etd.IDDERIVATIVEATTRIB)
  inner join dbo.MATURITY ma_asset on (ma_asset.IDMATURITY=da_asset.IDMATURITY)
  inner join dbo.DERIVATIVECONTRACT dc_asset on (dc_asset.IDDC=da_asset.IDDC) and (dc_asset.CATEGORY='O')
  left outer join ( 
    select asset_unl.IDASSET, dc_unl.INSTRUMENTNUM, dc_unl.INSTRUMENTDEN
    from dbo.ASSET_ETD asset_unl
    inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB=asset_unl.IDDERIVATIVEATTRIB)
    inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC=da_unl.IDDC)
  ) dc_unl on (dc_unl.IDASSET=posdetquote_w.IDASSET_UNL) and (posdetquote_w.ASSETCATEGORY_UNL='Future')
  order by posdetquote_w.IDASSET_UNL;

begin
  for row1 in c1
  loop
    begin
      found:= true;
        
      begin
        select quoteLast.* into quote 
        from (
          select quote.*
          from dbo.VW_QUOTE_H quote
          where ((quote.QUOTESIDE is null) or (quote.QUOTESIDE='Mid') or (quote.QUOTESIDE='OfficialClose') or (quote.QUOTESIDE='OfficialSettlement'))
          and (
            (
              -- AtMaturity :
              -- - FinalSettltSide Specified      :  Use FinalSettltSide price if it exists else N/A
              -- - FinalSettltSide not Specified  :  Use OfficialSettlement price if it exists else use OfficialClose price if it exists else N/A 
              (row1.ATMATURITY='1') and (quote.QUOTESIDE=isnull(row1.FINALSETTLTSIDE,quote.QUOTESIDE))
            )
            or 
            (
              -- Not AtMaturity :
              -- - Use OfficialClose price if it exists else N/A
              (row1.ATMATURITY='0') and (quote.QUOTESIDE='OfficialClose')
            )      
          )
          -- and (quote.ISENABLED=1) 
          and (quote.TIME < (%%DA:DATE1.GetDataSQLValue()%% + 1))
          and (quote.IDASSET=row1.IDASSET_UNL)
          and (quote.ASSETCATEGORY=row1.ASSETCATEGORY_UNL)
          and exists (
            select 1
            from POSDETQUOTE_%%SHORTSESSIONID%%_W 
            where (IDQUOTE_H is null) and (IDASSET_UNL=row1.IDASSET_UNL) and (ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL)
          )
          order by quote.TIME desc, 
            case nvl(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc                                     
          ) quoteLast
        where (rownum=1);
      exception
            when NO_DATA_FOUND then
            found:=false;
      end;
  
      if (found) then
        update POSDETQUOTE_%%SHORTSESSIONID%%_W 
        set IDQUOTE_H  = quote.IDQUOTE_H,
            VALUE = quote.VALUE,
            TIME = quote.TIME,
            QUOTESIDE = quote.QUOTESIDE,
            QUOTETIMING = quote.QUOTETIMING,
            SOURCE = quote.SOURCE,
            ITM_OTM = ( 
              case  
                -- 1 = Call
                when row1.PUTCALL='1' and row1.STRIKE_PRICE < quote.VALUE then 'In the money'
                when row1.PUTCALL='1' and row1.STRIKE_PRICE > quote.VALUE then 'Out the money'
                when row1.PUTCALL='1' and row1.STRIKE_PRICE = quote.VALUE 
                  then case when row1.ITMCONDITION in ('1','2') then 'At the money (ITM)' else 'At the money (OTM)' end
                -- 0 = Put
                when row1.PUTCALL='0' and row1.STRIKE_PRICE > quote.VALUE then 'In the money'
                when row1.PUTCALL='0' and row1.STRIKE_PRICE < quote.VALUE then 'Out the money'
                when row1.PUTCALL='0' and row1.STRIKE_PRICE = quote.VALUE 
                  then case when row1.ITMCONDITION in ('1','3') then 'At the money (ITM)' else 'At the money (OTM)' end
                else 'N/A' end                          
          )
          where (IDASSET=row1.IDASSET)
            and (IDASSET_UNL=row1.IDASSET_UNL)
            and (ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL);
      else
        update POSDETQUOTE_%%SHORTSESSIONID%%_W
          set QUOTESIDE = nvl(QUOTESIDE,case when row1.ATMATURITY='1' then row1.FINALSETTLTSIDE when (row1.ATMATURITY='0') then 'OfficialClose' else null end)
        where (IDASSET=row1.IDASSET)
          and (IDASSET_UNL=row1.IDASSET_UNL)
          and (ASSETCATEGORY_UNL=row1.ASSETCATEGORY_UNL);
      end if;
    end;
  end loop;
end;
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--
  CC/PL 20171115 [23533] Consultations timestamp - Suppression de la checkbox ISWITHLATETRADE 
  RD 20150925 [21397] Use alias "b" and "b2" instead of respectively"bk" and "bk2"
                      script of %%SR:TRADEALLOC_WHERE_PREDICATE%% uses alias "b"
  EG 20180710 [XXXXX] Perf: Refactoring et utilisation instruction WITH pour lire la position détaillée (séparation Oracle SqlServer)
  EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
  -->
  <item name="POSDETOTC_PRESELECT">
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSDETOTC_%%SHORTSESSIONID%%_W;
        ]]>
      </Command>
      <Command rdbms = "sqlserver">
        <![CDATA[
/* Spheres:Hint ARITHABORT_ON NOPARAMS */        
with POSDETOTC_W as 
  (                
  select t.IDASSET, t.ASSETCATEGORY, t.IDA_DEALER, t.IDB_DEALER, t.IDA_CLEARER, t.IDB_CLEARER, t.IDT, t.DTBUSINESS, t.DTTRADE,
  t.SIDE,
  floor(t.QTY) as QTY_INITIAL, t.QTY - isnull(pas.QTY,0) - isnull(pab.QTY,0) as QTY_POS, t.IDM, t.DTSETTLT, pr.IDP
  from dbo.TRADE t  
  %%CC:ITRADE_JOIN%%(t)
  inner join dbo.INSTRUMENT ns on (ns.IDI = t.IDI)
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
    <choose>
    <when test="{FILTER_RTSONLY}=1">
      and (pr.GPRODUCT = 'OTC') and (pr.FAMILY = 'RTS')
    </when>
    <when test="{FILTER_DSTONLY}=1">
      and (pr.GPRODUCT = 'SEC') and (pr.FAMILY = 'DSE')
    </when>
    <when test="{FILTER_ESTONLY}=1">
      and (pr.GPRODUCT = 'SEC') and (pr.FAMILY = 'ESE')
    </when>
    <otherwise>
      and (pr.GPRODUCT in ('OTC','SEC', 'FX'))
    </otherwise>
  </choose>
  inner join dbo.BOOK bd on (bd.IDB = t.IDB_DEALER)
  %%SR:TRADEALLOC_JOIN%%(t.IDT,t,bd)

  /* Position en DTBUSINESS   : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTBUSINESS <= DTPOS */ 
  /* Position en DTSETTLEMENT : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) <= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_BUY as IDT,
      <choose>
        <when test="{POSDATETYPE}=0">
        sum(isnull(pad.QTY,0)) as QTY
        </when>
        <when test="{POSDATETYPE}=1">
        sum(case when (isnull(trb.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(trs.DTSETTLT,@DATE1) &lt;= @DATE1) then isnull(pad.QTY,0) else 0 end) as QTY
        </when>
      </choose>
      from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
    <choose>
      <when test="{POSDATETYPE}=1">
		  /* Join: Pour lecture des DTSETTLT du couple IDT_BUY/IDT_SELL */ 
		  left outer join dbo.TRADE trb on (trb.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADE trs on (trs.IDT = pad.IDT_SELL) 
      </when>
    </choose>
		where (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (@DATE1 < pad.DTCAN))
      group by pad.IDT_BUY 
  ) pab on (pab.IDT = t.IDT)                  

  /* Position en DTBUSINESS   : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTBUSINESS <= DTPOS */ 
  /* Position en DTSETTLEMENT : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) <= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_SELL as IDT,
      <choose>
        <when test="{POSDATETYPE}=0">
        sum(isnull(pad.QTY,0)) as QTY
        </when>
        <when test="{POSDATETYPE}=1">
        sum(case when (isnull(trb.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(trs.DTSETTLT,@DATE1) &lt;= @DATE1) then isnull(pad.QTY,0) else 0 end) as QTY
        </when>
      </choose>
      from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
    <choose>
      <when test="{POSDATETYPE}=1">
		  /* Join: Pour lecture des DTSETTLT du couple IDT_BUY/IDT_SELL */ 
		  left outer join dbo.TRADE trb on (trb.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADE trs on (trs.IDT = pad.IDT_SELL) 
      </when>
    </choose>
		where (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (@DATE1 < pad.DTCAN))
		  group by pad.IDT_SELL
    ) pas on (pas.IDT = t.IDT)                  

	/* SI DTBUSINESS : DTBUSINESS (ou DTTRADE si LateTrade) <= @DATE1 */
	/* SI DTSETTLT   : DTSETTLT <= DTPOSITION */
    
  where (t.IDSTACTIVATION = 'REGULAR') and (t.IDSTBUSINESS = 'ALLOC') and 
  <choose>
    <when test="{POSDATETYPE}=0">
      <choose>
        <when test="{ISWITHLATETRADE}=1">
        (t.DTTRADE &lt;= @DATE1)
        </when>
        <otherwise>
        (t.DTBUSINESS &lt;= @DATE1)
        </otherwise>
      </choose>
    </when>
    <when test="{POSDATETYPE}=1">
      <choose>
        <when test="{ISWITHLATETRADE}=1">
        (isnull(t.DTSETTLT, t.DTTRADE) &lt;= @DATE1)
        </when>
        <otherwise>
        (isnull(t.DTSETTLT, t.DTBUSINESS) &lt;= @DATE1)        
        </otherwise>
      </choose>
    </when>
    </choose>
  and (t.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) > 0) 
  and (bd.ISPOSKEEPING = 1)
  and (%%CC:ITRADE_WHERE_PREDICATE%%)
  and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
)
    
insert into POSDETOTC_%%SHORTSESSIONID%%_W
(
  CLIENT_IDA , ACTORSIDE, POSDATETYPE, DATAKEYFIELD, DTTRADE, DTBUSINESS, DTSETTLT, DTPOS, IDASSET, ASSETCATEGORY, 
  IDA_DEALERORCLEARER,IDB_DEALERORCLEARER, IDT, SIDE, QTY_INITIAL, QTY_POS, IDM, IDP
)
select 
arCLIENT.IDA as CLIENT_IDA, rs.ACTORSIDE, rs.POSDATETYPE, rs.DATAKEYFIELD, rs.DTTRADE, rs.DTBUSINESS, rs.DTSETTLT, rs.DTPOS, rs.IDASSET, rs.ASSETCATEGORY,            
rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER, rs.IDT, rs.SIDE, rs.QTY_INITIAL, rs.QTY_POS, rs.IDM, rs.IDP
from 
(
  <choose>
    <when test="{ACTORSIDE}=1 or {ACTORSIDE}=0">
      select 1 as ACTORSIDE, @POSDATETYPE as POSDATETYPE, 
      '1' || '|' || '@POSDATETYPE' || '|' || convert(varchar, po.IDASSET)   || '|' || po.ASSETCATEGORY || '|' || 
      convert(varchar, po.IDB_DEALER)|| '|' || convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,            
      po.DTTRADE, po.DTBUSINESS, po.DTSETTLT, @DATE1 as DTPOS, po.IDASSET, po.ASSETCATEGORY,                 
      po.IDA_DEALER as IDA_DEALERORCLEARER, po.IDB_DEALER as IDB_DEALERORCLEARER, 
      po.IDT, case po.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
      po.QTY_INITIAL, po.QTY_POS, po.IDM, po.IDP                
      from POSDETOTC_W po
    </when>
  </choose> 
    <choose>
    <when test="{ACTORSIDE}=0">
    -- ============================================================================================================================================================                
    union all                
    -- ============================================================================================================================================================                
    </when>
    </choose>
    <choose>
    <when test="{ACTORSIDE}=2 or {ACTORSIDE}=0">
      select 1 as ACTORSIDE, @POSDATETYPE as POSDATETYPE, 
      '2' || '|' || '@POSDATETYPE' || '|' || convert(varchar, po.IDASSET)   || '|' || po.ASSETCATEGORY || '|' || 
      convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,            
      po.DTTRADE, po.DTBUSINESS, po.DTSETTLT, @DATE1 as DTPOS, po.IDASSET, po.ASSETCATEGORY,                 
      po.IDA_CLEARER as IDA_DEALERORCLEARER, po.IDB_CLEARER as IDB_DEALERORCLEARER, 
      po.IDT, case po.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
      po.QTY_INITIAL, po.QTY_POS, po.IDM, po.IDP                
      from POSDETOTC_W po
    </when>
  </choose> 
) rs           
left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR = 'CLIENT')) arCLIENT on (arCLIENT.IDA = rs.IDA_DEALERORCLEARER)
where (('N/A' = @FK) or (rs.DATAKEYFIELD = @FK));
]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSDETOTC_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
insert into POSDETOTC_%%SHORTSESSIONID%%_W
(
  CLIENT_IDA , ACTORSIDE, POSDATETYPE, DATAKEYFIELD, DTTRADE, DTBUSINESS, DTSETTLT, DTPOS, IDASSET, ASSETCATEGORY, 
  IDA_DEALERORCLEARER,IDB_DEALERORCLEARER, IDT, SIDE, QTY_INITIAL, QTY_POS, IDM, IDP
)
with POSDETOTC_W as 
(
  select t.IDASSET, t.ASSETCATEGORY, t.IDA_DEALER, t.IDB_DEALER, t.IDA_CLEARER, t.IDB_CLEARER, t.IDT, t.DTBUSINESS, t.DTTRADE,
  case t.SIDE when '1' then 'Long' else 'Short' end as SIDE,
  floor(t.QTY) as QTY_INITIAL, t.QTY - isnull(pas.QTY,0) - isnull(pab.QTY,0) as QTY_POS, t.IDM, t.DTSETTLT, pr.IDP
  from dbo.TRADE t
  %%CC:ITRADE_JOIN%%(t)
  inner join dbo.INSTRUMENT ns on (ns.IDI = t.IDI)
  inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP)
  <choose> 
    <when test="{FILTER_RTSONLY}=1">
      and (pr.GPRODUCT = 'OTC') and (pr.FAMILY = 'RTS')
    </when>
    <when test="{FILTER_DSTONLY}=1">
      and (pr.GPRODUCT = 'SEC') and (pr.FAMILY = 'DSE')
    </when>
    <when test="{FILTER_ESTONLY}=1">
      and (pr.GPRODUCT = 'SEC') and (pr.FAMILY = 'ESE')
    </when>
    <otherwise>
      and (pr.GPRODUCT in ('OTC','SEC', 'FX'))
    </otherwise>
  </choose>
  inner join dbo.BOOK bd on (bd.IDB = t.IDB_DEALER)
  %%SR:TRADEALLOC_JOIN%%(t.IDT,t,bd)
  
  /* Position en DTBUSINESS   : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTBUSINESS <= DTPOS */ 
  /* Position en DTSETTLEMENT : SUM des QTY(IDT_BUY) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) <= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_BUY as IDT,
    <choose>
      <when test="{POSDATETYPE}=0">
        sum(isnull(pad.QTY,0)) as QTY
      </when>
      <when test="{POSDATETYPE}=1">
        sum(case when (isnull(trb.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(trs.DTSETTLT,@DATE1) &lt;= @DATE1) then isnull(pad.QTY,0) else 0 end) as QTY
      </when>
    </choose>
		  from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
    <choose>
      <when test="{POSDATETYPE}=1">
		    /* Join: Pour lecture des DTSETTLT du couple IDT_BUY/IDT_SELL */ 
		  left outer join dbo.TRADE trb on (trb.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADE trs on (trs.IDT = pad.IDT_SELL) 
      </when>
    </choose>
		where (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (@DATE1 < pad.DTCAN))
      group by pad.IDT_BUY 
  ) pab on (pab.IDT = t.IDT)                  

  /* Position en DTBUSINESS   : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTBUSINESS <= DTPOS */ 
  /* Position en DTSETTLEMENT : SUM des QTY(IDT_SELL) présents dans POSACTIONDET tel que DTSETTLT(IDT_BUY) ET DTSETTLT(IDT_SELL) <= DTPOS */ 
    left outer join 
    (               
      select pad.IDT_SELL as IDT,
    <choose>
      <when test="{POSDATETYPE}=0">
        sum(isnull(pad.QTY,0)) as QTY
      </when>
      <when test="{POSDATETYPE}=1">
        sum(case when (isnull(trb.DTSETTLT,@DATE1) &lt;= @DATE1 and isnull(trs.DTSETTLT,@DATE1) &lt;= @DATE1) then isnull(pad.QTY,0) else 0 end) as QTY
      </when>
    </choose>
		  from dbo.POSACTIONDET pad
		  inner join dbo.POSACTION pa on (pa.IDPA = pad.IDPA) 
    <choose>
      <when test="{POSDATETYPE}=1">
		    /* Join: Pour lecture des DTSETTLT du couple IDT_BUY/IDT_SELL */ 
		  left outer join dbo.TRADE trb on (trb.IDT = pad.IDT_BUY) 
		  left outer join dbo.TRADE trs on (trs.IDT = pad.IDT_SELL) 
      </when>
    </choose>
		where (pa.DTBUSINESS <= @DATE1) and ((pad.DTCAN is null) or (@DATE1 < pad.DTCAN))
		  group by pad.IDT_SELL
    ) pas on (pas.IDT = t.IDT)                  

	/* SI DTBUSINESS : DTBUSINESS (ou DTTRADE si LateTrade) <= @DATE1 */
	/* SI DTSETTLT   : DTSETTLT <= DTPOSITION */

  where (t.IDSTACTIVATION = 'REGULAR') and (t.IDSTBUSINESS = 'ALLOC') and 
  <choose>
    <when test="{POSDATETYPE}=0">
      <choose>
        <when test="{ISWITHLATETRADE}=1">
        (t.DTTRADE &lt;= @DATE1)
        </when>
        <otherwise>
        (t.DTBUSINESS &lt;= @DATE1)
        </otherwise>
      </choose>
    </when>
    <when test="{POSDATETYPE}=1">
      <choose>
        <when test="{ISWITHLATETRADE}=1">
        (isnull(t.DTSETTLT, t.DTTRADE) &lt;= @DATE1)
        </when>
        <otherwise>
        (isnull(t.DTSETTLT, t.DTBUSINESS) &lt;= @DATE1)        
        </otherwise>
      </choose>
    </when>
  </choose>
  and (t.QTY - isnull(pab.QTY,0) - isnull(pas.QTY,0) > 0) 
  and (bd.ISPOSKEEPING = 1)
  and (%%CC:ITRADE_WHERE_PREDICATE%%)
  and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
)
select  arCLIENT.IDA as CLIENT_IDA, rs.ACTORSIDE, rs.POSDATETYPE, rs.DATAKEYFIELD, rs.DTTRADE, rs.DTBUSINESS, rs.DTSETTLT, rs.DTPOS, rs.IDASSET, rs.ASSETCATEGORY,            
rs.IDA_DEALERORCLEARER, rs.IDB_DEALERORCLEARER, rs.IDT, rs.SIDE, rs.QTY_INITIAL, rs.QTY_POS, rs.IDM, rs.IDP
from                
(                
  <choose>
    <when test="{ACTORSIDE}=1 or {ACTORSIDE}=0">
      select 1 as ACTORSIDE, @POSDATETYPE as POSDATETYPE, 
      '1' || '|' || '@POSDATETYPE' || '|' || convert(varchar, po.IDASSET)   || '|' || po.ASSETCATEGORY || '|' || 
      convert(varchar, po.IDB_DEALER)|| '|' || convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,            
      po.DTTRADE, po.DTBUSINESS, po.DTSETTLT, @DATE1 as DTPOS, po.IDASSET, po.ASSETCATEGORY,                 
      po.IDA_DEALER as IDA_DEALERORCLEARER, po.IDB_DEALER as IDB_DEALERORCLEARER, 
      po.IDT, case po.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
      po.QTY_INITIAL, po.QTY_POS, po.IDM, po.IDP                
      from POSDETOTC_W po
    </when>
  </choose>
  <choose>
    <when test="{ACTORSIDE}=0">
      -- ============================================================================================================================================================                
      union all                
      -- ============================================================================================================================================================                
    </when>
  </choose>
  <choose>
    <when test="{ACTORSIDE}=2 or {ACTORSIDE}=0">
      select 1 as ACTORSIDE, @POSDATETYPE as POSDATETYPE, 
      '2' || '|' || '@POSDATETYPE' || '|' || convert(varchar, po.IDASSET)   || '|' || po.ASSETCATEGORY || '|' || 
      convert(varchar, po.IDB_CLEARER) as DATAKEYFIELD,            
      po.DTTRADE, po.DTBUSINESS, po.DTSETTLT, @DATE1 as DTPOS, po.IDASSET, po.ASSETCATEGORY,                 
      po.IDA_CLEARER as IDA_DEALERORCLEARER, po.IDB_CLEARER as IDB_DEALERORCLEARER, 
      po.IDT, case po.SIDE when '1' then 'Long' else 'Short' end as SIDE,           
      po.QTY_INITIAL, po.QTY_POS, po.IDM, po.IDP                
      from POSDETOTC_W po
   </when>
   </choose>
  ) rs     
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=rs.IDA_DEALERORCLEARER)
  where (rs.DATAKEYFIELD = case when 'N/A' = @FK then rs.DATAKEYFIELD else @FK end);
    ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  CC 20170531 FLOWSBYASSET_SELECT - Add (ar.IDA_ACTOR=rs.IDA_ENTITY) on ACTORROLE join (to avoid duplicates when a client is a client of 2 entities) on query AGGREGATEDATETYPE = 2 (Day to day)
  PL 20170523 FLOWSBYASSET_SELECT - Add (ar.IDA_ACTOR=rs.IDA_ENTITY) on ACTORROLE join (to avoid duplicates when a client is a client of 2 entities) on query AGGREGATEDATETYPE = 1 (Period)
  EG 20180628 FLOWSBYASSET_SELECT - Refactoring for performance (Choose...)
  -->
  <item name="FLOWSBYASSET_SELECT">
    <sqlCommand>
      <!--
      AGGREGATEDATETYPE = 1 = Displays flows on period 
      AGGREGATEDATETYPE = 2 = Displays flows day by day 
      PM 20141010 [18685] Exclude TrdType 'OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003)' from "Qty Traded" 
      PM 20150212 [20793] Add amount of events RMV in disabled date with inverted payer and receiver and always show disabled events 
      -->
      <Command rdbms = "all">
        <![CDATA[/* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
        <choose>
          <when test ="{AGGREGATEDATETYPE}=1" >    
		    NULL as DTBUSINESS,
          </when>
          <when test ="{AGGREGATEDATETYPE}=2" >
          rs.DTEVENT as DTBUSINESS,
          </when>
        </choose>
        ar.IDA as arCLIENT_IDA, rs.ACTORSIDE, rs.IDASSET,  rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO,
		    isnull(rs.QTY_BUY,0) as QTY_BUY, isnull(rs.QTY_SELL,0) as QTY_SELL,
		    /* rs.SIDE_NET, */
        rs.UNIT, rs.PREMIUMAMOUNT, rs.CASHSETTLEMENT, rs.EQPAMOUNT, rs.VARMARGINAMOUNT, rs.UNREALMARGINAMOUNT, rs.LOVAMOUNT, rs.REALMARGINAMOUNT, 
        /* rs.FEE, */ 
        rs.FEEINCLTAXAMOUNT,rs.TAXAMOUNT,rs.FEEEXCLTAXAMOUNT,
        rs.IDM, rs.IDA_ENTITY
		    from
		    (
          select /*+ ordered */
          <choose>
            <when test ="{AGGREGATEDATETYPE}=2" >
              result.DTEVENT,
            </when>
          </choose>
			    result.ACTORSIDE, tr.IDM, tr.IDASSET, result.IDA, result.IDB, tr.IDA_ENTITY,
          /* Exclude : OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003) */
          sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0 
              else (
                <choose>
                  <when test ="{AGGREGATEDATETYPE}=1" >
                    case when tr.DTBUSINESS between @DATE1 and @DATE2 then 
					        </when>
                  <when test ="{AGGREGATEDATETYPE}=2" >
                    case when tr.DTBUSINESS = result.DTEVENT then 
                  </when>
                </choose>
                case when tr.SIDE = '1' then floor(tr.QTY) else 0 end else 0 end) end) as QTY_BUY,
          sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0 
              else (
                <choose>
                  <when test ="{AGGREGATEDATETYPE}=1" >
                    case when tr.DTBUSINESS between @DATE1 and @DATE2 then 
					        </when>
                  <when test ="{AGGREGATEDATETYPE}=2" >
                    case when tr.DTBUSINESS = result.DTEVENT then 
                  </when>
                </choose>
                case when tr.SIDE = '2' then floor(tr.QTY) else 0 end else 0 end) end) as QTY_SELL,
          result.UNIT, 
			    sum(result.PREMIUMAMOUNT)      as PREMIUMAMOUNT,      sum(result.CASHSETTLEMENT)     as CASHSETTLEMENT,
			    sum(result.EQPAMOUNT)          as EQPAMOUNT,          sum(result.VARMARGINAMOUNT)    as VARMARGINAMOUNT, 
			    sum(result.UNREALMARGINAMOUNT) as UNREALMARGINAMOUNT, sum(result.LOVAMOUNT)          as LOVAMOUNT,
			    sum(result.REALMARGINAMOUNT)   as REALMARGINAMOUNT,   
          /* sum(result.FEE)                as FEE */
          sum(result.FEEINCLTAXAMOUNT)   as FEEINCLTAXAMOUNT,   sum(result.TAXAMOUNT)          as TAXAMOUNT,
          sum(result.FEEEXCLTAXAMOUNT)   as FEEEXCLTAXAMOUNT
          
			    from dbo.TRADE tr
          %%CC:ITRADE_JOIN%%(tr)
			    inner join dbo.VW_INSTR_PRODUCT pr on ( pr.IDI = tr.IDI) and (pr.FUNGIBILITYMODE != 'NONE') and (pr.GPRODUCT = 'FUT')
			    inner join dbo.BOOK bd on (bd.IDB = tr.IDB_DEALER)
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr,bd)
			    inner join dbo.ASSET_ETD ass_etd   on (ass_etd.IDASSET=tr.IDASSET)
			    inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB=ass_etd.IDDERIVATIVEATTRIB)
			    inner join dbo.MATURITY mat        on (mat.IDMATURITY=da.IDMATURITY)
			    inner join
			    (
				    select 
            <choose>
              <when test ="{AGGREGATEDATETYPE}=2" >
                amt.DTEVENT,
              </when>
            </choose>
            tr.IDA_ENTITY, tr.IDM, amt.ACTORSIDE, tr.IDASSET, tr.IDT, amt.IDA, amt.IDB, amt.UNIT,   
				    sum(case amt.EVENTTYPE when 'PRM' then amt.RESULT_SIGNED else 0 end) as PREMIUMAMOUNT,
				    sum(case amt.EVENTTYPE when 'SCU' then amt.RESULT_SIGNED else 0 end) as CASHSETTLEMENT,
				    sum(case amt.EVENTTYPE when 'EQP' then amt.RESULT_SIGNED else 0 end) as EQPAMOUNT,
				    sum(case amt.EVENTTYPE when 'VMG' then amt.RESULT_SIGNED else 0 end) as VARMARGINAMOUNT,
				    sum(case amt.EVENTTYPE when 'UMG' then amt.RESULT_SIGNED else 0 end) as UNREALMARGINAMOUNT,
				    sum(case amt.EVENTTYPE when 'LOV' then amt.RESULT_SIGNED else 0 end) as LOVAMOUNT,
				    sum(case amt.EVENTTYPE when 'RMG' then amt.RESULT_SIGNED else 0 end) as REALMARGINAMOUNT,
            ( sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) + sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) ) as FEEINCLTAXAMOUNT,
            sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) as TAXAMOUNT,
            sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end)  as FEEEXCLTAXAMOUNT
				    from dbo.TRADE tr
            %%CC:ITRADE_JOIN%%(tr)
				    inner join dbo.VW_INSTR_PRODUCT pr on ( pr.IDI = tr.IDI) and (pr.FUNGIBILITYMODE != 'NONE') and (pr.GPRODUCT = 'FUT')
				    inner join dbo.ASSET_ETD ass_etd   on (ass_etd.IDASSET=tr.IDASSET)
				    inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB=ass_etd.IDDERIVATIVEATTRIB)
				    inner join dbo.MATURITY mat        on (mat.IDMATURITY=da.IDMATURITY)
				    left outer join
				    (
              <choose>
                <when test="{ACTORSIDE}=0 or {ACTORSIDE}=1">
				          /* -- Type:      Dealer */
				      /* -- Montants : OPP-xxx / STA-NOM / xxx-LOV / xxx-PRM / xxx-RMG / xxx-UMG / xxx-VMG */
                  select 
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=2" >
                      ec.DTEVENT,
                    </when>
                  </choose>
                  1 as ACTORSIDE, tr.IDA_DEALER as IDA, tr.IDB_DEALER as IDB, ev.IDT, ev.UNIT, 
					        case when ev.EVENTCODE in ('LPI','OPP','STA') then ev.EVENTCODE else 'EOD' end as EVENTCODE, 
                  case when ev.EVENTTYPE = 'TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE,
					    sum(case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
                      case tr.IDA_DEALER when ev.IDA_PAY then -1 
                                         when ev.IDA_REC then 1 else 0 end * ev.VALORISATION) as RESULT_SIGNED
					    from dbo.EVENT ev
              inner join dbo.TRADE tr on (tr.IDT =  ev.IDT)
					    inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE)  and (ec.EVENTCLASS in ('VAL','RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
					    left outer join dbo.EVENTCLASS ec2 on (ec2.IDE=ec.IDE) and (ec2.EVENTCLASS='STL') and (ec2.ISPAYMENT=1)
					    left outer join dbo.EVENTPOSACTIONDET ep on (ep.IDE=ev.IDE)
              left outer join dbo.POSACTIONDET pa on (pa.IDPADET=ep.IDPADET) and (pa.IDT_CLOSING=ev.IDT)
					    where (
							        (ev.EVENTTYPE in ('PRM', 'VMG') and (ec2.IDE is not null)) or 
							        (ev.EVENTTYPE in ('SCU', 'EQP', 'UMG', 'LOV')) or 
							        ((ev.EVENTTYPE = 'RMG') and (pa.IDPADET is not null)) or 
							        (ev.EVENTCODE = 'OPP') 
                    )
					        group by 
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=2">
                      ec.DTEVENT,
                    </when>
                  </choose>
                  tr.IDA_DEALER, tr.IDB_DEALER, 
                  ev.IDT, ev.UNIT, 
                  case when ev.EVENTCODE in ('LPI','OPP','STA') then ev.EVENTCODE else 'EOD' end,
                  case when ev.EVENTTYPE = 'TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' else ev.EVENTTYPE end
                </when>
            </choose>
          
            <choose>
              <when test="{ACTORSIDE}=0">
              -- ============================================================================================================================================================                
              union all                
              -- ============================================================================================================================================================                
              </when>
            </choose>
          
            <choose>
                <when test="{ACTORSIDE}=0 or {ACTORSIDE}=2">
				          /* -- Type:      Clearer */
				          /* -- Montants : OPP-xxx / STA-NOM / xxx-LOV / xxx-PRM / xxx-RMG / xxx-UMG / xxx-VMG */
                  select 
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=2">
                  ec.DTEVENT, 
                    </when>
                  </choose>
                  2 as ACTORSIDE, tr.IDA_CLEARER as IDA, tr.IDB_CLEARER as IDB, ev.IDT, ev.UNIT, 
					        case when ev.EVENTCODE in ('LPI','OPP','STA') then ev.EVENTCODE else 'EOD' end as EVENTCODE, 
                  case when ev.EVENTTYPE = 'TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE,
                  sum(case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
                      case tr.IDA_CLEARER when ev.IDA_PAY then 1 
                                          when ev.IDA_REC then -1 else 0 end * ev.VALORISATION) as RESULT_SIGNED
                  from dbo.EVENT ev
                  inner join dbo.TRADE tr on (tr.IDT =  ev.IDT)
					        inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE)  and (ec.EVENTCLASS in ('VAL','RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
					        left outer join dbo.EVENTCLASS ec2 on (ec2.IDE=ec.IDE) and (ec2.EVENTCLASS='STL') and (ec2.ISPAYMENT=1)
                  left outer join dbo.EVENTPOSACTIONDET ep on (ep.IDE=ev.IDE)
					        left outer join dbo.POSACTIONDET pa on (pa.IDPADET=ep.IDPADET) and (pa.IDT_CLOSING=ev.IDT)
					        where (
                               (ev.EVENTTYPE in ('PRM', 'VMG') and (ec2.IDE is not null)) or 
                               (ev.EVENTTYPE in ('SCU', 'EQP', 'UMG', 'LOV')) or 
                               ((ev.EVENTTYPE = 'RMG') and (pa.IDPADET is not null)) or 
                               (ev.EVENTCODE = 'OPP') 
                          )
                  group by 
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=2">
                  ec.DTEVENT,
                    </when>
                  </choose>
                  tr.IDA_CLEARER, tr.IDB_CLEARER, 
                  ev.IDT, ev.UNIT, 
                  case when ev.EVENTCODE in ('LPI','OPP','STA') then ev.EVENTCODE else 'EOD' end,
                  case when ev.EVENTTYPE = 'TAX' then 'TAX' when ev.EVENTCODE='OPP' then 'FEE' else ev.EVENTTYPE end
                </when>
            </choose>
              
            <choose>
              <when test="{ACTORSIDE}=0">
              -- ============================================================================================================================================================                
              union all                
              -- ============================================================================================================================================================                
              </when>
            </choose>
                                  
            <choose>
                <when test="{ACTORSIDE}=0 or {ACTORSIDE}=3">
					        /* -- Type:      Exec */
					        /* -- Montants : OPP-xxx */
                  select 
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=2">
                  ec.DTEVENT,
                    </when>
                  </choose>
                  3 as ACTORSIDE, taexec.IDA, taexec.IDB, ev.IDT, ev.UNIT, 
                  'OPP' as EVENTCODE, 
                  case when ev.EVENTTYPE='TAX' then 'TAX' else 'FEE' end as EVENTTYPE,
					        sum(case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
                      case taexec.IDA when ev.IDA_PAY then -1 
                                      when ev.IDA_REC then 1 else 0 end * ev.VALORISATION) as RESULT_SIGNED
                  from dbo.EVENT ev
                  inner join dbo.TRADE tr on (tr.IDT =  ev.IDT)
                  inner join dbo.TRADEACTOR taexec on (taexec.IDT=tr.IDT) and (taexec.IDROLEACTOR='BROKER')   and (taexec.IDA_ACTOR=tr.IDA_CLEARER)
                  inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS in ('VAL','RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
                  where (ev.EVENTCODE = 'OPP')
                  group by 
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=2">
                  ec.DTEVENT,
                    </when>
                  </choose>
                  taexec.IDA, taexec.IDB, 
                  ev.IDT, ev.UNIT, 
                  case when ev.EVENTTYPE='TAX' then 'TAX' else 'FEE' end 
                </when>
              </choose>
                           
				    ) amt on (amt.IDT = tr.IDT)

            where ( (mat.MATURITYDATE>=@DATE1) or (mat.MATURITYDATE is null))
            and (%%CC:ITRADE_WHERE_PREDICATE%%)
				    group by 
            tr.IDA_ENTITY, 
            <choose>
              <when test ="{AGGREGATEDATETYPE}=2" >
                amt.DTEVENT,
              </when>
            </choose>
            tr.IDM, tr.IDASSET, amt.IDA, amt.IDB, amt.ACTORSIDE, amt.UNIT, tr.IDT 
          ) result on (result.IDT = tr.IDT)   
          where (tr.IDSTACTIVATION = 'REGULAR') and (tr.IDSTBUSINESS = 'ALLOC') and
          ( (mat.MATURITYDATE>=@DATE1) or (mat.MATURITYDATE is null)) 
          and (result.ACTORSIDE = case when @ACTORSIDE = 0 then result.ACTORSIDE else @ACTORSIDE end)
            and (bd.ISPOSKEEPING=1)
          and (%%CC:ITRADE_WHERE_PREDICATE%%)
          and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
			    group by tr.IDA_ENTITY, 
          <choose>
            <when test ="{AGGREGATEDATETYPE}=2" >
              result.DTEVENT,
            </when>
          </choose>
          tr.IDM, tr.IDASSET, result.IDA, result.IDB, result.ACTORSIDE, result.UNIT
      ) rs
      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT') and (ar.IDA_ACTOR=rs.IDA_ENTITY)       
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="FLOWSBYASSETOTC_SELECT">
    <sqlCommand>
      <!-- 
      AGGREGATEDATETYPE = 1 = Displays flows on period 
      AGGREGATEDATETYPE = 2 = Displays flows day by day 
      Le detail des Funding (Rate, Spread, etc.) sont affichés uniquement en mode day by day 
      Il est de plus supposé que pour une position donnée et à une date donnée x les caractéristiques sont identiques (=> Usage de l'opérateur max)
      
      CC/PL 20160325 Replace de max(isnull(fdadet.RATE,0)) par avg(fdadet.RATE) pour gérer le cas des taux négatif sur les funding rate
      Idem pour RATE_SPREAD - Besoin d'utiliser une fonction d'agrégation en raison des group by opérés sur la query
      RD 20160404 [20680] Take the Qty of trade only once for AggregateDateType = 2 (Date To Date)
      CC 20160406 [22037] Application de la correction du 20160325 dans toute la query (mise en place du choose pour les données relatives au funding rate)
      RD 20180504 [23119] Supprimer RMG de la liste des events car il est traité à part pour le prendre uniquement du coté Closing
      RD 20180504 [22868] Gérer SKP comme étant un EVENTCODE et non un EVENTTYPE
      EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
      -->
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
        <choose>
          <when test ="{AGGREGATEDATETYPE}=1" >    
          NULL as DTBUSINESS, 
          </when>
          <when test ="{AGGREGATEDATETYPE}=2" >
          rs.DTEVENT as DTBUSINESS,
          </when>
        </choose>
        ar.IDA as arCLIENT_IDA, rs.ACTORSIDE,rs.IDM, rs.IDASSET,  rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO, rs.IDI, rs.ASSETCATEGORY,
        isnull(rs.QTY_BUY,0) as QTY_BUY, isnull(rs.QTY_SELL,0) as QTY_SELL, 
        rs.UNIT, 
        rs.FUNDINGAMOUNT, 
        <choose>
          <when test ="{AGGREGATEDATETYPE}=1" >    
               null as RATE, null as RATE_SPREAD, null as RATE_MULTIPLIER, null as RATE_ASSET_IDENT, null as RATE_ASSET_CATEGORY,
          </when>
          <when test ="{AGGREGATEDATETYPE}=2" >    
              rs.RATE, rs.RATE_SPREAD, rs.RATE_MULTIPLIER, rs.RATE_ASSET_IDENT, rs.RATE_ASSET_CATEGORY,
          </when>
        </choose>
        rs.BORROWINGAMOUNT, rs.VARMARGINAMOUNT, rs.UNREALMARGINAMOUNT, rs.REALMARGINAMOUNT, 
        rs.PRINCIPALAMOUNT, rs.ACCRUEDINTAMOUNT,rs.GROSSAMOUNT, rs.FULLCOUPONAMOUNT, 
        rs.MARKETVALUEAMOUNT,rs.MKVPRINCIPALAMOUNT,rs.MKVACCRUEDINTAMOUNT,
        rs.SAFEKEEPAMOUNT, rs.FEEINCLTAXAMOUNT,rs.TAXAMOUNT,rs.FEEEXCLTAXAMOUNT
        from
	        (
		        select /*+ ordered */
            <choose>
              <when test ="{AGGREGATEDATETYPE}=2" >
              result.DTEVENT,
              </when>
            </choose>
            result.ACTORSIDE, tr.IDM, tr.IDASSET, result.IDA, result.IDB, tr.IDI, tr.ASSETCATEGORY,
            
		        /* Exclude : OptionExercise(45), PositionOpening(1000), Cascading(1001), Shifting(1002), CorporateAction(1003) */
		        sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
		            else (
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=1" >
                      case when tr.DTBUSINESS between @DATE1 and @DATE2 then 
					          </when>
                    <when test ="{AGGREGATEDATETYPE}=2" >
                      case when tr.DTBUSINESS = result.DTEVENT then 
					          </when>
                  </choose>
                    case when tr.SIDE = '1' then tr.QTY else 0 end else 0 end) end) as QTY_BUY,
		        sum(case when tr.TRDTYPE in ('45','1000','1001','1002','1003') then 0
		            else (                  
                  <choose>
                    <when test ="{AGGREGATEDATETYPE}=1" >
                      case when tr.DTBUSINESS between @DATE1 and @DATE2 then 
					          </when>
                    <when test ="{AGGREGATEDATETYPE}=2" >
                      case when tr.DTBUSINESS = result.DTEVENT then 
					          </when>
                  </choose>
                    case when tr.SIDE = '2' then tr.QTY else 0 end else 0 end) end) as QTY_SELL,
		        result.UNIT, 
		        sum(result.FUNDINGAMOUNT)  as FUNDINGAMOUNT,    
            
            <choose>
                <when test ="{AGGREGATEDATETYPE}=1" >
                null as RATE, null as RATE_SPREAD, null as RATE_MULTIPLIER, 
                null as RATE_ASSET_IDENT, null as RATE_ASSET_CATEGORY,
                </when>
                <when test ="{AGGREGATEDATETYPE}=2" >
                avg(result.RATE) as RATE, avg(result.RATE_SPREAD) as RATE_SPREAD, max(result.RATE_MULTIPLIER) as RATE_MULTIPLIER, 
                max(result.RATE_ASSET_IDENT) as RATE_ASSET_IDENT, max(result.RATE_ASSET_CATEGORY) as RATE_ASSET_CATEGORY,
                </when>
            </choose>
            
            sum(result.BORROWINGAMOUNT)    as BORROWINGAMOUNT,
		        sum(result.VARMARGINAMOUNT)    as VARMARGINAMOUNT,  
            sum(result.UNREALMARGINAMOUNT) as UNREALMARGINAMOUNT,
            sum(result.MARKETVALUEAMOUNT)  as MARKETVALUEAMOUNT,
            sum(result.MKVPRINCIPALAMOUNT)  as MKVPRINCIPALAMOUNT,
            sum(result.MKVACCRUEDINTAMOUNT)  as MKVACCRUEDINTAMOUNT,
            sum(result.REALMARGINAMOUNT)   as REALMARGINAMOUNT, 
            sum(result.PRINCIPALAMOUNT)    as PRINCIPALAMOUNT, sum(result.ACCRUEDINTAMOUNT) as ACCRUEDINTAMOUNT, 
            sum(result.GROSSAMOUNT)		     as GROSSAMOUNT,
            sum(result.FULLCOUPONAMOUNT)   as FULLCOUPONAMOUNT,
            sum(result.SAFEKEEPAMOUNT)	   as SAFEKEEPAMOUNT,
		        sum(result.FEEINCLTAXAMOUNT)   as FEEINCLTAXAMOUNT, sum(result.TAXAMOUNT) as TAXAMOUNT,
		        sum(result.FEEEXCLTAXAMOUNT)   as FEEEXCLTAXAMOUNT
            from dbo.VW_TRADE_POSOTC_SEC tr
		        inner join
			            (
				            select  
                    <choose>
                      <when test ="{AGGREGATEDATETYPE}=2" >
                      amt.DTEVENT as DTEVENT,
                      </when>
                    </choose>
                    tr.IDM, amt.ACTORSIDE, tr.IDASSET, tr.IDT, amt.IDA, amt.IDB, tr.IDI, amt.UNIT,   
                    
                    sum(case amt.EVENTTYPE when 'FDA' then amt.RESULT_SIGNED else 0 end) as FUNDINGAMOUNT,
                    
                    <choose>
                        <when test ="{AGGREGATEDATETYPE}=1" >
                        null as RATE, null as RATE_SPREAD, null as RATE_MULTIPLIER, 
                        null as RATE_ASSET_IDENT, null as RATE_ASSET_CATEGORY,
                        </when>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                        avg(amt.RATE) as RATE, avg(amt.RATE_SPREAD) as RATE_SPREAD, max(isnull(amt.RATE_MULTIPLIER,0)) as RATE_MULTIPLIER,
                        max(isnull(amt.RATE_ASSET_IDENT,' ')) as RATE_ASSET_IDENT, max(isnull(amt.RATE_ASSET_CATEGORY,' ')) as RATE_ASSET_CATEGORY,
                        </when>
                    </choose>
                    
				            sum(case amt.EVENTTYPE when 'BWA' then amt.RESULT_SIGNED else 0 end) as BORROWINGAMOUNT,
				            sum(case amt.EVENTTYPE when 'VMG' then amt.RESULT_SIGNED else 0 end) as VARMARGINAMOUNT,
                    sum(case amt.EVENTTYPE when 'UMG' then amt.RESULT_SIGNED else 0 end) as UNREALMARGINAMOUNT,
                    sum(case amt.EVENTTYPE when 'MKV' then amt.RESULT_SIGNED else 0 end) as MARKETVALUEAMOUNT,
                    sum(case amt.EVENTTYPE when 'MKP' then amt.RESULT_SIGNED else 0 end) as MKVPRINCIPALAMOUNT,
                    sum(case amt.EVENTTYPE when 'MKA' then amt.RESULT_SIGNED else 0 end) as MKVACCRUEDINTAMOUNT,
                    sum(case amt.EVENTTYPE when 'RMG' then amt.RESULT_SIGNED else 0 end) as REALMARGINAMOUNT,
					          sum(case amt.EVENTTYPE when 'PAM' then amt.RESULT_SIGNED else 0 end) as PRINCIPALAMOUNT,
                    sum(case amt.EVENTTYPE when 'AIN' then amt.RESULT_SIGNED else 0 end) as ACCRUEDINTAMOUNT,
                    sum(case amt.EVENTTYPE when 'GAM' then amt.RESULT_SIGNED else 0 end) as GROSSAMOUNT,
                    sum(case amt.EVENTTYPE when 'INT' then amt.RESULT_SIGNED else 0 end) as FULLCOUPONAMOUNT,
					          sum(case amt.EVENTTYPE when 'SKP' then amt.RESULT_SIGNED else 0 end) as SAFEKEEPAMOUNT,
					          ( sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end) + 
                      sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) ) as FEEINCLTAXAMOUNT,
					          sum(case amt.EVENTTYPE when 'TAX' then amt.RESULT_SIGNED else 0 end) as TAXAMOUNT,
					          sum(case amt.EVENTTYPE when 'FEE' then amt.RESULT_SIGNED else 0 end)  as FEEEXCLTAXAMOUNT
				            from dbo.VW_TRADE_POSOTC_SEC tr
                    %%CC:ITRADE_JOIN%%(tr)
                    %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr)
                    
					          left outer join
						        (
							        select 
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                        ec.DTEVENT, 
                        </when>
                      </choose>
                      case ta.FIXPARTYROLE when '27' then 1 else 2 end as ACTORSIDE, ev.IDT,   
                      case  when ev.EVENTCODE in ('OPP', 'STA') then  ev.EVENTCODE 
                            else 'EOD' 
                      end as EVENTCODE,
                      case  when ev.EVENTCODE='OPP' then 'FEE'  
                            when ev.EVENTCODE='SKP' then 'SKP' 
                            else ev.EVENTTYPE 
                      end as EVENTTYPE,
                      ta.IDA, ta.IDB,
                      ev.UNIT, 
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=1" >
                          sum(
                          case when ev.EVENTTYPE in ('UMG','MKV','MKP','MKA') then
                               case when ec.DTEVENT = @DATE2 then
                                case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
					                        case when ((ev.IDA_PAY=ta.IDA) and (ta.FIXPARTYROLE='27')) then -1 else 1 end  * ev.VALORISATION
                              else 0 
                              end
                          else 
                            case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
					                        case when ((ev.IDA_PAY=ta.IDA) and (ta.FIXPARTYROLE='27')) then -1 else 1 end  * ev.VALORISATION
                          end ) as RESULT_SIGNED, 
                        </when>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                            sum(
                              case when (ec.EVENTCLASS='RMV') then -1 else 1 end * 
					                    case when ((ev.IDA_PAY=ta.IDA) and (ta.FIXPARTYROLE='27')) then -1 else 1 end  * ev.VALORISATION ) as RESULT_SIGNED, 
                        </when>
                      </choose>
                      
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=1" >
                          null as RATE, null as RATE_SPREAD, null as RATE_MULTIPLIER, 
                          null as RATE_ASSET_IDENT, null as RATE_ASSET_CATEGORY
							          </when>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                          avg(fdadet.RATE) as RATE, avg(fdadet.SPREAD) as RATE_SPREAD, max(isnull(fdadet.MULTIPLIER,0)) as RATE_MULTIPLIER,
                          max(isnull(asset.IDENTIFIER,' ')) as RATE_ASSET_IDENT, max(isnull(asset.ASSETCATEGORY, ' ')) as RATE_ASSET_CATEGORY
							          </when>
                      </choose>
                      
                      from dbo.EVENT ev
							        inner join dbo.TRADEACTOR ta  on (ta.IDT=ev.IDT)  and (ta.IDROLEACTOR='COUNTERPARTY') 
                      <choose>
                         <when test="{ACTORSIDE}=1">   
                            and (ta.FIXPARTYROLE in ('27'))
                         </when>
                         <when test="{ACTORSIDE}=2">   
                            and (ta.FIXPARTYROLE in ('28'))
                         </when>
                         <otherwise>
                            and (ta.FIXPARTYROLE in ('27','28'))
                         </otherwise>
                      </choose>
							        inner join dbo.EVENTCLASS ec  on (ec.IDE=ev.IDE)  and ((ec.EVENTCLASS='VAL') or (ec.EVENTCLASS='RMV')) and (ec.DTEVENT between @DATE1 and @DATE2)
                      
                      left outer join dbo.EVENTPOSACTIONDET ep on (ep.IDE=ev.IDE)
							        left outer join dbo.POSACTIONDET      pa on (pa.IDPADET=ep.IDPADET) and (pa.IDT_CLOSING=ev.IDT)
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                          left outer join dbo.EVENTDET fdadet on (fdadet.IDE=ev.IDE) and (ev.EVENTTYPE='FDA')
					                left outer join dbo.EVENTASSET fdaasset on (fdaasset.IDE=fdadet.IDE) 
					                left outer join dbo.VW_ASSET asset on (asset.IDASSET=fdaasset.IDASSET) and (asset.ASSETCATEGORY=fdaasset.ASSETCATEGORY)
                        </when>
                      </choose>
                      
                      where (
							                (ev.EVENTTYPE in ('FDA', 'BWA', 'VMG','PAM','AIN','GAM','UMG','MKV','MKP','MKA')) or 
                              ((ev.EVENTTYPE = 'RMG') and (pa.IDPADET is not null)) or  /* RMG only on closing Trade */
                              ((ev.EVENTCODE = 'INT') and (ev.EVENTTYPE = 'INT')) or    /* FullCoupon for DebtSecurityTransaction */
							                (ev.EVENTCODE in ('OPP', 'SKP')) 
						                )
                      group by     
                      <choose>
                        <when test ="{AGGREGATEDATETYPE}=2" >
                        ec.DTEVENT, 
                        </when>
                      </choose>
                      ev.IDT, ev.UNIT, ta.IDA, ta.IDB, case ta.FIXPARTYROLE when '27' then 1 else 2 end, 
                      case  when ev.EVENTCODE in ('OPP', 'STA') then  ev.EVENTCODE 
                            else 'EOD' 
                      end,
                      case 
                        when ev.EVENTCODE='OPP' then 'FEE'
                        when ev.EVENTCODE='SKP' then 'SKP' 
                        else ev.EVENTTYPE 
                      end
			        ) amt on (amt.IDT = tr.IDT)
              where 
              (tr.POSKEEPBOOK_DEALER=1)
              and (%%CC:ITRADE_WHERE_PREDICATE%%)
              and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
              group by
               <choose>
                  <when test ="{AGGREGATEDATETYPE}=2" >
                  amt.DTEVENT,
                  </when>
                </choose>
                tr.IDT, tr.IDI, tr.IDM, tr.IDASSET, tr.ASSETCATEGORY, amt.IDA, amt.IDB, amt.ACTORSIDE, amt.UNIT
            ) result on (result.IDT = tr.IDT)	
            
            group by
			      <choose>
              <when test ="{AGGREGATEDATETYPE}=2" >
                result.DTEVENT,
              </when>
            </choose>
            result.IDA, result.IDB, result.ACTORSIDE, result.UNIT, tr.IDI, tr.IDM, tr.IDASSET, tr.ASSETCATEGORY
		      ) rs
      		
		      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')        
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--EG 20130916 Réécriture -->
  <item name="FLOWSBYCURRENCY_SELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select /*+ ordered */
        ar.IDA as arCLIENT_IDA, rs.ACTORSIDE, rs.DTBUSINESS, rs.IDA as IDA_DEALORCLEARORBRO, rs.IDB as IDB_DEALORCLEARORBRO, rs.UNIT, 
        
        rs.VARMARGINAMOUNT, rs.PREMIUMAMOUNT, rs.CASHSETTLEMENT, 
        rs.EQPAMOUNT, rs.INTERESTS, 
        rs.FEE, rs.MARGINCALL, rs.MARGINREQ, 
        rs.DAILYBALANCE, rs.PREVCASHBALANCE, rs.CASHTRANSFER, 
        rs.CASHBALANCE, rs.CASHFLOW, 
        rs.COLLATERAL_A, rs.COLLATERAL_U, 
        rs.PREVCASHB_CASHT,
        
        rs.MARGINREQ_PREV,
        rs.COLLATERAL_A_PREV, 
        rs.COLLATERAL_U_PREV
        
        from
        (              
          /*************************************************************************************************************************************************************
          Affichage des flux par Devise côté Dealer (Client, Maison) & Clearer
          ************************************************************************************************************************************************************ */
          select /*+ ordered */
          tr.DTBUSINESS,
          e_mgr.ACTORSIDE, e_mgr.IDA, e_mgr.IDB, e_mgr.UNIT, 

          sum(VARMARGINAMOUNT) as VARMARGINAMOUNT, sum(PREMIUMAMOUNT) as PREMIUMAMOUNT, sum(CASHSETTLEMENT) as CASHSETTLEMENT,
          sum(EQPAMOUNT) as EQPAMOUNT, sum(INTERESTS) as INTERESTS, 
          sum(FEE) as FEE, sum(MARGINCALL) as MARGINCALL, sum(MARGINREQ) as MARGINREQ, 
          sum(DAILYBALANCE) as DAILYBALANCE, sum(PREVCASHBALANCE) as PREVCASHBALANCE, sum(CASHTRANSFER) as CASHTRANSFER,
          sum(CASHBALANCE) as CASHBALANCE, sum(CASHFLOW) as CASHFLOW, 
          sum(COLLATERAL_A) as COLLATERAL_A, sum(COLLATERAL_U) as COLLATERAL_U, 
          sum(PREVCASHB_CASHT) as PREVCASHB_CASHT,
          
          sum(MARGINREQ_PREV) as MARGINREQ_PREV,
          sum(COLLATERAL_A_PREV) as COLLATERAL_A_PREV, 
          sum(COLLATERAL_U_PREV) as COLLATERAL_U_PREV

          from dbo.TRADE tr
          %%SR:TRADERISK_JOIN%%(tr.IDT, tr)
          inner join dbo.INSTRUMENT i on (i.IDI=tr.IDI)
          inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashBalance')
          inner join 
          ( 
            
            <choose>
            <when test="{ACTORSIDE}=0 or {ACTORSIDE}=1 or {ACTORSIDE}=2">
          
            /* Affichage des flux par Devise côté Dealer/Clearer */ 
            select ev.IDT, ev.UNIT,
            case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end as ACTORSIDE,
            case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end as IDA,
            case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end as IDB,

            sum(case amt.EVENTTYPE when 'VMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as VARMARGINAMOUNT,
            sum(case amt.EVENTTYPE when 'PRM' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREMIUMAMOUNT,
            sum(case amt.EVENTTYPE when 'SCU' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHSETTLEMENT,
            sum(case amt.EVENTTYPE when 'EQP' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQPAMOUNT,
            0 as INTERESTS,
            sum(case amt.EVENTTYPE when 'FEE' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FEE,
            sum(case amt.EVENTTYPE when 'MGC' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARGINCALL,
            sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ,
            sum(case when amt.EVENTTYPE in ('FEE','MGC','PRM','SCU','VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as DAILYBALANCE,
            sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHBALANCE,
            sum(case amt.EVENTTYPE when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then  1 else -1 end) * amt.VALORISATION else 0 end) as CASHTRANSFER,
            sum(case amt.EVENTTYPE when 'CSB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHBALANCE,
            sum(case when amt.EVENTTYPE in ('FEE', 'PRM', 'SCU', 'VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHFLOW,
            sum(case amt.EVENTTYPE when 'CLA' then amt.VALORISATION else 0 end) as COLLATERAL_A,
            sum(case amt.EVENTTYPE when 'CLU' then amt.VALORISATION else 0 end) as COLLATERAL_U,
            sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION
                                   when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHB_CASHT,
                                   
            0 as MARGINREQ_PREV,
            0 as COLLATERAL_A_PREV,
            0 as COLLATERAL_U_PREV
            
            from dbo.EVENT ev  
            inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS = @DTBUSINESS)
            inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='CBS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
            left outer join
            (
              /* -- Montants : OPP-xxx / LPC-VMG / LPC-PRM / LPC-SCU / LPC-MGC / LPC-PCB / LPC-CBP / LPC-CSB / LPC-CLA / LPC-CLU */
              select ev.IDT, case ev.EVENTCODE when 'OPP' then 'FEE' else ev.EVENTTYPE end as EVENTTYPE, 
              ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO 
              from dbo.EVENT ev
              inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS = @DTBUSINESS)
              where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS.ToUTC())) 
                and (
                         (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('CBP','CLA','CLU','CSB','MGC','MGR','PCB','PRM','SCU','VMG','EQP'))
                      or (ev.EVENTCODE = 'OPP')
                     )
            ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
            where (ev.EVENTCODE='LPC') and (ev.EVENTTYPE='MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS.ToUTC()))
            <choose>  
              <when test="{ACTORSIDE}=1">and (ev.IDA_PAY=tr.IDA_RISK)</when>
              <when test="{ACTORSIDE}=2">and (ev.IDA_REC=tr.IDA_RISK)</when>
            </choose> 
            group by ev.IDT, ev.UNIT,
                 case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end,
                 case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end
              
            union all                

            /* Affichage des flux par Devise côté Dealer/Clearer (uniquement les flux issus du trade CB précédent)*/ 
            select ev.IDT, ev.UNIT,
            case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end as ACTORSIDE,
            case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end as IDA,
            case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end as IDB,

            0 as VARMARGINAMOUNT,
            0 as PREMIUMAMOUNT,
            0 as CASHSETTLEMENT,
            0 as EQPAMOUNT,
            0 as INTERESTS,
            0 as FEE,
            0 as MARGINCALL,
            0 as MARGINREQ,
            0 as DAILYBALANCE,
            0 as PREVCASHBALANCE,
            0 as CASHTRANSFER,
            0 as CASHBALANCE,
            0 as CASHFLOW,
            0 as COLLATERAL_A,
            0 as COLLATERAL_U,
            0 as PREVCASHB_CASHT,
            sum(case pamt.EVENTTYPE when 'MGR' then pamt.VALORISATION else 0 end) as MARGINREQ_PREV,
            sum(case pamt.EVENTTYPE when 'CLA' then pamt.VALORISATION else 0 end) as COLLATERAL_A_PREV,
            sum(case pamt.EVENTTYPE when 'CLU' then pamt.VALORISATION else 0 end) as COLLATERAL_U_PREV
            from dbo.EVENT ev  
            inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS = @DTBUSINESS)
            inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.EVENTCODE='CBS') and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
            left outer join 
            ( 
              /* -- Montants : LPC-MGR / LPC-CLA / LPC-CLU */
              select tlink.IDT_A as IDT, ev.EVENTTYPE, 
              ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION, 0) as VALORISATION, ev.STREAMNO 
              from dbo.EVENT ev
              inner join dbo.TRADELINK tlink on (tlink.IDT_B = ev.IDT) and (tlink.LINK = 'PrevCashBalance')
              inner join dbo.TRADE tr on (tr.IDT = tlink.IDT_A) and (tr.DTBUSINESS = @DTBUSINESS)
              where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS.ToUTC())) 
                and (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('MGR','CLA','CLU'))
            ) pamt on (pamt.IDT = ev.IDT) and (pamt.UNIT = ev.UNIT) and (pamt.STREAMNO = ev.STREAMNO)
            where (ev.EVENTCODE='LPC') and (ev.EVENTTYPE='MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS.ToUTC()))
            <choose>  
              <when test="{ACTORSIDE}=1"> and (ev.IDA_PAY=tr.IDA_RISK)</when>
              <when test="{ACTORSIDE}=2"> and (ev.IDA_REC=tr.IDA_RISK)</when>
            </choose>
            group by ev.IDT, ev.UNIT,
                 case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end,
                 case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end,
                 case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end
            </when>
            </choose>
            
            <choose>
              <when test="{ACTORSIDE}=0">
              -- ============================================================================================================================================================                
              union all                
              -- ============================================================================================================================================================                
              </when>
            </choose>

            <choose>
            <when test="{ACTORSIDE}=0 or {ACTORSIDE}=3">
            /* Affichage des flux par Devise côté Executing (uniquement les flux de type OPP) */ 
            select ev.IDT, ev.UNIT, 3 as ACTORSIDE, taexec.IDA, taexec.IDB, 
            
            0 as VARMARGINAMOUNT, 
            0 as PREMIUMAMOUNT, 
            0 as CASHSETTLEMENT, 
            0 as EQPAMOUNT, 
            0 as INTERESTS,
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as FEE, 
            0 as MARGINCALL, 
            0 as MARGINREQ,
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as DAILYBALANCE, 
            0 as PREVCASHBALANCE, 
            0 as CASHTRANSFER,
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as CASHBALANCE, 
            sum(case when ev.IDA_PAY=taexec.IDA then -1 when ev.IDA_REC=taexec.IDA then 1 else 0 end * isnull(ev.VALORISATION,0)) as CASHFLOW, 
            0 as COLLATERAL_A,
            0 as COLLATERAL_U,
            0 as PREVCASHB_CASHT,            
              
            0 as MARGINREQ_PREV,
            0 as COLLATERAL_A_PREV,
            0 as COLLATERAL_U_PREV
            
            from dbo.EVENT ev  
            inner join dbo.TRADE tr             on (tr.IDT = ev.IDT)       and (tr.DTBUSINESS = @DTBUSINESS)
            inner join dbo.TRADEACTOR ta        on (ta.IDT=ev.IDT)         and (ta.IDROLEACTOR='COUNTERPARTY') and (ta.FIXPARTYROLE in ('4','21'))
            inner join dbo.TRADEACTOR taexec    on (taexec.IDT=ta.IDT)     and (taexec.IDROLEACTOR='BROKER')   and (taexec.IDA_ACTOR=ta.IDA)
            inner join dbo.EVENTCLASS ec        on (ec.IDE=ev.IDE)         and (ec.EVENTCLASS='VAL')           and (ec.DTEVENT=@DTBUSINESS)

            where (ev.EVENTCODE = 'OPP') and ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DTBUSINESS.ToUTC()))
                
            group by ev.IDT, ev.UNIT, taexec.IDA, taexec.IDB
            
            </when>
            </choose>

          ) e_mgr on (e_mgr.IDT = tr.IDT)
        	
          where (tr.IDSTACTIVATION='REGULAR') and (tr.DTBUSINESS = @DTBUSINESS) 
          and (e_mgr.ACTORSIDE = case when @ACTORSIDE = 0 then e_mgr.ACTORSIDE else @ACTORSIDE end)
          and (%%SR:TRADERISK_WHERE_PREDICATE%%)
          group by tr.DTBUSINESS, e_mgr.ACTORSIDE, e_mgr.UNIT, e_mgr.IDA, e_mgr.IDB
        ) rs
        left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT')    
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--
  EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
  PM 20220202 [XXXXX] Ajout trade RISK MISSING et IDSTACTIVATION
  -->
  <item name="RISKPERFORMANCE_SELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,            
  case when e_mgr.IDA_PAY= t.IDA_RISK then 1 else 2  end as ACTORSIDE,            
  t.IDI,t.IDT, t.DTBUSINESS, t.DTTIMESTAMP, t.DTORDERENTERED, t.TZFACILITY, t.IDENTIFIER,            
  t.IDA_RISK as IDA_MRO, t.IDB_RISK as IDB_MRO, t.IDSTACTIVATION as IDSTACTIVATION,
  e_mgr.VALORISATION as MARGINAMOUNT, e_mgr.UNIT as MARGINCURRENCY,            
  e_mgr.VALORISATIONSYS as MARGINAMOUNTSYS, e_mgr.UNITSYS as MARGINCURRENCYSYS,            
  case t.TIMING when 'EOD' then 'EndOfDay' else 'Intra-day' end as TIMING,             
  ta_css.IDA as IDA_CSS, ta_ent.IDA as IDA_ENTITY            
  from dbo.TRADE t 
  inner join dbo.INSTRUMENT i on ( i.IDI=t.IDI )            
  inner join dbo.PRODUCT p on ( p.IDP=i.IDP ) and ( p.IDENTIFIER='marginRequirement' )            
  inner join dbo.EVENT e_mgr on e_mgr.IDT=t.IDT and e_mgr.EVENTTYPE='MGR' and e_mgr.IDSTACTIVATION = 'REGULAR'            
  inner join dbo.EVENTCLASS ec_mgr on ec_mgr.IDE=e_mgr.IDE and ec_mgr.EVENTCLASS='REC'            
  <choose>
    <when test ="{POSITIONSIDE}=1" >
      and t.IDA_RISK = e_mgr.IDA_PAY and t.IDB_RISK = e_mgr.IDB_PAY
    </when>
    <when test ="{POSITIONSIDE}=2" >
    and t.IDA_RISK = e_mgr.IDA_REC and t.IDB_RISK = e_mgr.IDB_REC
    </when>
  </choose>
  inner join dbo.TRADEACTOR ta_css on ta_css.IDROLEACTOR='CSS' and ta_css.IDT=t.IDT             
  inner join dbo.TRADEACTOR ta_ent on ta_ent.IDROLEACTOR='ENTITY' and ta_ent.IDT=t.IDT             
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=t.IDA_RISK)
  
  %%SR:TRADERISK_JOIN%%(t.IDT, t)
  where (%%SR:TRADERISK_WHERE_PREDICATE%%) and ((t.IDSTACTIVATION='REGULAR') or (t.IDSTACTIVATION='MISSING'))
  ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--EG 20131120 [19215] Réécriture -->
  <!--RD 20170629 [23204] Ajout "inner join TRADE" pour la table EVENT-->
  <!--EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <!--EG 20201012 [24156] Ajout de la colonne VMG (VARMARGIN) dans la consultation "Garanties/Soldes"-->
  <item name="CASHBALANCE_SELECT">
    <sqlCommand>
      <!-- Flows from ExchangeCashBalanceStream (ECS - on countervalue currency) AND CashBalanceStream (CBS - on original currency flow) -->
      <Command rdbms = "all">
        <![CDATA[
        select /*+ ordered */
        ar.IDA as arCLIENT_IDA, tr.IDT, tr.IDENTIFIER, tr.DTBUSINESS, 
        rs.IDA_ENTITY,            
        rs.ACTORSIDE, rs.RESULTSTYPE,
        rs.IDA as IDA_CBO, rs.IDB as IDB_CBO, rs.UNIT, 
        rs.CASH_A, rs.CASH_U, rs.CASHBALANCE, rs.CASHFLOW, rs.CASHTRANSFER, 
        rs.COLLATERAL_A, rs.COLLATERAL_U, rs.DAILYBALANCE, rs.MARGINCALL, rs.MARGINREQ, 
        rs.PREVCASHBALANCE, rs.UNCOVERMARGINREQ, rs.FEE,rs.PREMIUM,rs.CASHSETTLEMENT,rs.EQPAMOUNT,
        rs.FUNDINGAMOUNT, rs.BORROWINGAMOUNT, rs.SAFEKEEPING, 
        rs.EQUITYBALANCE, rs.FWDCASHPAYMENT, rs.EQUITYBALFWDCASH, rs.EXCESSDEFICIT, 
        rs.EXCESSDEFFWDCASH, rs.CASHDEPOSIT, rs.CASHWITHDRAWAL, rs.LONGOPTIONVALUE, rs.SHORTOPTIONVALUE,
        rs.MARKETVALUE, rs.TOTALACCOUNTVALUE, 
        rs.REALMARGIN, rs.FUTREALMARGIN, rs.OPTREALMARGIN, rs.FSOPTREALMARGIN, rs.PSOPTREALMARGIN,
        rs.UNREALMARGIN, rs.FUTUNREALMARGIN, rs.OPTUNREALMARGIN, rs.FSOPTUNREALMARGIN, rs.PSOPTUNREALMARGIN,
        rs.UNSETTLEDTRANSAC,
        rs.VARMARGIN, 
        rs.MARGINREQ_PREV
    
        from dbo.TRADE tr    
        %%SR:TRADERISK_JOIN%%(tr.IDT, tr)
        inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)            
        inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) and (pr.IDENTIFIER = 'cashBalance')            

        inner join 
        ( 
          select 
          e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB,
          sum(CASH_A) as CASH_A, sum(CASH_U) as CASH_U, sum(CASHBALANCE) as CASHBALANCE, sum(CASHFLOW) as CASHFLOW, sum(CASHTRANSFER) as CASHTRANSFER, 
          sum(COLLATERAL_A) as COLLATERAL_A, sum(COLLATERAL_U) as COLLATERAL_U, sum(DAILYBALANCE) as DAILYBALANCE, sum(MARGINCALL) as MARGINCALL, sum(MARGINREQ) as MARGINREQ, 
          sum(PREVCASHBALANCE) as PREVCASHBALANCE, sum(UNCOVERMARGINREQ) as UNCOVERMARGINREQ, sum(FEE) as FEE, sum(PREMIUM) as PREMIUM, sum(CASHSETTLEMENT) as CASHSETTLEMENT, sum(EQPAMOUNT) as EQPAMOUNT,
          sum(FUNDINGAMOUNT) as FUNDINGAMOUNT, sum(BORROWINGAMOUNT) as BORROWINGAMOUNT, sum(SAFEKEEPING) as SAFEKEEPING, sum(EQUITYBALANCE) as EQUITYBALANCE, sum(FWDCASHPAYMENT) as FWDCASHPAYMENT, sum(EQUITYBALFWDCASH) as EQUITYBALFWDCASH, sum(EXCESSDEFICIT) as EXCESSDEFICIT,
          sum(EXCESSDEFFWDCASH) as EXCESSDEFFWDCASH, sum(CASHDEPOSIT) as CASHDEPOSIT, sum(CASHWITHDRAWAL) as CASHWITHDRAWAL, sum(LONGOPTIONVALUE) as LONGOPTIONVALUE, sum(SHORTOPTIONVALUE) as SHORTOPTIONVALUE,
          sum(MARKETVALUE) as MARKETVALUE, sum(TOTALACCOUNTVALUE) as TOTALACCOUNTVALUE,
          sum(REALMARGIN) as REALMARGIN, sum(FUTREALMARGIN) as FUTREALMARGIN, sum(OPTREALMARGIN) as OPTREALMARGIN, sum(FSOPTREALMARGIN) as FSOPTREALMARGIN, sum(PSOPTREALMARGIN) as PSOPTREALMARGIN,
	        sum(UNREALMARGIN) as UNREALMARGIN, sum(FUTUNREALMARGIN) as FUTUNREALMARGIN, sum(OPTUNREALMARGIN) as OPTUNREALMARGIN, sum(FSOPTUNREALMARGIN) as FSOPTUNREALMARGIN, sum(PSOPTUNREALMARGIN) as PSOPTUNREALMARGIN,
          sum(UNSETTLEDTRANSAC) as UNSETTLEDTRANSAC,
          sum(VARMARGIN) as VARMARGIN, 
	        sum(MARGINREQ_PREV) as MARGINREQ_PREV
      
          from 
          (
              /* 
              -- Type     : Dealer / Clearer 
              -- Montants : Du Cash Balance du jour 
              */
              select 
              ev.IDT, 
              case when e_stream.EVENTCODE = 'CBS' then ev.UNIT else ev.UNIT || ' ' || '(Basis)' end as UNIT, 
              case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end as ACTORSIDE,
              case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end as RESULTSTYPE,
            
              tr.IDA_ENTITY,
              case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end as IDA,
              case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
              sum(case amt.EVENTTYPE when 'CSA' then amt.VALORISATION else 0 end) as CASH_A,
              sum(case amt.EVENTTYPE when 'CSU' then amt.VALORISATION else 0 end) as CASH_U,
              sum(case amt.EVENTTYPE when 'CSB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHBALANCE,
              sum(case when amt.EVENTTYPE in ('ALLFEE', 'PRM', 'SCU', 'VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHFLOW,
              sum(case amt.EVENTTYPE when 'CBP' then (case when ev.IDA_PAY = amt.IDA_PAY then  1 else -1 end) * amt.VALORISATION else 0 end) as CASHTRANSFER,
              sum(case amt.EVENTTYPE when 'CLA' then amt.VALORISATION else 0 end) as COLLATERAL_A,
              sum(case amt.EVENTTYPE when 'CLU' then amt.VALORISATION else 0 end) as COLLATERAL_U,      
              sum(case when amt.EVENTTYPE in ('ALLFEE','MGC','PRM','SCU','VMG') then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as DAILYBALANCE,
              sum(case amt.EVENTTYPE when 'MGC' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARGINCALL,
              sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ,      
              sum(case amt.EVENTTYPE when 'PCB' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREVCASHBALANCE,
              sum(case amt.EVENTTYPE when 'UMR' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNCOVERMARGINREQ,                                   
              sum(case amt.EVENTTYPE when 'ALLFEE' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FEE,
              sum(case amt.EVENTTYPE when 'PRM' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PREMIUM,
              sum(case amt.EVENTTYPE when 'SCU' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as CASHSETTLEMENT,
              sum(case amt.EVENTTYPE when 'EQP' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQPAMOUNT,
              sum(case amt.EVENTTYPE when 'FDA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUNDINGAMOUNT,
              sum(case amt.EVENTTYPE when 'BWA' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as BORROWINGAMOUNT,
              sum(case amt.EVENTTYPE when 'SKP' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SAFEKEEPING,
              sum(case amt.EVENTTYPE when 'E_B' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALANCE,
              sum(case amt.EVENTTYPE when 'FCP' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as FWDCASHPAYMENT,
              sum(case amt.EVENTTYPE when 'EBF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EQUITYBALFWDCASH,
              sum(case amt.EVENTTYPE when 'E_D' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFICIT,
              sum(case amt.EVENTTYPE when 'EDF' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as EXCESSDEFFWDCASH,
              sum(case amt.EVENTTYPE when 'CSD' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHDEPOSIT,
              sum(case amt.EVENTTYPE when 'CSW' then (case when ev.IDA_PAY = amt.IDA_PAY then 1 else -1 end) * amt.VALORISATION else 0 end) as CASHWITHDRAWAL,
              sum(case amt.EVENTTYPE when 'OVL' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as LONGOPTIONVALUE,
              sum(case amt.EVENTTYPE when 'OVS' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as SHORTOPTIONVALUE,
              sum(case amt.EVENTTYPE when 'MKV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as MARKETVALUE,
              sum(case amt.EVENTTYPE when 'TAV' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as TOTALACCOUNTVALUE,
              --RMG total sans distinction sur la CATEGORY (Future/Option) 
              sum(case amt.EVENTTYPE when 'RMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as REALMARGIN,
              --RMG sur Future uniquement
              sum(case amt.EVENTTYPE when 'FUTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTREALMARGIN,
              --RMG sur Option uniquement
              sum(case amt.EVENTTYPE when 'OPTRMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTREALMARGIN,
              --RMG sur Futures Style Option uniquement
              sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTREALMARGIN,        
              --RMG sur Premium Style Option uniquement
              sum(case when amt.EVENTTYPE= 'OPTRMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTREALMARGIN,
              --UMG total sans disctinction sur la CATEGORY (Future/Option) 
              sum(case amt.EVENTTYPE when 'UMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNREALMARGIN,
              --UMG sur Future uniquement
              sum(case amt.EVENTTYPE when 'FUTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FUTUNREALMARGIN,
              --UMG sur Option uniquement
              sum(case amt.EVENTTYPE when 'OPTUMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as OPTUNREALMARGIN,
              --UMG sur Futures Style Option uniquement
              sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='FSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as FSOPTUNREALMARGIN,
              --UMG sur Premium Style Option uniquement
              sum(case when amt.EVENTTYPE= 'OPTUMG' and amt.EVENT_PARENT='PSO' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as PSOPTUNREALMARGIN,
              sum(case amt.EVENTTYPE when 'UST' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as UNSETTLEDTRANSAC,
              --VMG total sans distinction sur la CATEGORY (Future/Option) 
              sum(case amt.EVENTTYPE when 'VMG' then (case when ev.IDA_PAY = amt.IDA_PAY then -1 else 1 end) * amt.VALORISATION else 0 end) as VARMARGIN,
              0 as MARGINREQ_PREV
        
              from dbo.EVENT ev  
              inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS between @DATE1 and @DATE2)
            
              inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
              
              <choose>
                <when test="{RESULTSTYPE}=0">
                  and (e_stream.EVENTCODE in ('CBS','ECS'))
                </when>
                <when test="{RESULTSTYPE}=1">
                  and (e_stream.EVENTCODE = 'CBS') 
                </when>
                <when test="{RESULTSTYPE}=2">
                  and (e_stream.EVENTCODE = 'ECS') 
                </when>
              </choose>
              
              left outer join
              (
                  select ev.IDT, 
                  case when ev.EVENTCODE='OPP' then 'ALLFEE' 
                        when ev.EVENTCODE='SKP' then 'SKP' 
                        when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='RMG') then 'RMG'
                        when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='RMG') then 'FUTRMG' 	
                        when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='RMG') then 'OPTRMG' 	
                        when (ev.EVENTCODE='LPC' and ev.EVENTTYPE='UMG') then 'UMG' 	
                        when (ev.EVENTCODE='LFC' and ev.EVENTTYPE='UMG') then 'FUTUMG' 	
                        when (ev.EVENTCODE='LOC' and ev.EVENTTYPE='UMG') then 'OPTUMG' 	
                        else ev.EVENTTYPE
                  end as EVENTTYPE, 
                  ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT, isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO,
                  e_parent.EVENTCODE as EVENT_PARENT
                  from dbo.EVENT ev
                  inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS between @DATE1 and @DATE2)
                  inner join dbo.EVENT e_parent on (e_parent.IDT = ev.IDT) and (e_parent.IDE=ev.IDE_EVENT)
                  where ((ev.IDSTACTIVATION = 'REGULAR') or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2.ToUTC())) 
                    and (
                              (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE in ('CBP','CLA','CLU','CSA','CSB','CSD','CSU','CSW','E_B','E_D','EBF','EDF','EQP','FCP','FDA','BWA','MGC','MGR','MKV','OVL','OVS','PCB','PRM','RMG','SCU','TAV','UMG','UMR','UST','VMG')) 
                          or (ev.EVENTCODE in ('LFC','LOC') and ev.EVENTTYPE in ('RMG','UMG')) 
                          or (ev.EVENTCODE = 'OPP')
                          or (ev.EVENTCODE = 'SKP')
                          )
              ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	

              where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2.ToUTC()))
              group by ev.IDT, 
                        case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end,
                        case when e_stream.EVENTCODE = 'CBS' then ev.UNIT else ev.UNIT || ' ' || '(Basis)' end,
	                      case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end,
                        case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end,
                        case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end,
                        tr.IDA_ENTITY
               
              union all
        
              /* 
              -- Type     : Dealer / Clearer 
              -- Montants : Du Cash Balance précédent 
              */
              select ev.IDT, 
              case when e_stream.EVENTCODE = 'CBS' then ev.UNIT else ev.UNIT || ' ' || '(Basis)' end as UNIT, 
              case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end as ACTORSIDE,
              case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end as RESULTSTYPE,
            
              tr.IDA_ENTITY,
              case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end as IDA,
              case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end as IDB,
        
              0 as CASH_A, 0 as CASH_U, 0 as CASHBALANCE, 0 as CASHFLOW, 0 as CASHTRANSFER,
              0 as COLLATERAL_A, 0 as COLLATERAL_U, 0 as DAILYBALANCE, 0 as MARGINCALL, 0 as MARGINREQ,      
              0 as PREVCASHBALANCE, 0 as UNCOVERMARGINREQ, 0 as FEE, 0 as PREMIUM, 0 as CASHSETTLEMENT, 0 as EQPAMOUNT,
              0 as FUNDINGAMOUNT, 0 as BORROWINGAMOUNT, 0 as SAFEKEEPING, 0 as EQUITYBALANCE, 0 as FWDCASHPAYMENT, 0 as EQUITYBALFWDCASH, 0 as EXCESSDEFICIT,
		          0 as EXCESSDEFFWDCASH, 0 as CASHDEPOSIT, 0 as CASHWITHDRAWAL, 0 as LONGOPTIONVALUE, 0 as SHORTOPTIONVALUE,
              0 as MARKETVALUE, 0 as TOTALACCOUNTVALUE,
              0 as REALMARGIN, 0 as FUTREALMARGIN, 0 as OPTREALMARGIN, 0 as FSOPTREALMARGIN, 0 as PSOPTREALMARGIN,
	            0 as UNREALMARGIN, 0 as FUTUNREALMARGIN, 0 as OPTUNREALMARGIN, 0 as FSOPTUNREALMARGIN, 0 as PSOPTUNREALMARGIN,
              0 as UNSETTLEDTRANSAC,
              0 as VARMARGIN, 
              sum(case amt.EVENTTYPE when 'MGR' then amt.VALORISATION else 0 end) as MARGINREQ_PREV
        
              from dbo.EVENT ev  
              inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS between @DATE1 and @DATE2)
                
              inner join dbo.EVENT e_stream on (e_stream.IDT = ev.IDT) and (e_stream.UNIT = ev.UNIT) and (e_stream.STREAMNO = ev.STREAMNO)
                
              <choose>
                <when test="{RESULTSTYPE}=0">
                  and (e_stream.EVENTCODE in ('CBS','ECS'))
                </when>
                <when test="{RESULTSTYPE}=1">
                  and (e_stream.EVENTCODE = 'CBS') 
                </when>
                <when test="{RESULTSTYPE}=2">
                  and (e_stream.EVENTCODE = 'ECS') 
                </when>
              </choose>
                
        
              left outer join
              (
                  /* -- Previous amount : LPC-MGR */
                  select tlink.IDT_A as IDT, ev.EVENTTYPE, 
                  ev.IDA_PAY, ev.IDB_PAY, ev.IDA_REC, ev.IDB_REC, ev.UNIT , isnull(ev.VALORISATION,0) as VALORISATION, ev.STREAMNO
                  from dbo.EVENT ev
                  inner join dbo.TRADE tr on (tr.IDT = ev.IDT) and (tr.DTBUSINESS between @DATE1 and @DATE2)
                  inner join dbo.TRADELINK tlink on (tlink.IDT_B = ev.IDT) and (tlink.LINK = 'PrevCashBalance')
                  where ((ev.IDSTACTIVATION='REGULAR') or (ev.IDSTACTIVATION='DEACTIV' and ev.DTSTACTIVATION>@DATE2.ToUTC())) 
                  and (ev.EVENTCODE = 'LPC' and ev.EVENTTYPE = 'MGR')
            
              ) amt on (amt.IDT = ev.IDT) and (amt.UNIT = ev.UNIT) and (amt.STREAMNO = ev.STREAMNO)	
        
              where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'MGR') and ((ev.IDSTACTIVATION = 'REGULAR' ) or (ev.IDSTACTIVATION = 'DEACTIV' and ev.DTSTACTIVATION > @DATE2.ToUTC()))
              group by ev.IDT, 
                        case when e_stream.EVENTCODE = 'CBS' then 1 else 2 end,
                        case when e_stream.EVENTCODE = 'CBS' then ev.UNIT else ev.UNIT || ' ' || '(Basis)' end,
                        case when ev.IDA_PAY = tr.IDA_RISK then 1 else 2 end,
                        case when ev.IDA_PAY = tr.IDA_RISK then ev.IDA_PAY else ev.IDA_REC end,
                        case when ev.IDA_PAY = tr.IDA_RISK then ev.IDB_PAY else ev.IDB_REC end,
                        tr.IDA_ENTITY
          ) e_mgr
          group by e_mgr.IDT, e_mgr.UNIT, e_mgr.ACTORSIDE, e_mgr.RESULTSTYPE, e_mgr.IDA_ENTITY, e_mgr.IDA, e_mgr.IDB
        ) rs on (rs.IDT = tr.IDT)    
        
        left outer join dbo.ACTORROLE ar on (ar.IDA = rs.IDA) and (ar.IDROLEACTOR='CLIENT') and (ar.IDA_ACTOR=rs.IDA_ENTITY)
        where (rs.ACTORSIDE = case when @ACTORSIDE = 0 then rs.ACTORSIDE else @ACTORSIDE end) 
        and (tr.DTBUSINESS between @DATE1 and @DATE2) and (%%SR:TRADERISK_WHERE_PREDICATE%%) and (tr.IDSTACTIVATION = 'REGULAR')         
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!--EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="CASHPAYMENT_SELECT">
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,
  case when arCLEARER.IDA is null then 1 else 2 end as ACTORSIDE,
  t.IDT, t.IDENTIFIER, t.DTTRADE, t.DTTIMESTAMP, t.DTORDERENTERED, t.TZFACILITY, t.DISPLAYNAME, t.DESCRIPTION, t.EXTLLINK, t.SOURCE,
  t.TRDTYPE,
  case when e.IDA_PAY = ta_cp.IDA then e.IDA_PAY else e.IDA_REC end as IDA,            
  case when e.IDA_PAY = ta_cp.IDA then e.IDB_PAY else e.IDB_REC end as IDB,            
  ta_ent.IDA as IDA_ENTITY,            
  e.EVENTTYPE, e.UNIT,            
  case when arCLEARER.IDA is null then isnull(case when e.IDA_PAY = ta_cp.IDA then +1 else -1 end * e.VALORISATION, 0)
       else isnull(case when e.IDA_PAY = arCLEARER.IDA then -1 else +1 end * e.VALORISATION, 0) end 
  as VALORISATION, 
  ec.DTEVENT
  from dbo.TRADE t    
  %%SR:TRADERISK_JOIN%%(t.IDT, t)
  inner join dbo.INSTRUMENT i on (i.IDI=t.IDI)            
  inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashPayment')            
  inner join dbo.EVENT e on (e.IDT=t.IDT) and (e.EVENTCODE='STA') and (e.IDSTACTIVATION='REGULAR')
  inner join dbo.EVENTCLASS ec on (ec.IDE=e.IDE) and (ec.EVENTCLASS='STL')
  inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT=t.IDT) and (ta_ent.IDROLEACTOR='ENTITY')
  inner join dbo.TRADEACTOR ta_cp on (ta_cp.IDT=t.IDT) and (ta_cp.IDROLEACTOR='COUNTERPARTY') and (ta_cp.IDA!=ta_ent.IDA) 
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ta_cp.IDA)
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR in ('CLEARER','CCLEARINGCOMPART','HCLEARINGCOMPART','MCLEARINGCOMPART'))) arCLEARER on arCLEARER.IDA=ta_cp.IDA
  
  where (t.IDSTACTIVATION='REGULAR')
  <choose>
    <when test ="{POSITIONSIDE}=1"> 
     and (arCLEARER.IDA is null)
    </when>
    <when test ="{POSITIONSIDE}=2"> 
     and (arCLEARER.IDA is not null)
    </when>
  </choose>
  and (%%SR:TRADERISK_WHERE_PREDICATE%%)  
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- CC 20120927 Query used by consultation of cash interests trades -->
  <!-- Distinct query for sqlserver and oracle due to reading data in the XML of trade -->
  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="CASHINTEREST_SELECT">
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,
  t.IDT, t.IDENTIFIER,            
  e_startper.DTSTARTUNADJ as DTSTARTPERIOD, 
  t.DTTRADE as DTENDPERIOD, 
  ta_ci.IDA as IDA,            
  ta_ci.IDB as IDB,            
  ta_ent.IDA as IDA_ENTITY, 
  -- lecture du type de flux sur lequel sont calculés les intérêts
  case when trx.TRADEXML.value('declare default element namespace "http://www.fpml.org/2007/FpML-4-4"; 
  declare namespace efs="http://www.efs.org/2007/EFSmL-3-0"; declare namespace fixml="http://www.fixprotocol.org/FIXML-5-0-SP1";            
  (efs:EfsML/trade/efs:cashBalanceInterest/efs:interestAmountType/text()) [1]','varchar(64)')='CashBalance' 
       then 'DebitCreditCashBalance' 
       else 'CashCoveredInitialMargin'
  end as AMOUNTTYPE,
  case when e_ci_d.UNIT is null then e_ci_c.UNIT else e_ci_d.UNIT end as UNIT,
  isnull(e_ci_d.VALORISATION,0) as D_INTEREST,
  isnull(e_ci_c.VALORISATION,0) as C_INTEREST
  --abs(isnull(e_ci_d.VALORISATION,0) - isnull(e_ci_c.VALORISATION,0)) as TOTAL_INTEREST
  from dbo.TRADE t    
  %%SR:TRADE_JOIN%%(t.IDT, t)
  inner join dbo.TRADEXML trx on (trx.IDT=t.IDT)            
  inner join dbo.INSTRUMENT i on (i.IDI=t.IDI)            
  inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashBalanceInterest')            
  inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT=t.IDT) and (ta_ent.IDROLEACTOR='ENTITY')
  inner join dbo.TRADEACTOR ta_ci on (ta_ci.IDT=t.IDT) and (ta_ci.IDROLEACTOR='COUNTERPARTY') and (ta_ci.IDA!=ta_ent.IDA) 
  -- lecture de l''événement TRD/DAT pour récupérer la date de début de période non ajustée du calcul d''intérêts
  -- la date de fin de période étant lue sur la colonne DTTRADE de la table TRADE
  inner join dbo.EVENT e_startper on e_startper.IDT=t.IDT and e_startper.EVENTCODE='TRD' and e_startper.EVENTTYPE='DAT'
  -- lecture de l''événement TER/INT où IDA_PAY = TRADEACTOR.IDA pour récupérer le montant total des intérêts débiteurs
  left outer join dbo.EVENT e_ci_d on (e_ci_d.IDT=t.IDT) and (e_ci_d.EVENTCODE='TER') and (e_ci_d.EVENTTYPE='INT') 
  and (e_ci_d.IDA_PAY=ta_ci.IDA) and (e_ci_d.IDSTACTIVATION='REGULAR')
  -- lecture de l''événement TER/INT où IDA_REC = TRADEACTOR.IDA pour récupérer le montant total des intérêts créditeurs
  left outer join dbo.EVENT e_ci_c on (e_ci_c.IDT=t.IDT) and (e_ci_c.EVENTCODE='TER') and (e_ci_c.EVENTTYPE='INT') 
  and (e_ci_c.IDA_REC=ta_ci.IDA) and (e_ci_c.IDSTACTIVATION='REGULAR')
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ta_ci.IDA)
  
  where (t.IDSTACTIVATION='REGULAR') and (%%SR:TRADE_WHERE_PREDICATE%%)  
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
  select
  arCLIENT.IDA as arCLIENT_IDA,
  t.IDT, t.IDENTIFIER,            
  e_startper.DTSTARTUNADJ as DTSTARTPERIOD, 
  t.DTTRADE as DTENDPERIOD, 
  ta_ci.IDA as IDA,            
  ta_ci.IDB as IDB,            
  ta_ent.IDA as IDA_ENTITY, 
  -- lecture du type de flux sur lequel sont calculés les intérêts
  case when extractvalue(trx.TRADEXML,'(efs:EfsML/trade/efs:cashBalanceInterest/efs:interestAmountType/text()) [1]',
  'xmlns:efs="http://www.efs.org/2007/EFSmL-3-0", xmlns:fixml="http://www.fixprotocol.org/FIXML-5-0-SP1", 
  xmlns="http://www.fpml.org/2007/FpML-4-4"')='CashBalance' 
       then 'DebitCreditCashBalance' 
       else 'CashCoveredInitialMargin'
  end as AMOUNTTYPE,
  case when e_ci_d.UNIT is null then e_ci_c.UNIT else e_ci_d.UNIT end as UNIT,
  nvl(e_ci_d.VALORISATION,0) as D_INTEREST,
  nvl(e_ci_c.VALORISATION,0) as C_INTEREST
  --abs(nvl(e_ci_c.VALORISATION,0) - nvl(e_ci_d.VALORISATION,0)) as TOTAL_INTEREST
  from dbo.TRADE t    
  inner join dbo.TRADEXML trx on (trx.IDT=t.IDT)            
  %%SR:TRADE_JOIN%%(t.IDT, t)
  inner join dbo.INSTRUMENT i on (i.IDI=t.IDI)            
  inner join dbo.PRODUCT p on (p.IDP=i.IDP) and (p.IDENTIFIER='cashBalanceInterest')            
  inner join dbo.TRADEACTOR ta_ent on (ta_ent.IDT=t.IDT) and (ta_ent.IDROLEACTOR='ENTITY')
  inner join dbo.TRADEACTOR ta_ci on (ta_ci.IDT=t.IDT) and (ta_ci.IDROLEACTOR='COUNTERPARTY') and (ta_ci.IDA!=ta_ent.IDA) 
  -- lecture de l''événement TRD/DAT pour récupérer la date de début de période non ajustée du calcul d''intérêts
  -- la date de fin de période étant lue sur la colonne DTTRADE de la table TRADE
  inner join dbo.EVENT e_startper on e_startper.IDT=t.IDT and e_startper.EVENTCODE='TRD' and e_startper.EVENTTYPE='DAT'
  -- lecture de l''événement TER/INT où IDA_PAY = TRADEACTOR.IDA pour récupérer le montant total des intérêts débiteurs
  left outer join dbo.EVENT e_ci_d on (e_ci_d.IDT=t.IDT) and (e_ci_d.EVENTCODE='TER') and (e_ci_d.EVENTTYPE='INT') 
  and (e_ci_d.IDA_PAY=ta_ci.IDA) and (e_ci_d.IDSTACTIVATION='REGULAR')
  -- lecture de l''événement TER/INT où IDA_REC = TRADEACTOR.IDA pour récupérer le montant total des intérêts créditeurs
  left outer join dbo.EVENT e_ci_c on (e_ci_c.IDT=t.IDT) and (e_ci_c.EVENTCODE='TER') and (e_ci_c.EVENTTYPE='INT') 
  and (e_ci_c.IDA_REC=ta_ci.IDA) and (e_ci_c.IDSTACTIVATION='REGULAR')
  left outer join (select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')) arCLIENT on (arCLIENT.IDA=ta_ci.IDA)
  where (%%SR:TRADE_WHERE_PREDICATE%%) and (t.IDSTACTIVATION='REGULAR') 
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <item name="MCO_RPT_SELECT">
    <sqlCommand>
      <Command rdbms="sqlserver">
        <![CDATA[
        select mco.IDMCO,
        case when mco.DTUPD is not null then mco.DTUPD else mco.DTINS end as DTMSG,
        mco.DTMCO,mco.DTMCOFORCED,mco.DTMCO2,
        mco.IDA_SENDBYPARTY, mco.IDA_SENDBYOFFICE,
        mco.IDA_SENDTOPARTY, mco.IDA_SENDTOOFFICE, mco.IDB_SENDTOPARTY,
        mco.CNFMSGXML,
        mco.DOCTYPEMSGTXT,mco.LOCNFMSGTXT,
        mco.DOCTYPEMSGBIN,mco.LOCNFMSGBIN,
        mco.DOCNAME, mco.SCOPE, mco.DTOBSOLETE
        from dbo.VW_MCO_MULTITRADES mco
        inner join dbo.CNFMESSAGE cnfmsg on cnfmsg.IDCNFMESSAGE = mco.IDCNFMESSAGE
        and cnfmsg.CNFTYPE in ('ALLOCATION','FINANCIAL','FINANCIALPERIODIC','POSITION','POSSYNTHETIC','POSACTION','SYNTHESIS')
        where 
        <choose>
        <when test ="{PERIODREPORTTYPE}=1"> 
          -- Daily Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is null)
        </when>
        <when test ="{PERIODREPORTTYPE}=2"> 
          -- Weekly Period
           (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) and 
           ((((datepart(weekday,mco.DTMCO) + @@DATEFIRST -1 -1) % 7) +1)=1) and ( datediff(day,mco.DTMCO,mco.DTMCO2)=6 or datediff(day,mco.DTMCO,mco.DTMCO2)=4 ) 
        </when>
        <when test ="{PERIODREPORTTYPE}=3"> 
          -- Monthly Period
           (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
           and (day(mco.DTMCO)=1) and (mco.DTMCO2=dateadd(d,-1,dateadd(m,1,DTMCO))) 
        </when>
        <when test ="{PERIODREPORTTYPE}=4"> 
        --Yealy Period
         (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
         and (day(mco.DTMCO)=1) and (month(mco.DTMCO)=1) and (day(mco.DTMCO2)=31) and (month(mco.DTMCO2)=12) 
        </when>
        <otherwise>
          -- Daily Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null)
        </otherwise>
        </choose>
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms="oracle">
        <![CDATA[
        select mco.IDMCO,
        case when mco.DTUPD is not null then mco.DTUPD else mco.DTINS end as DTMSG,
        mco.DTMCO,mco.DTMCOFORCED,mco.DTMCO2,
        mco.IDA_SENDBYPARTY, mco.IDA_SENDBYOFFICE,
        mco.IDA_SENDTOPARTY, mco.IDA_SENDTOOFFICE, mco.IDB_SENDTOPARTY,
        mco.CNFMSGXML,
        mco.DOCTYPEMSGTXT,mco.LOCNFMSGTXT,
        mco.DOCTYPEMSGBIN,mco.LOCNFMSGBIN,
        mco.DOCNAME, mco.SCOPE, mco.DTOBSOLETE
        from dbo.VW_MCO_MULTITRADES mco
        inner join dbo.CNFMESSAGE cnfmsg on cnfmsg.IDCNFMESSAGE = mco.IDCNFMESSAGE
        and cnfmsg.CNFTYPE in ('ALLOCATION','FINANCIAL','FINANCIALPERIODIC','POSITION','POSSYNTHETIC','POSACTION','SYNTHESIS')
        where 
        <choose>
        <when test ="{PERIODREPORTTYPE}=1"> 
          -- Daily Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is null)
        </when>
        <when test ="{PERIODREPORTTYPE}=2"> 
          -- Weekly Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
          and (mod( mco.DTMCO - date '1000-01-01', 7) + 1)=1
          and ( (mco.DTMCO2 - mco.DTMCO)=6 or (mco.DTMCO2 - mco.DTMCO)=4 ) 
        </when>
        <when test ="{PERIODREPORTTYPE}=3"> 
          -- Monthly Period
          (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
          and (extract(day from mco.DTMCO)=1) and (mco.DTMCO2=last_day(mco.DTMCO)) 
        </when>
        <when test ="{PERIODREPORTTYPE}=4"> 
        --Yealy Period
        (mco.DTMCO=@DATE1) and (mco.DTMCO2 is not null) 
        and (extract(day from mco.DTMCO)=1) and (extract(month from mco.DTMCO)=1) 
        and (extract(day from mco.DTMCO2)=31) and (extract(month from mco.DTMCO2)=12) 
        </when>
        <otherwise>
          -- Daily Period
          (mco.DTMCO=@DATE1)  and (mco.DTMCO2 is not null)
        </otherwise>
        </choose>
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  CC/PL 20130919 Ticket 18971 - Correction sur signe du montant pour le flux SCU                 
  POSACTIONDET_PRESELECT utilisé par la consultation des 'Actions opérées sur positions',        
  consultation accessible via le menu Consultations\Exchange (Bourse)\Positions                  
  Le PRESELECT alimente une table temporaire avec le jeu de résultats                            
  POSACTIONDET_PRESELECT (étape 1) est associé au POSACTIONDET_SELECT (étape 2)                  
  
  EG 20141208 Add POSITIONEFFECT      
  FI 20160229 Modfy
      => add 'AUTOEXE','AUTOASS','AUTOABN'
      => add restriction (price.QUOTEPRICE100 is not null) sur colonne ITM_OTM
      => si MOF lecture du prix sur l'EVENTDET rattaché à l'évènement MOF
  EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
      -->
  <item name="POSACTIONDET_PRESELECT">

    <!-- 
      Remarques
      - Pour optimiser les temps de réponses les sous select font des lecture dans la table EVENT,EVENTCLASS en date de traitement
      Ceci n'est pas effectué pour la requête qui charge les décompensations car il est impossible de connaître la date de la compensation initiale
      
      - Une compensation décompensée le même jour donne lieu à 2 enregistrements
      -->
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSACTIONDET_%%SHORTSESSIONID%%_W;
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSACTIONDET_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      insert into POSACTIONDET_%%SHORTSESSIONID%%_W
      (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
      DTSYS, PRICE, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, SCU_IDA_PAY, SCU_IDA_REC, SCU, SCU_IDC, ITM_OTM, DEACTIV, POSITIONEFFECT)

      select     
          pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
          pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, 
          pad.DTINS as DTSYS, price.QUOTEPRICE100 as PRICE,
          rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC,
          scu.IDA_PAY as SCU_IDA_PAY, scu.IDA_REC as SCU_IDA_REC, scu.VALORISATION as SCU, scu.UNIT as SCU_IDC,
          
          case when pad.REQUESTTYPE in ('EXE','ASS','ABN','NEX','NAS', 'AUTOEXE','AUTOASS','AUTOABN') 
                    and (price.IDT = pad.TRADE_IDT) and (price.QUOTEPRICE100 is not null) then
            case  
            -- 1 = Call
            when asset.PUTCALL='1' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'Out the money'
            when asset.PUTCALL='1' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'In the money' 
            when asset.PUTCALL='1' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money' 
            -- 0 = Put
            when asset.PUTCALL='0' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'In the money'
            when asset.PUTCALL='0' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'Out the money'
            when asset.PUTCALL='0' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money'
            else 'N/A' end 
          else 'N/A' end as ITM_OTM,
          0 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADE tr on (tr.IDT=pad.TRADE_IDT)
      %%CC:ITRADE_JOIN%%(tr)
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,tr,null)
      inner join dbo.ASSET_ETD asset on (asset.IDASSET=tr.IDASSET)
      
      left outer join 
      (
          select ev.IDT,  case ev.EVENTCODE  
                               when 'MOF' then evdet.CLOSINGPRICE100 
                                          else evdet.SETTLTPRICE100 
                          end as QUOTEPRICE100, epad.IDPADET 
          from dbo.EVENT ev
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS in ('PHY','CSH')) and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE=ev.IDE)
          left outer join dbo.EVENTDET evdet on (evdet.IDE=ev.IDE)
          where ev.EVENTCODE in ('EXE', 'AEX', 'ABN', 'AAB', 'ASS', 'AAS', 'MOF') 
      ) price  on (price.IDPADET=pad.IDPADET) and (price.IDT=pad.TRADE_IDT)

      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE = 'RMG')
      ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT)
      
      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE = 'SCU')
      ) scu  on (scu.IDPADET = pad.IDPADET) and (scu.IDT = pad.TRADE_IDT)
      where (pad.DTBUSINESS between @DATE1 and @DATE2 ) 
      and (%%CC:ITRADE_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
      
      union all
  
      select     
      pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
      pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS, null as PRICE, rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, 
      rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, null as SCU_IDA_PAY, null as SCU_IDA_REC, null as SCU, null as SCU_IDC, 
      'N/A' as ITM_OTM, 1 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADE tr on (tr.IDT=pad.TRADE_IDT)
      %%CC:ITRADE_JOIN%%(tr)
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,tr,null)
      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS='VAL')
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE ='RMG')
      ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT=pad.TRADE_IDT)
      where (pad.DTUNCLEARING between @DATE1 and @DATE2)
      and (%%CC:ITRADE_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
			]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20141208 Add POSITIONEFFECT -->
  <!-- PL 20170523 Add (ar.IDA_ACTOR=rs.IDA_ENTITY) on ACTORROLE join (to avoid duplicates when a client is a client of 2 entities) -->
  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="POSACTIONDET_SELECT">
    <!--
     Remarques
     - Lorsque Type de position vaut "Client,Maison, Teneur de Marché"
       un transfert est affiché uniquement s'il a lieu côté Dealer (Nouveau Book côté Dealer)
     
     - Lorsque Type de position vaut "Compensateurs"
       un transfert est affiché uniquement s'il a lieu côté Clearer (Nouveau Book côté Clearer)
     
     - Lorsque Type de position vaut <Tous>
       un transfert peut être affiché 2 fois s'il a lieu côté Dealer (Nouveau Book côté Dealer) et s'il a lieu côté Clearer (Nouveau Book côté Clearer)
     
     - Les Transferts sont affichés comme Transfert uniquement si TRDTYPE = PositionTransfert (42) et TRDSUBTYPE vaut Internal transfer or adjustment(1)
       Les Transferts sont affichés comme Correction dans les autres cas, Le trade résultat du transfert est non accessible depuis le grid 
    -->
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[/* Spheres:Hint ARITHABORT_ON NOPARAMS */
      select ar.IDA as arCLIENT_IDA, rs.IDA_ENTITY, rs.ACTORSIDE, rs.IDPR, 
      case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then 
                                                           case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then 'POT' else 'POC' end
                                                           else rs.REQUESTTYPE end end as REQUESTTYPE,
      case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then 
                                                           case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then 'POT' else 'POC' end
                                                           else rs.REQUESTTYPE end end as REQUESTTYPE_VALUE,
      rs.IDPA, rs.IDPADET, posefctaction.EXTVALUE as POSITIONEFFECT, rs.IDT, 
      rs.IDA as IDA_DEALERORCLEARER, rs.IDB as IDB_DEALERORCLEARER, 
      case when rs.REQUESTTYPE = 'POT' then case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then rs.IDT2 else null end else rs.IDT2 end as IDT2,
      rs.DTBUSINESS, rs.DTUNCLEARING, rs.QUANTITY, rs.DEACTIV, rs.DTSYS, rs.IDASSET, rs.IDM, rs.IDA_CSSCUSTODIAN, rs.PRICE, 
      case when rs.IDA = rs.RMG_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
										else case when rs.DEACTIV=0 then  1 else -1 end end * rs.RMG as RMG, rs.RMG_IDC,
      case when rs.IDA = rs.SCU_IDA_PAY then -1 else 1 end * rs.SCU as SCU, rs.SCU_IDC,
      rs.ITM_OTM, en.EXTVALUE As REQUESTTYPEENUM, en.EXTVALUE As REQUESTTYPE_EXTVALUE
      from 
      (
          select posact.ACTORSIDE, posact.IDPR, posact.REQUESTTYPE, posact.IDPA, posact.IDPADET, posact.IDT, posact.IDT2, 
          posact.DTBUSINESS, posact.DTUNCLEARING, posact.QTY as QUANTITY, posact.DTSYS, posact.PRICE, 
          posact.RMG_IDA_PAY, posact.RMG_IDA_REC, posact.RMG, posact.RMG_IDC, 
          posact.SCU_IDA_PAY, posact.SCU_IDA_REC, posact.SCU, posact.SCU_IDC, 
          posact.ITM_OTM, posact.DEACTIV, posact.POSITIONEFFECT, posact.IDA, posact.IDB, tr.IDASSET, tr.IDM, tr.IDA_CSSCUSTODIAN, tr.IDA_ENTITY    
          from 
          (
              <choose>
               <when test="{ACTORSIDE}=0 or {ACTORSIDE}=1">   
              select 1 as ACTORSIDE, tr.IDA_DEALER as IDA, tr.IDB_DEALER as IDB,
              pad.IDPR, pad.IDPA, pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.IDT, pad.IDT2, 
              pad.DTSYS, pad.PRICE, 
              pad.RMG_IDA_PAY, pad.RMG_IDA_REC, pad.RMG, pad.RMG_IDC, 
			        pad.SCU_IDA_PAY, pad.SCU_IDA_REC, pad.SCU, pad.SCU_IDC, pad.ITM_OTM, pad.DEACTIV, pad.POSITIONEFFECT
              from POSACTIONDET_%%SHORTSESSIONID%%_W pad
              inner join dbo.TRADE tr on (tr.IDT =  pad.IDT)
              left outer join dbo.TRADE tr2 on (tr2.IDT = pad.IDT2) and (tr2.IDB_DEALER != tr.IDB_DEALER)
              where 1 = case when (pad.REQUESTTYPE = 'POT' and  tr2.IDT is null) then 0 else 1 end
              <choose>
                    <when test="{ISWITHTODAYUNCLEARING}=0">
                      and ((pad.DTUNCLEARING is null) or (pad.DTUNCLEARING != pad.DTBUSINESS))
               </when>
                  </choose>
               </when>
              </choose>
              <choose> 
                <when test="{ACTORSIDE}=0">   
                  union ALL
                </when>
              </choose>
              <choose> 
               <when test="{ACTORSIDE}=0 or {ACTORSIDE}=2">   
                select 2 as ACTORSIDE, tr.IDA_CLEARER as IDA, tr.IDB_CLEARER as IDB,
                pad.IDPR, pad.IDPA, pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.IDT, pad.IDT2, 
                pad.DTSYS, pad.PRICE, 
                pad.RMG_IDA_PAY, pad.RMG_IDA_REC, pad.RMG, pad.RMG_IDC, 
			          pad.SCU_IDA_PAY, pad.SCU_IDA_REC, pad.SCU, pad.SCU_IDC, pad.ITM_OTM, pad.DEACTIV, pad.POSITIONEFFECT
                from POSACTIONDET_%%SHORTSESSIONID%%_W pad
                inner join dbo.TRADE tr on (tr.IDT =  pad.IDT)  
                left outer join dbo.TRADE tr2 on (tr2.IDT = pad.IDT2) and (tr2.IDB_CLEARER != tr.IDB_CLEARER)
                where 1 = case when (pad.REQUESTTYPE = 'POT' and  tr2.IDT is null) then 0 else 1 end
                <choose>
                <when test="{ISWITHTODAYUNCLEARING}=0">
                    and ((pad.DTUNCLEARING is null) or (pad.DTUNCLEARING != pad.DTBUSINESS))
                      </when>
                  </choose>
                </when>
              </choose>
        ) posact
        inner join dbo.VW_TRADE_FUNGIBLE_LIGHT_ETD tr on (tr.IDT=posact.IDT)
      ) rs
      left outer join dbo.ENUM posefctaction on (posefctaction.CODE='PositionEffectEnum') and (posefctaction.VALUE=rs.POSITIONEFFECT)
      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT') and (ar.IDA_ACTOR=rs.IDA_ENTITY)
      left outer join dbo.TRADE tr2 on tr2.IDT = rs.IDT2
      left outer join dbo.ENUM en on (en.CODE='PosRequestTypeEnum') and (en.VALUE=
                case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then 'POT' else 'POC' end else rs.REQUESTTYPE end end)]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20141208 Add POSITIONEFFECT  -->
  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="POSACTIONDET_OTC_PRESELECT">

    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSACTIONDET_OTC_%%SHORTSESSIONID%%_W;
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSACTIONDET_OTC_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <!-- 
      Remarques
      - Pour optimiser les temps de réponses les sous select font des lecture dans la table EVENT,EVENTCLASS en date de traitement
      Ceci n'est pas effectué pour la requête qui charge les décompensations car il est impossible de connaître la date de la compensation initiale
      - Une compensation décompensée le même jour donne lieu à 2 enregistrements
      -->
      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      insert into POSACTIONDET_OTC_%%SHORTSESSIONID%%_W
      (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
      DTSYS, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, 
      AIN_IDA_PAY, AIN_IDA_REC, AIN, AIN_IDC,
      GAM_IDA_PAY, GAM_IDA_REC, GAM, GAM_IDC,
      DEACTIV, POSITIONEFFECT)
      select     
      pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
      pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, pad.DTINS as DTSYS, 
      rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 
      ain.IDA_PAY as AIN_IDA_PAY, ain.IDA_REC as AIN_IDA_REC, ain.VALORISATION as AIN, ain.UNIT as AIN_IDC, 
      gam.IDA_PAY as GAM_IDA_PAY, gam.IDA_REC as GAM_IDA_REC, gam.VALORISATION as GAM, gam.UNIT as GAM_IDC, 
      0 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADE tr on (tr.IDT=pad.TRADE_IDT)
      %%CC:ITRADE_JOIN%%(tr)
      inner join dbo.VW_INSTR_PRODUCT pr on ( pr.IDI = tr.IDI) and (pr.FUNGIBILITYMODE != 'NONE') and (pr.GPRODUCT in ('OTC','SEC'))
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,tr,null)
      
      left outer join 
      (
          select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
          from dbo.EVENT ev 
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
          where (ev.EVENTTYPE = 'RMG')
      ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT)
      
      left outer join 
      (    /* Flux LPC/AIN = rétrocession de coupon couru en cas de transfert, de correction */
          select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
          from dbo.EVENT ev 
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
          where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'AIN')
      ) ain  on (ain.IDPADET = pad.IDPADET) and (ain.IDT = pad.TRADE_IDT)
      
      left outer join 
      (    /* Flux LPC/GAM = rétrocession de gross amount en cas de transfert, de correction */
          select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
          from dbo.EVENT ev 
          inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL') and (ec.DTEVENT between @DATE1 and @DATE2)
          inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
          where (ev.EVENTCODE = 'LPC') and (ev.EVENTTYPE = 'GAM')
      ) gam  on (gam.IDPADET = pad.IDPADET) and (gam.IDT = pad.TRADE_IDT)
      
      where (pad.DTBUSINESS between @DATE1 and @DATE2)
      and (%%CC:ITRADE_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
      
      union all
  
      select     
      pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
      pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS,
      rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 
      /* Columns below set null - Only RMG on UNCLEARING*/
      null as AIN_IDA_PAY, null as AIN_IDA_REC, null as AIN, null as AIN_IDC, 
      null as GAM_IDA_PAY, null as GAM_IDA_REC, null as GAM, null as GAM_IDC, 
      1 as DEACTIV, pad.POSITIONEFFECT
      from dbo.VW_POSACTIONDET pad
      inner join dbo.TRADE tr on (tr.IDT=pad.TRADE_IDT)
      %%CC:ITRADE_JOIN%%(tr)
      inner join dbo.VW_INSTR_PRODUCT pr on ( pr.IDI = tr.IDI) and (pr.FUNGIBILITYMODE != 'NONE') and (pr.GPRODUCT in ('OTC','SEC'))
      %%SR:TRADEALLOC_JOIN%%(pad.TRADE_IDT,tr,null)
      left outer join 
      (
           select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
           from dbo.EVENT ev 
           inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS='VAL')
           inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
           where (ev.EVENTTYPE ='RMG')
      ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT=pad.TRADE_IDT)
      
      where (pad.DTUNCLEARING between @DATE1 and @DATE2)
      and (%%CC:ITRADE_WHERE_PREDICATE%%)
      and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
			]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  CC/EG 20150304 Add ASSETCATEGORY
  EG 20141208 Add POSITIONEFFECT  
  EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
  -->
  <item name="POSACTIONDET_OTC_SELECT">
    <!--
     Remarques
     - Lorsque Type de position vaut "Client,Maison, Teneur de Marché"
       Les transferts sont affichés uniquement s'il ont lieu côté Dealer  (FIXPARTYROLE = 27)
     
     - Lorsque Type de position vaut "Custodian"
       Les transferts sont affichés uniquement s'il ont lieu côté Custodian  (FIXPARTYROLE != 27)
     
     - Lorsque Type de position vaut <Tous>
       Chaque transfert n'apparaît qu'une seule fois
     
       Les Transferts sont affichés comme Correction dans les autres cas, Le trade résultat du transfert n'est pas accessible depuis le grid 
    -->

    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
      /* Spheres:Hint ARITHABORT_ON NOPARAMS */
      select ar.IDA as arCLIENT_IDA, rs.ACTORSIDE, rs.IDPR, 
      case when rs.DEACTIV = 1 then 'UNCLEARING' else 
                                                 case rs.REQUESTTYPE when 'POT' then 
                                                                    case when rs.FAMILY='ESE' then case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then 'POT' else 'POC' end
                                                                                              else 'POT'
                                                                                              end                                      
                                                                    else rs.REQUESTTYPE 
                                                                    end 
                                                 end as REQUESTTYPE,
      rs.IDPA, rs.IDPADET, posefctaction.EXTVALUE as POSITIONEFFECT, rs.IDT, 
      rs.IDA as IDA_DEALERORCLEARER, rs.IDB as IDB_DEALERORCLEARER, 
      case when rs.REQUESTTYPE = 'POT' then case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then rs.IDT2 else null end else rs.IDT2 end as IDT2,
      rs.DTBUSINESS, rs.DTUNCLEARING, rs.QUANTITY, rs.DEACTIV, rs.DTSYS, rs.IDASSET, rs.ASSETCATEGORY, rs.IDM, rs.IDA_CSSCUSTODIAN, 
      case when rs.IDA = rs.RMG_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
										else case when rs.DEACTIV=0 then  1 else -1 end end * rs.RMG as RMG, rs.RMG_IDC,
      
      case when rs.IDA = rs.AIN_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
										else case when rs.DEACTIV=0 then  1 else -1 end end * rs.AIN as AIN, rs.AIN_IDC,
                    
      case when rs.IDA = rs.GAM_IDA_PAY then case when rs.DEACTIV=0 then -1 else  1 end  
			              else case when rs.DEACTIV=0 then  1 else -1 end end * rs.GAM as GAM, rs.GAM_IDC,
      en.EXTVALUE As REQUESTTYPEENUM, en.EXTVALUE As REQUESTTYPE_EXTVALUE      
                    
      from 
      (
          select pa_otc.ACTORSIDE, pa_otc.IDPR, pa_otc.REQUESTTYPE, pa_otc.IDPA, pa_otc.IDPADET, pa_otc.IDT, pa_otc.IDT2, 
          pa_otc.DTBUSINESS, pa_otc.DTUNCLEARING, pa_otc.QTY as QUANTITY, pa_otc.DTSYS, 
          pa_otc.RMG_IDA_PAY, pa_otc.RMG_IDA_REC, pa_otc.RMG, pa_otc.RMG_IDC, 
          pa_otc.AIN_IDA_PAY, pa_otc.AIN_IDA_REC, pa_otc.AIN, pa_otc.AIN_IDC,
          pa_otc.GAM_IDA_PAY, pa_otc.GAM_IDA_REC, pa_otc.GAM, pa_otc.GAM_IDC,
          pa_otc.DEACTIV, pa_otc.POSITIONEFFECT, pa_otc.IDA, pa_otc.IDB, tr.IDASSET, tr.ASSETCATEGORY, tr.IDM, tr.IDA_CSSCUSTODIAN, tr.IDA_ENTITY, 
          tr.FAMILY
          from 
          (
              select case ta.FIXPARTYROLE when '27' then 1 else 2 end as ACTORSIDE, ta.IDA, ta.IDB,
              pad.IDPR, pad.IDPA, pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.IDT, pad.IDT2, 
              pad.DTSYS, 
              pad.RMG_IDA_PAY, pad.RMG_IDA_REC, pad.RMG, pad.RMG_IDC, 
              pad.AIN_IDA_PAY, pad.AIN_IDA_REC, pad.AIN, pad.AIN_IDC,
              pad.GAM_IDA_PAY, pad.GAM_IDA_REC, pad.GAM, pad.GAM_IDC,
              
              pad.DEACTIV, pad.POSITIONEFFECT
              from POSACTIONDET_OTC_%%SHORTSESSIONID%%_W pad
              inner join dbo.TRADE tr on (tr.IDT = pad.IDT)
              inner join dbo.TRADEACTOR ta on (ta.IDT = tr.IDT) and (ta.IDROLEACTOR='COUNTERPARTY')
              <choose>
               <when test="{ACTORSIDE}=1">   
                  and (ta.FIXPARTYROLE in ('27'))
               </when>
               <when test="{ACTORSIDE}=2">   
                  and (ta.FIXPARTYROLE in ('28','21'))
               </when>
               <otherwise>
                  and (ta.FIXPARTYROLE in ('27','28','21'))
                </otherwise>
              </choose>
              left outer join dbo.TRADE tr2 on (tr2.IDT = pad.IDT2)
              <choose> 
                <when test="{ACTORSIDE}=0">   
                where 
                (
                  tr.IDT = case when pad.REQUESTTYPE = 'POT' then  
					                      case ta.FIXPARTYROLE when '27' then tr.IDT else -1
                                end 
					                 else tr.IDT end
                )
                </when>
              </choose>
              
              <choose> 
                <when test="{ISWITHTODAYUNCLEARING}=0">
                  <choose> 
                      <when test="{ACTORSIDE}!=0">
                        where
                      </when>
                      <otherwise>
                       and 
                      </otherwise>
                  </choose>
                  ((pad.DTUNCLEARING is null) or (pad.DTUNCLEARING&lt;&gt;pad.DTBUSINESS))
                </when>
              </choose>
              
              
        ) pa_otc
        inner join dbo.VW_TRADE_FUNGIBLE_LIGHT_OTCSEC tr on (tr.IDT=pa_otc.IDT)
      ) rs
      left outer join dbo.ENUM posefctaction on (posefctaction.CODE='PositionEffectEnum') and (posefctaction.VALUE=rs.POSITIONEFFECT)
      left outer join dbo.ACTORROLE ar on (ar.IDA=rs.IDA) and (ar.IDROLEACTOR='CLIENT') and (ar.IDA_ACTOR=rs.IDA_ENTITY)
      left outer join dbo.TRADE tr2 on tr2.IDT = rs.IDT2
      left outer join dbo.ENUM en on (en.CODE='PosRequestTypeEnum') and (en.VALUE=
                case when rs.DEACTIV = 1 then 'UNCLEARING' else case rs.REQUESTTYPE when 'POT' then case when rs.FAMILY='ESE' then case when tr2.TRDTYPE ='42' and tr2.TRDSUBTYPE = '1' then 'POT' else 'POC' end else 'POT' end else rs.REQUESTTYPE end end)
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  POSACTIONDET_TRADE_PRESELECT utilisé par la consultation des 'Actions opérées sur positions',  
  consultation accessible via le bouton 'POS.ACT' disponible sur le masque de saisie des trades  
  EG 20141208 Add POSITIONEFFECT  
  FI 20160229 Modfy
      => alias PRICE, expression QUOTEPRICE100 lecture de CLOSINGPRICE100 si MOF
      => add restriction (price.QUOTEPRICE100 is not null) sur colonne ITM_OTM
      => suppression des jointures sur EVENTCLASS puisque non utile
  -->
  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="POSACTIONDET_TRADE_PRESELECT">

    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSACTIONDET_%%SHORTSESSIONID%%_W;
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSACTIONDET_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <!-- Remarques                                                                       
      Le RMG est lu sur le trade consulté pour optmiser les temps de réponse de la requête 
      Ce trade peut-être le trade clôturant ou le trade clôturé                            
      -->
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        insert into POSACTIONDET_%%SHORTSESSIONID%%_W
        (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
        DTSYS, PRICE, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, SCU_IDA_PAY, SCU_IDA_REC, SCU, SCU_IDC, ITM_OTM, DEACTIV, POSITIONEFFECT)

        select     
            pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
            pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, 
            pad.DTINS as DTSYS, price.QUOTEPRICE100 as PRICE,
            rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC,
            scu.IDA_PAY as SCU_IDA_PAY, scu.IDA_REC as SCU_IDA_REC, scu.VALORISATION as SCU, scu.UNIT as SCU_IDC,
            
            case when pad.REQUESTTYPE in ('EXE','ASS','ABN','NEX','NAS', 'AUTOEXE','AUTOASS','AUTOABN') 
                                      and (price.IDT = pad.TRADE_IDT) and (price.QUOTEPRICE100 is not null) then
              case  
              -- 1 = Call
              when asset.PUTCALL='1' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'Out the money'
              when asset.PUTCALL='1' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'In the money' 
              when asset.PUTCALL='1' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money' 
              -- 0 = Put
              when asset.PUTCALL='0' and asset.STRIKEPRICE > price.QUOTEPRICE100 then 'In the money'
              when asset.PUTCALL='0' and asset.STRIKEPRICE < price.QUOTEPRICE100 then 'Out the money'
              when asset.PUTCALL='0' and asset.STRIKEPRICE = price.QUOTEPRICE100 then 'At the money'
              else 'N/A' end 
            else 'N/A' end as ITM_OTM,
            0 as DEACTIV, 
            pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        inner join dbo.TRADE tr on (tr.IDT=pad.TRADE_IDT) and (tr.ASSETCATEGORY='ExchangeTradedContract')
        inner join dbo.ASSET_ETD asset on (asset.IDASSET = tr.IDASSET) 
        left outer join 
        (
             select ev.IDT, case ev.EVENTCODE  
                              when 'MOF' then evdet.CLOSINGPRICE100 
                                         else evdet.SETTLTPRICE100 
                            end as QUOTEPRICE100, epad.IDPADET
             from dbo.EVENT ev
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE=ev.IDE)
             left outer join dbo.EVENTDET evdet on (evdet.IDE=ev.IDE)
             where ev.EVENTCODE in ('EXE', 'AEX', 'ABN', 'AAB', 'ASS', 'AAS', 'MOF') and (ev.IDT = @IDT)
        ) price  on (price.IDPADET=pad.IDPADET) and (price.IDT=pad.TRADE_IDT)
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE = 'RMG') and (ev.IDT = @IDT)
        ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE = 'SCU') and (ev.IDT = @IDT)
        ) scu  on (scu.IDPADET = pad.IDPADET) and (scu.IDT = pad.TRADE_IDT)
        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT)
        
        union all
    
        select     
        pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
        pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS, null as PRICE, rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, 
        rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, null as SCU_IDA_PAY, null as SCU_IDA_REC, null as SCU, null as SCU_IDC, 
        'N/A' as ITM_OTM, 1 as DEACTIV, pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE ='RMG') and (ev.IDT = @IDT)
        ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)
        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT) and (pad.DTUNCLEARING is not null);
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  POSACTIONDET_OTC_TRADE_PRESELECT utilisé par la consultation des 'Actions opérées sur positions (OTC/SEC)',  
  consultation accessible via le bouton 'POS.ACT' disponible sur le masque de saisie des trades  
  EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
  -->
  <item name="POSACTIONDET_OTC_TRADE_PRESELECT">
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table POSACTIONDET_%%SHORTSESSIONID%%_W;
			  ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table POSACTIONDET_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
			  ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
        /* Spheres:Hint ARITHABORT_ON NOPARAMS */
        insert into POSACTIONDET_%%SHORTSESSIONID%%_W
        (IDPR, IDPA, IDPADET, REQUESTTYPE, REQUESTMODE, DTBUSINESS, DTUNCLEARING, QTY, IDT, IDT2, 
        DTSYS, RMG_IDA_PAY, RMG_IDA_REC, RMG, RMG_IDC, DEACTIV, POSITIONEFFECT)

        select     
            pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE,
            pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT, pad.TRADE2_IDT as IDT2, 
            pad.DTINS as DTSYS, 
            rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 0 as DEACTIV, pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        inner join dbo.TRADE tr on (tr.IDT=pad.TRADE_IDT)
        inner join dbo.VW_ASSET asset on (asset.IDASSET = tr.IDASSET) and (asset.ASSETCATEGORY = tr.ASSETCATEGORY)
        
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTCLASS ec on (ec.IDE=ev.IDE) and (ec.EVENTCLASS='VAL')
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE = 'RMG') and (ev.IDT = @IDT)
        ) rmg  on (rmg.IDPADET = pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)

        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT)
        
        union all
    
        select     
        pad.IDPR, pad.IDPA,pad.IDPADET, pad.REQUESTTYPE, pad.REQUESTMODE, pad.DTBUSINESS, pad.DTUNCLEARING, pad.QTY, pad.TRADE_IDT as IDT,
        pad.TRADE2_IDT as IDT2, pad.DTUPD as DTSYS, rmg.IDA_PAY as RMG_IDA_PAY, rmg.IDA_REC as RMG_IDA_REC, 
        rmg.VALORISATION as RMG, rmg.UNIT as RMG_IDC, 1 as DEACTIV, pad.POSITIONEFFECT
        from dbo.VW_POSACTIONDET pad
        left outer join 
        (
             select ev.IDT, ev.IDA_PAY, ev.IDA_REC, ev.VALORISATION, ev.UNIT, epad.IDPADET 
             from dbo.EVENT ev 
             inner join dbo.EVENTCLASS ec on (ec.IDE = ev.IDE) and (ec.EVENTCLASS='VAL')
             inner join dbo.EVENTPOSACTIONDET epad on (epad.IDE = ev.IDE)
             where (ev.EVENTTYPE ='RMG') and (ev.IDT = @IDT)
        ) rmg on (rmg.IDPADET=pad.IDPADET) and (rmg.IDT = pad.TRADE_IDT or rmg.IDT = pad.TRADE2_IDT)
        where (pad.TRADE_IDT=@IDT or pad.TRADE2_IDT=@IDT) and (pad.DTUNCLEARING is not null);
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- 
  RD 20161031 [22570] Annulation des actions de dénouement avec le statut Warning
  FI 20160407 [22064]  
    Mode annulation : => Annulation possible des actions (autre que Annulation) en succès ou Annulation des POSREQUEST Mode EOD en PENDING  
    (Rq: Comportement identique depuis l'écran de saisie trade des denouements)
  
  FI 20160407 [22061] la jointure sur l'alias pr s'appuie désormais sur DTENTITY 
  EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)
  EG 20220928 [26125][WI445] UPD MPD
  -->
  <item name="DENBULK_PRESELECT">
    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table %%PARAM1%%_%%SHORTSESSIONID%%_W;
          truncate table Q%%PARAM1%%_%%SHORTSESSIONID%%_W;
          truncate table PA%%PARAM1%%_%%SHORTSESSIONID%%_W;
			  ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[truncate table %%PARAM1%%_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[truncate table Q%%PARAM1%%_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[truncate table PA%%PARAM1%%_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[insert into PA%%PARAM1%%_%%SHORTSESSIONID%%_W (IDT,QTY,QTY2)
            select pad.IDT_BUY as IDT, sum(pad.QTY) as QTY,
            sum(case when pa.DTBUSINESS = em.DTENTITY  
            <choose>
              <when test="%%PARAM1%% contains 'ASSEXEBULK'">and (pr.REQUESTTYPE in ('ASS','EXE'))</when>
              <when test="%%PARAM1%% contains 'ABNBULK'">and (pr.REQUESTTYPE in ('ABN','NEX','NAS'))</when>
            </choose>
            then 0 else pad.QTY end) as QTY2
            from dbo.POSACTION pa
            inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
            inner join dbo.POSACTIONDET pad   on (pad.IDPA = pa.IDPA)
            inner join dbo.TRADE tr on (tr.IDT = pad.IDT_BUY)
            inner join dbo.ENTITYMARKET em on (em.IDM = tr.IDM) and (em.IDA = tr.IDA_ENTITY) <choose><when test="{MARKET}>-1"> and em.IDM=@MARKET</when></choose> <choose><when test="{ENTITY}>-1"> and em.IDA=@ENTITY</when></choose>
            where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY)) and (pa.DTOUT is null or pa.DTOUT > em.DTENTITY)
            group by pad.IDT_BUY
            union all
            select pad.IDT_SELL as IDT, sum(pad.QTY) as QTY,
            sum(case when pa.DTBUSINESS = em.DTENTITY  
            <choose>
              <when test="%%PARAM1%% contains 'ASSEXEBULK'">and (pr.REQUESTTYPE in ('ASS','EXE'))</when>
              <when test="%%PARAM1%% contains 'ABNBULK'">and (pr.REQUESTTYPE in ('ABN','NEX','NAS'))</when>
            </choose>
            then 0 else pad.QTY end) as QTY2
            from dbo.POSACTION pa
            inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
            inner join dbo.POSACTIONDET pad on (pad.IDPA = pa.IDPA)
            inner join dbo.TRADE tr on (tr.IDT = pad.IDT_SELL)
            inner join dbo.ENTITYMARKET em on (em.IDM = tr.IDM) and (em.IDA = tr.IDA_ENTITY) <choose><when test="{MARKET}>-1"> and em.IDM=@MARKET</when></choose><choose><when test="{ENTITY}>-1"> and em.IDA=@ENTITY</when></choose>
            where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY)) and (pa.DTOUT is null or pa.DTOUT > em.DTENTITY)
            group by pad.IDT_SELL;
        ]]>
      </Command>
    </sqlCommand>
    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
          /* Spheres:Hint ARITHABORT_ON NOPARAMS */
          insert into %%PARAM1%%_%%SHORTSESSIONID%%_W
          (IDT, DTBUSINESS, IDI, IDM, ASSETCATEGORY, IDASSET, IDA_ENTITY, IDA_CSSCUSTODIAN, 
          IDA_DEALER, IDB_DEALER,  IDA_CLEARER, IDB_CLEARER, IDEM, DTENTITY, DTMARKET, 
          SIDE, INITIALQTY, POSQTY, AVAILABLEQTY, IDPR, REQUESTTYPE, DENQTY, NBIDPR)
          select 
          tr.IDT, tr.DTBUSINESS, tr.IDI, tr.IDM, tr.ASSETCATEGORY, tr.IDASSET, tr.IDA_ENTITY, mk.IDA as IDA_CSSCUSTODIAN, 
          tr.IDA_DEALER, tr.IDB_DEALER,  tr.IDA_CLEARER, tr.IDB_CLEARER, em.IDEM, em.DTENTITY, em.DTMARKET, tr.SIDE, tr.QTY, 
          tr.QTY - isnull(pa.QTY,0), 
          tr.QTY - isnull(pa.QTY2,0),
          case when isnull(pr.NBIDPR,0) = 1 then pr.IDPR else null end as IDPR, pr.REQUESTTYPE, isnull(pr.DENQTY, 0), isnull(pr.NBIDPR,0)
          from dbo.TRADE tr
          %%CC:ITRADE_JOIN%%(tr)
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr)
          inner join dbo.MARKET mk on (mk.IDM = tr.IDM)
		      inner join dbo.VW_INSTR_PRODUCT i on (i.IDI = tr.IDI)  and (i.GPRODUCT = 'FUT')
          inner join dbo.BOOK b on b.IDB = tr.IDB_DEALER and b.ISPOSKEEPING = 1
          inner join dbo.ENTITYMARKET em on (em.IDM = tr.IDM ) and (em.IDA = tr.IDA_ENTITY) and (em.IDA_CUSTODIAN is null)
          inner join dbo.ASSET_ETD etd on (etd.IDASSET = tr.IDASSET)
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = etd.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC)
          inner join dbo.MATURITY ma on (ma.IDMATURITY = da.IDMATURITY)
          /* Jointure sur EVT ExerciseDate : Si EUR alors DTMARKET = ev.DTENDADJ (exercice autorisé à l'échéance exclusivement)  */
          inner join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'EXD') and (ev.DTENDADJ = case ev.EVENTTYPE when 'EUR' then em.DTMARKET else ev.DTENDADJ end)
                      
          /* On récupère les POSREQUEST des demandes du jour s'il en existe */
          <choose>
          <when test="{DENOPTIONACTIONTYPE}='remove'">inner join</when>
          <otherwise>left outer join</otherwise>
          </choose>
          (
            select pr.IDT, pr.DTBUSINESS, pr.REQUESTTYPE, 
            sum(case pr.STATUS 
              when 'SUCCESS' then pr.QTY
              when 'WARNING' then pr.QTY
              else 0 end) as DENQTY, 
            max(pr.IDPR) as IDPR, count(pr.IDT) as NBIDPR
            from dbo.POSREQUEST pr
            <choose>
              <when test="{DENOPTIONACTIONTYPE}='remove'">
              where (((pr.STATUS in ('SUCCESS','WARNING')) and (0 &lt; pr.QTY)) or ((pr.REQUESTMODE='EOD') and (pr.STATUS='PENDING'))) 
              </when>
              <otherwise>
              where (pr.STATUS in ('PENDING','SUCCESS','WARNING') and (0 &lt; pr.QTY))
              </otherwise>
            </choose>
            <choose>
              <when test="%%PARAM1%% contains 'ASSEXEBULK'">and (pr.REQUESTTYPE in ('ASS','EXE'))</when>
              <when test="%%PARAM1%% contains 'ABNBULK'">and (pr.REQUESTTYPE in ('ABN','NEX','NAS'))</when>
              <otherwise>and (pr.REQUESTTYPE in ('ABN','NEX','NAS','ASS','EXE'))</otherwise>
            </choose>
            group by 
            <choose>
            <when test="{DENOPTIONACTIONTYPE}='remove'">pr.IDPR, pr.IDT, pr.DTBUSINESS, pr.REQUESTTYPE</when>
            <otherwise>pr.IDT, pr.DTBUSINESS, pr.REQUESTTYPE</otherwise>
            </choose>
          ) pr on (pr.IDT = tr.IDT) and (pr.DTBUSINESS = em.DTENTITY) 
          
          left outer join PA%%PARAM1%%_%%SHORTSESSIONID%%_W pa on (pa.IDT = tr.IDT)
          
          where 
          <choose>
            <when test="{DENOPTIONACTIONTYPE}='newRemaining'">(tr.QTY - isnull(pa.QTY,0)  &gt; 0 ) and </when>
            <when test="{DENOPTIONACTIONTYPE}='new'">(tr.QTY - isnull(pa.QTY2,0)  &gt; 0) and (isnull(pr.NBIDPR,0) &lt;= 1) and </when>
            <otherwise>(tr.QTY - isnull(pa.QTY2,0)  &gt; 0) and </otherwise>
          </choose>
          (tr.DTBUSINESS <= em.DTMARKET) and (em.DTMARKET <= isnull(isnull(ma.MATURITYDATE, ma.MATURITYDATESYS),em.DTMARKET))
          <choose><when test="{MARKET}>-1"> and tr.IDM=@MARKET</when></choose><choose><when test="{ENTITY}>-1"> and tr.IDA_ENTITY=@ENTITY</when></choose>
          and (tr.IDSTACTIVATION = 'REGULAR') and (tr.IDSTBUSINESS = 'ALLOC')
          and (%%CC:ITRADE_WHERE_PREDICATE%%)
          and (%%SR:TRADEALLOC_WHERE_PREDICATE%%);
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
        insert into Q%%PARAM1%%_%%SHORTSESSIONID%%_W
        (DTMARKET, IDASSET, IDASSET_UNL, ASSETCATEGORY_UNL, IDQUOTE_H, VALUE, TIME, QUOTESIDE, QUOTETIMING, SOURCE, ITM_OTM)
        select assetQuoteUnl.DTMARKET, asset.IDASSET, assetQuoteUnl.IDASSET_UNL, assetQuoteUnl.ASSETCATEGORY_UNL, 
        quote_last.IDQUOTE_H, quote_last.VALUE, quote_last.TIME, quote_last.QUOTESIDE, quote_last.QUOTETIMING, quote_last.SOURCE,
        case when quote_last.IDQUOTE_H is null then 'N/A'
             when (asset.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE) then 'In the money'
             when (asset.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE) then 'Out the money'
             when (asset.PUTCALL='1' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE)
                  then case when assetQuoteUnl.ITMCONDITION in ('1','2') then 'At the money (ITM)' else 'At the money (OTM)' end
             when (asset.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE > quote_last.VALUE) then 'In the money'
             when (asset.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE < quote_last.VALUE) then 'Out the money'
             when (asset.PUTCALL='0' and assetQuoteUnl.STRIKE_PRICE = quote_last.VALUE) 
                then case when assetQuoteUnl.ITMCONDITION in ('1','3') then 'At the money (ITM)' else 'At the money (OTM)' end
        else 'N/A' end as ITM_OTM
        from
        (
          select posdet.DTMARKET, asset.IDASSET as IDASSET, asset_unl.IDASSET as IDASSET_UNL, 'Future' as ASSETCATEGORY_UNL ,
		      case when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and (dc_unl.INSTRUMENTDEN%100) = 0 then asset.STRIKEPRICE
               else floor(asset.STRIKEPRICE) + ((asset.STRIKEPRICE - floor(asset.STRIKEPRICE)) * 
                    case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
                    (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end)) end as STRIKE_PRICE, dc.ITMCONDITION,
			    (
				    select top 1 IDQUOTE_H
				    from dbo.VW_QUOTE_H quote
				    where (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') and 
                  (quote.ISENABLED=1) and (quote.TIME < (posdet.DTMARKET+1)) and (quote.IDASSET = asset_unl.IDASSET) and (quote.ASSETCATEGORY= 'Future')
						order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc	 				
          ) as IDQUOTE_H_UNL
          from dbo.ASSET_ETD asset
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) and (dc.ASSETCATEGORY = 'Future')
          inner join dbo.ASSET_ETD asset_unl on (asset_unl.IDASSET = da.IDASSET)
          inner join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
          inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET)
      
          union all 
    
          select posdet.DTMARKET, asset.IDASSET as IDASSET, vw_asset_unl.IDASSET as IDASSET_UNL, vw_asset_unl.ASSETCATEGORY as ASSETCATEGORY_UNL, 
          asset.STRIKEPRICE as STRIKE_PRICE, dc.ITMCONDITION,
          (
				    select top 1 IDQUOTE_H
				    from dbo.VW_QUOTE_H quote
				    where (quote.QUOTESIDE='Mid' or quote.QUOTESIDE is null or quote.QUOTESIDE='OfficialClose' or quote.QUOTESIDE='OfficialSettlement') and
				          (quote.ISENABLED=1) and quote.TIME < (posdet.DTMARKET+1)  and (quote.IDASSET = vw_asset_unl.IDASSET) and (quote.ASSETCATEGORY= vw_asset_unl.ASSETCATEGORY)
				    order by quote.TIME desc, case isnull(quote.QUOTESIDE,'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc	 				
			    ) as IDQUOTE_H_UNL
          from dbo.ASSET_ETD asset
          inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
          inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) and (dc.ASSETCATEGORY != 'Future')
          inner join dbo.VW_ASSET vw_asset_unl on (vw_asset_unl.ASSETCATEGORY = dc.ASSETCATEGORY) and (vw_asset_unl.IDASSET = dc.IDASSET_UNL)
          inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET)
        ) assetQuoteUnl
        inner join dbo.ASSET_ETD asset on (asset.IDASSET = assetQuoteUnl.IDASSET)
        inner join dbo.VW_QUOTE_H quote_last on (quote_last.IDQUOTE_H = assetQuoteUnl.IDQUOTE_H_UNL) and
				                                  			(quote_last.IDASSET = assetQuoteUnl.IDASSET_UNL) and 
                                                (quote_last.ASSETCATEGORY = assetQuoteUnl.ASSETCATEGORY_UNL);
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
        insert into Q%%PARAM1%%_%%SHORTSESSIONID%%_W
        (DTMARKET, IDASSET, IDASSET_UNL, ASSETCATEGORY_UNL, IDQUOTE_H, VALUE, TIME, QUOTESIDE, QUOTETIMING, SOURCE, ITM_OTM)
        select posdet.DTMARKET, asset.IDASSET, vw_asset_unl.IDASSET, vw_asset_unl.ASSETCATEGORY, 
        null, null, null, null, null, null, null
        from dbo.ASSET_ETD asset
        inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
        inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) 
        inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc.ASSETCATEGORY and (dc.ASSETCATEGORY != 'Future' and vw_asset_unl.IDASSET=dc.IDASSET_UNL)
        inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET)
        union all
        select posdet.DTMARKET, asset.IDASSET, vw_asset_unl.IDASSET, vw_asset_unl.ASSETCATEGORY, 
        null, null, null, null, null, null, null
        from dbo.ASSET_ETD asset
        inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
        inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) 
        inner join dbo.VW_ASSET vw_asset_unl on vw_asset_unl.ASSETCATEGORY=dc.ASSETCATEGORY and (dc.ASSETCATEGORY = 'Future' and vw_asset_unl.IDASSET=da.IDASSET)
        inner join (select distinct IDASSET, DTMARKET from %%PARAM1%%_%%SHORTSESSIONID%%_W) posdet on (posdet.IDASSET = asset.IDASSET)
        ]]>
      </Command>
      <Command rdbms = "oracle">
        <![CDATA[
        declare quote dbo.VW_QUOTE_H%ROWTYPE;
        found boolean ;  

        cursor c1 is
        select quote_w.DTMARKET, quote_w.IDASSET, quote_w.IDASSET_UNL, quote_w.ASSETCATEGORY_UNL, quote_w.IDQUOTE_H, asset.PUTCALL,
        case when quote_w.ASSETCATEGORY_UNL = 'Future' then
          case when isnull(dc_unl.INSTRUMENTNUM,1) <= 1 and dc_unl.INSTRUMENTDEN >= 100 and mod(dc_unl.INSTRUMENTDEN,100) = 0 then asset.STRIKEPRICE
               else floor(asset.STRIKEPRICE) + ((asset.STRIKEPRICE - floor(asset.STRIKEPRICE)) * 
                    case when isnull(dc_unl.INSTRUMENTDEN,0)<=0 then 1 else dc_unl.INSTRUMENTDEN end / 
                    (100 * case when isnull(dc_unl.INSTRUMENTNUM,0)=0 then 1 else dc_unl.INSTRUMENTNUM end)) end
               else asset.STRIKEPRICE end as STRIKE_PRICE, dc.ITMCONDITION
        from Q%%PARAM1%%_%%SHORTSESSIONID%%_W quote_w
        inner join dbo.ASSET_ETD asset on asset.IDASSET = quote_w.IDASSET
        inner join dbo.DERIVATIVEATTRIB da on (da.IDDERIVATIVEATTRIB = asset.IDDERIVATIVEATTRIB)
        inner join dbo.DERIVATIVECONTRACT dc on (dc.IDDC = da.IDDC) 
        left outer join dbo.ASSET_ETD asset_unl on (quote_w.ASSETCATEGORY_UNL = 'Future' and asset_unl.IDASSET = quote_w.IDASSET_UNL)
        left outer join dbo.DERIVATIVEATTRIB da_unl on (da_unl.IDDERIVATIVEATTRIB = asset_unl.IDDERIVATIVEATTRIB)
        left outer join dbo.DERIVATIVECONTRACT dc_unl on (dc_unl.IDDC = da_unl.IDDC)
        order by quote_w.IDASSET_UNL 
        for update;

        begin
        for row1 in c1
        loop
          found:= true;
          begin
              select quote.* into quote 
              from dbo.VW_QUOTE_H quote
              where ((quote.QUOTESIDE = 'Mid') or (quote.QUOTESIDE is null) or  (quote.QUOTESIDE = 'OfficialClose') or (quote.QUOTESIDE = 'OfficialSettlement'))
              and (quote.ISENABLED = 1) and (quote.TIME < (row1.DTMARKET+1)) and (quote.IDASSET = row1.IDASSET_UNL) and (quote.ASSETCATEGORY = row1.ASSETCATEGORY_UNL)
              order by quote.TIME desc, case nvl(quote.QUOTESIDE, 'OfficialClose') when 'OfficialSettlement' then 0 when 'OfficialClose' then 1 else 2 end asc
              fetch first 1 rows only;
            exception when NO_DATA_FOUND then found:= false;
            end;
      
            if (found) then
              update Q%%PARAM1%%_%%SHORTSESSIONID%%_W
              set IDQUOTE_H  = quote.IDQUOTE_H, VALUE = quote.VALUE, TIME = quote.TIME, QUOTESIDE = quote.QUOTESIDE, QUOTETIMING = quote.QUOTETIMING, SOURCE = quote.SOURCE,
              ITM_OTM = 
              ( 
                case
	              when (row1.PUTCALL='1' and row1.STRIKE_PRICE < quote.VALUE) then 'In the money'
                when (row1.PUTCALL='1' and row1.STRIKE_PRICE > quote.VALUE) then 'Out the money'
                when (row1.PUTCALL='1' and row1.STRIKE_PRICE = quote.VALUE) 
                       then case when row1.ITMCONDITION in ('1','2') then 'At the money (ITM)' else 'At the money (OTM)' end
                when (row1.PUTCALL='0' and row1.STRIKE_PRICE > quote.VALUE) then 'In the money'
                when (row1.PUTCALL='0' and row1.STRIKE_PRICE < quote.VALUE) then 'Out the money'
	              when (row1.PUTCALL='0' and row1.STRIKE_PRICE = quote.VALUE)
                      then case when row1.ITMCONDITION in ('1','3') then 'At the money (ITM)' else 'At the money (OTM)' end
                else 'N/A' end
              )
              where current of c1;
            end if;
        end loop;
      end;
      ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20170317 [22967] Add GPRODUCT -->
  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <!-- EG 20220928 [26125][WI445] UPD MPD -->
  <item name="CLEARINGBULK_PRESELECT">

    <sqlCommand>
      <Command rdbms = "sqlserver">
        <![CDATA[
          truncate table CLEARINGBULK_%%SHORTSESSIONID%%_W;
			  ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "oracle">
        <![CDATA[
          truncate table CLEARINGBULK_%%SHORTSESSIONID%%_W purge MATERIALIZED VIEW LOG reuse STORAGE
        ]]>
      </Command>
    </sqlCommand>

    <sqlCommand>
      <Command rdbms = "all">
        <![CDATA[
          /* Spheres:Hint ARITHABORT_ON NOPARAMS */
          insert into CLEARINGBULK_%%SHORTSESSIONID%%_W
          (IDI, IDM, ASSETCATEGORY, IDASSET, IDA_ENTITY, IDA_CSSCUSTODIAN, 
          IDA_DEALER, IDB_DEALER,  IDA_CLEARER, IDB_CLEARER, IDEM, DTENTITY, ISCUSTODIAN, 
          QTY_BUY, QTY_SELL, GPRODUCT)
          select 
          tr.IDI, tr.IDM, tr.ASSETCATEGORY, tr.IDASSET, tr.IDA_ENTITYDEALER as IDA_ENTITY, tr.IDA_CSSCUSTODIAN, 
          tr.IDA_DEALER, tr.IDB_DEALER,  tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDEM, tr.DTENTITY, tr.ISCUSTODIAN,
          sum(case when tr.SIDE = 1 then (tr.QTY - isnull(pab.QTY,0)) else 0 end) as QTY_BUY,
          sum(case when tr.SIDE = 2 then (tr.QTY - isnull(pas.QTY,0)) else 0 end) as QTY_SELL, tr.GPRODUCT
          from dbo.VW_TRADE_FUNGIBLE tr
          %%CC:ITRADE_JOIN%%(tr)
          %%SR:TRADEALLOC_JOIN%%(tr.IDT,tr)
          left outer join 
          (   
              select pad.IDT_BUY as IDT, sum(pad.QTY) as QTY
              from dbo.POSACTION pa
              inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
              inner join dbo.POSACTIONDET pad   on (pad.IDPA = pa.IDPA)
              inner join dbo.ENTITYMARKET em on (em.IDEM = pr.IDEM)          
              where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY)) and (pa.DTOUT is null or pa.DTOUT > em.DTENTITY)
              group by pad.IDT_BUY
              
          ) pab  on (pab.IDT = tr.IDT)

          left outer join 
          (   
            select pad.IDT_SELL as IDT, sum(pad.QTY) as QTY
            from dbo.POSACTION pa
            inner join dbo.POSREQUEST pr on (pr.IDPR = pa.IDPR)
            inner join dbo.POSACTIONDET pad on (pad.IDPA = pa.IDPA)
            inner join dbo.ENTITYMARKET em on (em.IDEM = pr.IDEM)          
            where (pa.DTBUSINESS <= em.DTENTITY) and (pad.DTCAN is null or (pad.DTCAN > em.DTENTITY)) and (pa.DTOUT is null or pa.DTOUT > em.DTENTITY)
            group by pad.IDT_SELL
            
          ) pas  on (pas.IDT = tr.IDT)

          where (tr.DTTRADE <= tr.DTENTITY) and (tr.DTBUSINESS <= tr.DTENTITY) and (tr.DTOUT is null or tr.DTOUT > tr.DTMARKET) and 
                (tr.IDA_ENTITYDEALER = case when -1=@ENTITY  then tr.IDA_ENTITYDEALER else @ENTITY end) and 
                (tr.IDA_CSSCUSTODIAN = case when (@CSSCUSTODIAN<0) then tr.IDA_CSSCUSTODIAN else @CSSCUSTODIAN end) and 
                (tr.ISCUSTODIAN = case when (@CSSCUSTODIAN=-2) then 0 else tr.ISCUSTODIAN end) and 
                (tr.ISCSS = case when (@CSSCUSTODIAN=-3) then 0 else tr.ISCSS end) and
                (tr.POSKEEPBOOK_DEALER = 1) and (%%SR:TRADEALLOC_WHERE_PREDICATE%%) and (%%CC:ITRADE_WHERE_PREDICATE%%)
                
                
          group by  tr.IDM, tr.DTENTITY, tr.IDI, tr.IDASSET, tr.IDEM, tr.IDA_CSSCUSTODIAN, tr.ASSETCATEGORY,
                    tr.IDA_DEALER, tr.IDB_DEALER, tr.IDA_ENTITYDEALER, 
                    tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDA_ENTITYCLEARER, tr.ISCUSTODIAN, tr.GPRODUCT
                      
          having  (sum(case when tr.SIDE = 1 then (tr.QTY - isnull(pab.QTY,0)) else 0 end) > 0) and
                  (sum(case when tr.SIDE = 2 then (tr.QTY - isnull(pas.QTY,0)) else 0 end) > 0);
                
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="FLOWSBYTRADE_SELECT">
    <sqlCommand>
      <!--
      EG 20180622 New
      -->
      <Command rdbms = "all">
        <![CDATA[/* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select 
        pr.IDP,
        tr.IDT, tr.IDI, tr.IDENTIFIER, tr.DTBUSINESS, isnull(tr.DTEXECUTION,tr.DTTIMESTAMP) as DTEXECUTION, tr.TZFACILITY,
        tr.IDM, tr.IDASSET, tr.ASSETCATEGORY, tr.IDA_DEALER, tr.IDB_DEALER, tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDA_CSSCUSTODIAN, tr.IDA_ENTITY, tr.SIDE, 
        tr.QTY, tr.UNITQTY, tr.STRIKEPRICE, tr.PRICE, tr.UNITPRICE, tr.DTDLVYSTART, tr.DTDLVYEND, tr.TZDLVY, tr.POSITIONEFFECT, 
        arCLIENT.IDA as IDA_CLIENT
        from dbo.TRADE tr
        %%CC:ITRADE_JOIN%%(tr)
        inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
        inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) 
        <choose> 
            <when test="{FILTER_ETDONLY}=1">
              and (pr.GPRODUCT = 'FUT')
            </when>
            <when test="{FILTER_COMONLY}=1">
              and (pr.GPRODUCT = 'COM')
            </when>
            <otherwise>
              and (pr.GPRODUCT in ('COM','FUT'))
            </otherwise>
        </choose>
        inner join dbo.BOOK bd on (bd.IDB = tr.IDB_DEALER)
        %%SR:TRADEALLOC_JOIN%%(tr.IDT, tr, bd)
		
        left outer join 
        (
          /* Cumul des quantités déjà compensées dans le cas des trades à l'Achat */
          select sum(pad.QTY) as QTY, pad.IDT_BUY as IDT
          from dbo.POSACTION pa
          inner join dbo.POSACTIONDET pad on pad.IDPA=pa.IDPA and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
          where (pa.DTBUSINESS < @DATE1 )
          group by pad.IDT_BUY
        ) tab on (tab.IDT = tr.IDT)
		
        left outer join 
        (
          /* Cumul des quantités déjà compensées dans le cas des trades à la Vente */
          select sum(pad.QTY) as QTY, pad.IDT_SELL as IDT
          from dbo.POSACTION pa
          inner join dbo.POSACTIONDET pad on pad.IDPA=pa.IDPA and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
          where (pa.DTBUSINESS < @DATE1 )
          group by pad.IDT_SELL
        ) tas on (tas.IDT = tr.IDT)
        
        left outer join 
        (
          select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')
        ) arCLIENT on (arCLIENT.IDA = tr.IDA_DEALER)
        where (tr.IDSTBUSINESS = 'ALLOC') and (tr.IDSTACTIVATION = 'REGULAR') and 
        (
		      /* Affichage des trades du jour (pour les books dealer avec ou sans tenue de position) */
		      (tr.DTBUSINESS=@DATE1)
		      or
	        /* Affichage des trades en position pour les books dealer avec tenue de position */
	        ((tr.DTBUSINESS < @DATE1) and (bd.ISPOSKEEPING = 1) and (tr.QTY - isnull(tab.QTY,0) - isnull(tas.QTY,0) > 0 ))
        )
        and (%%CC:ITRADE_WHERE_PREDICATE%%)
        and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
        ]]>
      </Command>
    </sqlCommand>
  </item>

  <!-- EG 20200226 [25077] RDBMS : New version of Trades tables architecture (TRADEINSTRUMENT (INSTRUMENTNO=1) to TRADE)-->
  <item name="FLOWSBYTRADEOTC_SELECT">
    <sqlCommand>
      <!--
      EG 20180622 New
      -->
      <Command rdbms = "all">
        <![CDATA[/* Spheres:Hint ARITHABORT_ON NOPARAMS */
        select 
        pr.IDP,
        tr.IDT, tr.IDI, tr.IDENTIFIER, tr.DTBUSINESS, isnull(tr.DTEXECUTION,tr.DTTIMESTAMP) as DTEXECUTION, tr.TZFACILITY,
        tr.IDM, tr.IDASSET, tr.ASSETCATEGORY, tr.IDA_DEALER, tr.IDB_DEALER, tr.IDA_CLEARER, tr.IDB_CLEARER, tr.IDA_CSSCUSTODIAN, tr.IDA_ENTITY, tr.SIDE, 
        tr.QTY, tr.UNITQTY, tr.STRIKEPRICE, tr.PRICE, tr.UNITPRICE, tr.DTDLVYSTART, tr.DTDLVYEND, tr.TZDLVY, tr.POSITIONEFFECT, 
        tr.QTY - isnull(tab.QTY,0) - isnull(tas.QTY,0) as QTY_ASSESSED, arCLIENT.IDA as IDA_CLIENT
        from dbo.TRADE tr
        %%CC:ITRADE_JOIN%%(tr)
        inner join dbo.INSTRUMENT ns on (ns.IDI = tr.IDI)
        inner join dbo.PRODUCT pr on (pr.IDP = ns.IDP) 
        <choose> 
          <when test="{FILTER_RTSONLY}=1">
            and (pr.GPRODUCT = 'OTC') and (pr.FAMILY = 'RTS')
          </when>
          <when test="{FILTER_DSTONLY}=1">
            and (pr.GPRODUCT = 'SEC') and (pr.FAMILY = 'DSE')
          </when>
          <when test="{FILTER_ESTONLY}=1">
            and (pr.GPRODUCT = 'SEC') and (pr.FAMILY = 'ESE')
          </when>
          <otherwise>
            and (pr.GPRODUCT in ('OTC','SEC', 'FX'))
          </otherwise>
        </choose>
        inner join dbo.BOOK bd on (bd.IDB = tr.IDB_DEALER)
        %%SR:TRADEALLOC_JOIN%%(tr.IDT, tr, bd)
        
        <choose> 
          <when test="{FILTER_RTSONLY}=0 and {FILTER_ESTONLY}=0">
            left outer join dbo.EVENT ev on (ev.IDT = tr.IDT) and (ev.EVENTCODE = 'INT') and (ev.EVENTTYPE = 'INT')  
            left outer join dbo.EVENTCLASS ecint on (ecint.IDE = ev.IDE) and (ecint.DTEVENT = @DATE1)  and (ecint.EVENTCLASS = 'VAL')
          </when>
        </choose>
		
        left outer join 
        (
          /* Cumul des quantités déjà compensées dans le cas des trades à l'Achat */
          select sum(pad.QTY) as QTY, pad.IDT_BUY as IDT
          from dbo.POSACTION pa
          inner join dbo.POSACTIONDET pad on (pad.IDPA = pa.IDPA) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
          where (pa.DTBUSINESS < @DATE1 )
          group by pad.IDT_BUY
        ) tab on (tab.IDT = tr.IDT)
		
        left outer join 
        (
          /* Cumul des quantités déjà compensées dans le cas des trades à la Vente */
          select sum(pad.QTY) as QTY, pad.IDT_SELL as IDT
          from dbo.POSACTION pa
          inner join dbo.POSACTIONDET pad on (pad.IDPA = pa.IDPA) and ((pad.DTCAN is null) or (pad.DTCAN > @DATE1))
          where (pa.DTBUSINESS < @DATE1 )
          group by pad.IDT_SELL
        ) tas on (tas.IDT = tr.IDT)
        
        left outer join 
        (
          select distinct IDA from dbo.ACTORROLE where (IDROLEACTOR='CLIENT')
        ) arCLIENT on (arCLIENT.IDA = tr.IDA_DEALER)
        where (tr.IDSTBUSINESS = 'ALLOC') and (tr.IDSTACTIVATION = 'REGULAR') and 
        (
		      /* Affichage des trades du jour (pour les books dealer avec ou sans tenue de position) */
          (tr.DTBUSINESS = @DATE1)
          or
	        /* Affichage des trades en position pour les books dealer avec tenue de position */
	        ((tr.DTBUSINESS < @DATE1) and (bd.ISPOSKEEPING = 1) and (tr.QTY - isnull(tab.QTY,0) - isnull(tas.QTY,0) > 0 ))
          <choose> 
            <when test="{FILTER_RTSONLY}=0 and {FILTER_DSTONLY}=0 and {FILTER_ESTONLY}=0">
              or
              (case when pr.IDENTIFIER='debtSecurityTransaction' and ecint.IDE is not null then 1 else 0 end = 1)
            </when>
        </choose>
        )
        and (%%SR:TRADEALLOC_WHERE_PREDICATE%%)
        and (%%CC:ITRADE_WHERE_PREDICATE%%)
        ]]>
      </Command>
    </sqlCommand>
  </item>

</sqlCommands>
